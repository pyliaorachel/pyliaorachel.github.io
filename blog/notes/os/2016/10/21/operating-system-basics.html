<!DOCTYPE html>
<html>
	<head>
		<title>Operating System - Basics</title>
		<link rel="stylesheet" href="/css/bootstrap.min.css" type="text/css">
		<link rel="stylesheet" href="/css/main.css" type="text/css">
		<link href="https://fonts.googleapis.com/css?family=Antic+Slab|Catamaran|Hind:300|Inconsolata|Josefin+Sans|Muli:300,400i|Poiret+One|Rajdhani:300|Rock+Salt|Ruda|Scope+One|Shadows+Into+Light|Source+Code+Pro|Space+Mono" rel="stylesheet">
		<link rel="stylesheet" href="/css/github-markdown.css">

		<!-- Place jquery before bootstrap -->
		<script type="text/javascript" src="/js/jquery.min.js"></script>
		<script type="text/javascript" src="/js/bootstrap.min.js"></script>
	</head>
	<body>
		<nav class="navbar navbar-default navbar-fixed-top">
	<div class="container-fluid">

		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">MyCoon</a>
		</div>

		<div class="collapse navbar-collapse" id="navbar-collapse">

			<form class="navbar-form navbar-left">
				<div class="form-group">
					<input type="text" class="form-control" placeholder="Search">
				</div>
				<button type="submit" class="btn btn-default">Submit</button>
			</form>

			<ul class="nav navbar-nav navbar-right" id="nav-links">
				<li class="nav-home"><a href="/">Home</a></li>
				<li class="dropdown nav-blog">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Blog<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="/blog">MyCoon Blog</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="/blog/categories">Categories</a></li>
						
							
						

						
							
							
							<li class="category">
								<a href="/blog/tech">
									<span>Tech</span>
									<span>2</span>
								</a>
							</li>
						
							
							
							<li class="category">
								<a href="/blog/notes">
									<span>Notes</span>
									<span>21</span>
								</a>
							</li>
						
						<li><a href="/blog/tags">Tags</a></li>
					</ul>
				</li>
				<li class="dropdown nav-tutorial">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Tutorials<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="/tutorial">MyCoon Tutorial</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="/tutorial/categories">Categories</a></li>
						
							
						

						
						<li><a href="/tutorial/tags">Tags</a></li>
					</ul>
				</li>
				<li  class="nav-project"><a href="/project">Projects</a></li>
				<li class="nav-special" id="special"><a href="#">?</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</div><!-- /.container-fluid -->
</nav>
		<main class="page-content post" aria-label="Content">
	<div class="post-wrapper">
		<div class="wrapper">
	<article class="post-article" itemscope itemtype="http://schema.org/BlogPosting">

		<header class="post-header">
			<h1 class="post-title" itemprop="name headline">Operating System - Basics</h1>
			<p class="post-meta">Oct 21, 2016
				 • Notes
				 • pyliaorachel
			</p>
		</header>

		

		<span class="separator"> • • • </span>

		<div class="post-content" itemprop="articleBody">
			<h2>Content</h2>

<ol>
<li>Basics of OS</li>
<li>OS Design</li>
<li>Hardware</li>
<li>OS-Related Hardware</li>
</ol>

<!--more-->

<hr>

<h2>Basics of OS</h2>

<ul>
<li>Layer of <code>software</code> between <code>hardware &amp; applications</code>

<ul>
<li>Application dedicated to a single task; OS serves all applications</li>
<li>Also called <code>systems software</code></li>
</ul></li>
</ul>

<h3><strong>What OS does</strong></h3>

<ul>
<li>Manage H/W resources

<ul>
<li>Allows programs to interact with H/W

<ul>
<li>CPU, memory, disk, graphics card, co-processors, ...</li>
<li>Simpler interface to devices

<ul>
<li>e.g. access disk as files</li>
<li><em>If NOT, apps have to be written to specific H/W devices directly -&gt; deal with all the specific H/W stuffs -&gt; not compatible to another manufacturer&#39;s device</em></li>
</ul></li>
</ul></li>
<li>Allows running many programs at the same time

<ul>
<li>Programs share CPU, memory</li>
<li>Isolates apps from each other

<ul>
<li><em>If NOT, then memory corruption a problem</em></li>
</ul></li>
<li>Isolates itself from apps

<ul>
<li><em>If NOT, then OS has to compromise for apps; apps may corrupt OS and no isolations provided to them</em></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h2>OS Design</h2>

<h3>Key Ideas</h3>

<ul>
<li>How does OS allow running many programs?

<ul>
<li><code>Virtualization</code> - programs share resources securely</li>
</ul></li>
<li>How does OS allow programs to interact with H/W?

<ul>
<li><code>Abstraction</code> for H/W</li>
<li>Implemented via <code>System calls</code></li>
</ul></li>
</ul>

<h3><strong>Virtualization</strong></h3>

<ul>
<li>Programs think:

<ul>
<li>They are running on their own machine (but only one physical machine!)</li>
<li>They have full access to CPU, memory, disk</li>
</ul></li>
<li>Benefits

<ul>
<li><code>Resource isolation</code> (an ideal virtual machine)

<ul>
<li>Program cannot accidentally overwrite others&#39; memory or files</li>
<li>Ideally, if a program uses too much memory, only its performance degrades</li>
</ul></li>
<li>Improves <strong>portablity</strong> of programs</li>
</ul></li>
<li>An ideal virtual machine ~ physical machine, i.e. programs won&#39;t affect each other</li>
<li>Implementation

<ul>
<li><strong>Processor -&gt; Threads</strong></li>
<li><strong>Memory -&gt; Virtual Memory</strong>

<ul>
<li>Contiguous &amp; private memory</li>
<li>Illusion of access to large amount of memory</li>
</ul></li>
<li><strong>Disk -&gt; Files</strong></li>
<li><strong>Network -&gt; Sockets</strong>

<ul>
<li>Hides details of network protocols &amp; layers</li>
</ul></li>
</ul></li>
</ul>

<h3><strong>Abstraction</strong></h3>

<ul>
<li>Eases programming, improves <strong>portability</strong></li>
</ul>

<h4>Concurrency</h4>

<ul>
<li><code>Thread abstraction</code> allows program to concurrently perform several tasks

<ul>
<li><em>Race condition?</em></li>
</ul></li>
</ul>

<h4>System Calls</h4>

<ul>
<li>Program request H/W access via <code>system calls</code></li>
<li><code>OS API</code>: a set of system calls</li>
<li>Requires control transfer from <code>user space</code> to <code>kernel space</code> via <code>interrupts</code> or <code>traps</code></li>
<li>e.g.

<ul>
<li>Create/destroy process (<em>process-related system calls</em>)</li>
<li>Allocate/deallocate memory from system (<em>memory-related system calls</em>)</li>
<li>Read/write a file</li>
</ul></li>
<li><p>Ex.</p>
<div class="highlight"><pre><code class="language-" data-lang="">    Program | Library
    -----------------
        OS Kernel                           # program read() 
    -----------------                       # -&gt; library generates trap 
           H/W                              # -&gt; trap invokes kernel 
                                            # -&gt; kernel accesses disk 
    Program (read) -&gt; library               # -&gt; kernel returns results to program
    ------------------(trap)--^----                 
        OS Kernel        |    |
    ---------------------v-(result)
                H/W             
</code></pre></div></li>
</ul>

<h4>OS Interface</h4>

<ul>
<li><code>OS interface</code> to H/W = set of <strong>system calls</strong></li>
<li><code>VM interface</code> to H/W = subset of physical machine interface + OS interface</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">    * Application Layer

    * OS Interface 
(system calls: thread_create(), read(), write(), thread_join(), ...)

    (when program needs access to devices)
------------virtual machine interface--------
    * OS Kernel                             |
(thread scheduler, memory mgmt,             |
device mgmt, file sys, network comm,        |
protection, process mgmt, security, ...)    |   (when program runs most instructions)
                                            |
-----------physical machine interface---------virtual/physical machine interface-------
                                                    (user mode interface)
    * H/W Layer
(network, CPU, memory, printer, video card, monitor, disk, ...)
</code></pre></div>
<h2>Hardware</h2>

<h3><strong>Processor (CPU)</strong></h3>

<ul>
<li><p>CPU executes a set of instructions</p>

<ul>
<li><code>Fetch</code> - <code>Decode</code> - <code>Execute</code></li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">PC = &lt;start address&gt;;
while (halt flag not set) {
    IR = memory[PC];
    PC++;
    execute(IR);
}
</code></pre></div></li>
<li><p>Anatomy of a CPU:</p>

<ul>
<li><code>Program Counter (PC)</code></li>
<li><code>Instruction Register (IR)</code></li>
<li><code>General Registers</code></li>
<li><code>Stack Pointer (SP)</code></li>
<li><code>Status Register (SR)</code> or <code>Processor Status Word</code></li>
</ul></li>
</ul>

<h3><strong>Memory</strong></h3>

<ul>
<li>Memory (DRAM) provides storage for <code>code</code> &amp; <code>data</code></li>
<li>Abstraction

<ul>
<li><code>Write(addr, val)</code></li>
<li><code>val = Read(addr)</code></li>
</ul></li>
<li>Anatomy of memory

<ul>
<li><code>Data sections</code>: global vars</li>
<li><code>Stack</code>: local vars, parameters, return values</li>
<li><code>Heap</code>: dynamic vars</li>
</ul></li>
</ul>

<h3><strong>I/O Devices</strong></h3>

<ul>
<li>Runs <strong>concurrently</strong> with <code>CPU</code></li>
<li>Connected to <strong>device-specific controllers</strong></li>
<li><code>Buses</code> connect <code>CPU</code> to <code>memory</code> &amp; <code>controllers</code>

<ul>
<li>Each <code>controller</code> owns a range of <code>bus addresses</code></li>
<li><code>CPU</code> sends messgage to address using:

<ul>
<li><code>Special I/O instructions</code></li>
<li><code>Memory-mapped I/O</code>: 

<ul>
<li>Memory locations mapped to device registers</li>
</ul></li>
</ul></li>
</ul></li>
<li>Communication model

<ul>
<li><code>Send(addr, val)</code></li>
<li><code>val = Receive(addr)</code>

<ul>
<li><code>CPU</code> polling the addr for val &amp; read the data with another address</li>
</ul></li>
<li>Similar to memory abstraction?

<ul>
<li>But data may <em>never arrive</em>, <em>get corrupted</em>, or <em>arrive out-of-order</em></li>
</ul></li>
<li><code>Polling</code> frequency?

<ul>
<li>Too high -&gt; waste CPU</li>
<li>Too low -&gt; data loss or delay</li>
</ul></li>
</ul></li>
</ul>

<h3><strong>Interrupts</strong></h3>

<ul>
<li><code>Polling</code> not efficient -&gt; let devices send <code>interrupts</code>

<ul>
<li><code>CPU</code> has <code>interrupt request flag</code> to be set by devices</li>
</ul></li>
<li>Requires support from H/W &amp; S/W</li>
<li><p>Processor execution with <code>interrupts</code>:</p>
<div class="highlight"><pre><code class="language-" data-lang="">1. (H/W) When interrupt flag set:
    H/W saves PC
    Set PC to predetermined address
    The address contains 'interrupt handler'
2. (S/W) When H/W executes next instruction:
    Save CPU registers
    Run interrupt handler
    Restore CPU registers
3. (S/W) Handler runs 'return from interrupt' instruction:
    Set PC to original next instruction
</code></pre></div><div class="highlight"><pre><code class="language-" data-lang="">PC = &lt;start address&gt;;
while (halt flag not set) {
    IR = memory[PC];
    PC++;
    execute(IR);
    if (InterruptRequest) {
        H/W save PC, SP, SR in stack; // not all states, only those necessary to be returned from handler
        PC = memory[0]; // where interrupt handler resides
    }
}
Interrupt_handler(){
    save_processor_state(); // gets to choose essential states to save
    handle_interrupt();
    restore_processor_state();
    return;
}
</code></pre></div></li>
</ul>

<h2>OS-Related Hardware</h2>

<ul>
<li>OS is S/W, when other apps are running, it is not. How does OS manage resources?

<ul>
<li>Requires H/W support to implement virtualization &amp; abstraction <strong>efficiently</strong> &amp; <strong>securely</strong>

<ul>
<li><strong>Efficient</strong> because no need to provide interpreter for every single instruction that provides H/W <code>abstraction</code> &amp; <code>virtualization</code></li>
<li><strong>Secure</strong> because <code>CPU modes</code>, <code>MMU</code>, &amp; <code>traps</code> ensure no corruption between programs</li>
</ul></li>
</ul></li>
</ul>

<h3><strong>CPU Modes</strong></h3>

<ul>
<li>2 CPU Modes:

<ul>
<li><code>Kernel mode</code> - OS

<ul>
<li>Every instruction can be executed<br>
e.g. access disk &amp; timer, controll interrupts, setting CPU mode</li>
</ul></li>
<li><code>User mode</code> - Programs

<ul>
<li>A subset of instructions can be executed<br>
e.g. <code>add</code>, <code>sub</code>, <code>push</code>, <code>pop</code>, etc.</li>
</ul></li>
</ul></li>
<li>Current mode kept in <code>status register</code></li>
<li>Devices mapped to kernel memory</li>
<li>OS is priviledged &amp; trusted program; correct system operation depend on correct OS design &amp; implementation instead of user programs</li>
<li>Enables <code>memory isolation</code>

<ul>
<li>Memories &amp; registers can only be changed in <code>privileged mode</code></li>
</ul></li>
</ul>

<h3><strong>Memory Management</strong></h3>

<ul>
<li><code>Memory Management Unit (MMU)</code>

<ol>
<li>Programs use <code>virtual memory addresses</code></li>
<li><code>CPU</code> sends <code>virtual addresses</code> to <code>MMU</code></li>
<li><code>MMU</code> translates them to <code>physical addresses</code></li>
<li><code>MMU</code> accesses <code>physical addresses</code></li>
</ol></li>
<li>Anatomy of a simple MMU

<ul>
<li><code>Base register</code>
<code>Phys addr = Virt addr + Base reg</code></li>
<li><code>Limit register</code>
<code>Virt addr &lt; Limit reg</code></li>
</ul></li>
<li>Enables <code>memory virtualization</code> &amp; <code>memory isolation</code>

<ul>
<li><code>Memory virtualization</code>: Each program has access to a large amount of contiguous, private memory, starting at address 0</li>
<li><code>Memory isolation</code>: Ensures OS &amp; other programs are located in different physical memory, and they cannot step on each other (memory access permission check)</li>
</ul></li>
</ul>

<h3><strong>Trap</strong></h3>

<ul>
<li>For programs to switch to <code>kernel mode</code> and run <code>OS code</code>

<ul>
<li>Programs cannot call <code>OS code</code> directly because <code>MMU</code> isolates <code>OS code</code> &amp; program not in <code>kernel mode</code></li>
</ul></li>
<li>Provides a secure way to enter the kernel</li>
<li><p>Similar to handling <code>interrupts</code></p>
<div class="highlight"><pre><code class="language-" data-lang=""># (H/W) On trap:
    Switch to kernel mode
    Run OS handler code at well-defined location
# (S/W) OS handler code:
    Save processor state
    Runs kernel functions to access H/W
    Restore processor state
    Return to user code, switch to user mode
</code></pre></div>
<p>=&gt; <strong>atomic</strong> to avoid <code>user code</code> running in <code>kernal mode</code></p></li>
<li><p>Unix system calls</p>

<ul>
<li>Process related<br>
e.g. fork, exec, wait, exit, kill, signal</li>
<li>File related<br>
e.g. open, read, write, close, link, unlink, chdir</li>
</ul></li>
<li><p>Invoking system call</p>
<div class="highlight"><pre><code class="language-" data-lang="">read(file, buff, n) { // library code
    ...
    lw v0, SYS_read // load syscall number into v0 reg

    syscall // trap
    ...
}
</code></pre></div></li>
<li><p><code>Traps</code>, <code>interrupts</code>, <code>exceptions</code></p>

<table><thead>
<tr>
<th></th>
<th style="text-align: left">Interrupt</th>
<th style="text-align: left">Trap</th>
<th style="text-align: left">Exception</th>
</tr>
</thead><tbody>
<tr>
<td>Cause</td>
<td style="text-align: left">H/W external to CPU</td>
<td style="text-align: left">Explicit intruction</td>
<td style="text-align: left">Instruction failure</td>
</tr>
<tr>
<td>Effect</td>
<td style="text-align: left">Program unaware of interrupt handling (async)</td>
<td style="text-align: left">Similar to program invoked function, function returns data (sync)</td>
<td style="text-align: left">Abnormal control flow</td>
</tr>
<tr>
<td>Timeliness</td>
<td style="text-align: left">Needs to respond quickly</td>
<td style="text-align: left">Program suspended, OS can take time</td>
<td style="text-align: left">OS can take time</td>
</tr>
</tbody></table></li>
</ul>

<hr>

<h2><strong>Quick Questions</strong></h2>

<ol>
<li>How does OS manage H/W?

<ul>
<li>Abstraction &amp; virtualization</li>
</ul></li>
<li>OS is software, when other applications are running, it is not running, so how can it do its work?

<ul>
<li>H/W support e.g. CPU modes, MMU, traps</li>
</ul></li>
<li>Why can’t applications corrupt other applications or the OS?

<ul>
<li>MMU helps</li>
</ul></li>
<li>Why can’t applications directly access h/w?

<ul>
<li>I/O devices are mapped to kernel memory, so no access allowed by MMU; or, I/O intructions are priviledged</li>
</ul></li>
<li>Why is the OS not a normal program?

<ul>
<li>Entered from different locations (system calls and interrupts) in response to external events</li>
<li>It does not have a single thread of control, it can be invoked simultaneously by two different events (e.g. system call &amp; interrupt)</li>
<li>It is not supposed to terminate</li>
<li>Can execute any instruction in the machine</li>
<li>Has access to the entire memory on the machine</li>
</ul></li>
<li>What if a program tries to cheat?

<ol>
<li>What happens if it issues a privileged instruction directly? 

<ul>
<li>Attempting execution of privileged instruction in user mode causes trap, so kernel gets control. Normally, kernel will kill program.</li>
</ul></li>
<li>What if a running thread doesn’t make a system call to the OS and hence hogs the CPU?

<ul>
<li>OS must register a future timer interrupt before it hands control of the CPU over to a thread; when the timer interrupt goes off, the OS gets control</li>
</ul></li>
<li>What stops the running program from disabling an interrupt?

<ul>
<li>It is a priviledges instruction</li>
</ul></li>
<li>What stops a program from modifying the OS so that the OS runs user code?

<ul>
<li>Program cannot even see OS code due to memory virtualization</li>
</ul></li>
<li>What stops a program from changing the MMU registers?

<ul>
<li>It is a priviledges instruction</li>
</ul></li>
</ol></li>
<li>How does the OS solve these problems:

<ol>
<li>Time sharing the CPU among programs?

<ul>
<li>Timer interrupts</li>
</ul></li>
<li>Space sharing memory among programs?

<ul>
<li>MMU</li>
</ul></li>
<li>Protection of programs from each other?

<ul>
<li>1. &amp; 2.</li>
</ul></li>
<li>Protection of hardware/devices?

<ul>
<li>I/O devices are mapped to kernel memory, so no access allowed by MMU; or, I/O intructions are priviledged</li>
</ul></li>
<li>Protection of the OS itself?

<ul>
<li>MMU isolates OS code</li>
</ul></li>
</ol></li>
<li>Does library code (executing in user mode) provide isolation and abstraction?

<ul>
<li>Provides abstraction but not isolation. Programs can jump to any instruction in library code, overwrite library code/data, thus bypassing any isolation that library code may try to provide.</li>
</ul></li>
<li>Does a virtual machine monitor (VMM) such as VMware provide isolation and abstraction?

<ul>
<li>A VMM is a system program, similar to an OS, that allows multiple OSs to run simultaneously on a single physical machine</li>
<li>It provides isolation, but the same abstraction as a physical machine (each OS thinks it is running on physical hardware), thus providing no additional abstraction than the physical machine.</li>
</ul></li>
<li>Why can’t user code execute some arbitrary code of its choosing in kernel mode?

<ul>
<li>User code wants to execute some code in kernel mode, so what can it do?

<ol>
<li>Write instructions into kernel image - can’t do that due to memory protection.</li>
<li>Transfer control to arbitrary places in kernel image to skip checks - can’t do this due to memory protection, and control can only be transferred via TRAP to well known kernel entry locations.</li>
<li>Execute privileged instructions - can’t do this in user mode.</li>
</ol></li>
</ul></li>
<li>What is the minimum number of privileged instructions that h/w must implement so that the OS can work correctly?

<ul>
<li>With memory mapped IO, you can hide all device accesses with memory protection. So programming the MMU (i.e., modify MMU registers) should be privileged. </li>
<li>Also, returning from a trap (e.g., iret instruction) should ensure that we cannot switch from user to kernel mode and run arbitrary kernel code. For example, on x86, a return from trap is guaranteed to execute code with the same or lower privilege level.</li>
</ul></li>
<li>Similarities &amp; differences between <code>OS</code> &amp; <code>web browsers</code>?

<ul>
<li>Similarities

<ul>
<li>Both run multiple applications (processes &amp; web applications)</li>
<li>Both need to isolate/protect different applications</li>
<li>Both need to ensure their own code is safe from application code</li>
</ul></li>
<li>Differences

<ul>
<li>OS uses H/W protection to protect OS and application code; browsers normally use S/W/language-level protection</li>
<li>OS has direct access to H/W; browsers need to use OS to access</li>
<li>OS usually runs local code; the main function of browsers is to run remote code and display remote data</li>
</ul></li>
</ul></li>
<li>Why can&#39;t OS code be shared like library codes do?

<ul>
<li>Some OS code needs to execute privileged instructions and hence will not run in user mode.</li>
<li>The OS code may manipulate data that can be globally shared across programs (e.g., the scheduler run queue). Since libraries share code but not data, the library code would not be able to access this shared data.</li>
<li>If the OS code is run in user mode, and it could be modified then the security guarantees provided by the OS could be compromised.</li>
</ul></li>
</ol>

		</div>

		<ul class="tag-list">
			

			<li class="tag">
				OS
			</li>

			

			<li class="tag">
				ECE344
			</li>

			
		</ul>

	</article>

	
		<div id="disqus_thread"></div>
<script>
	var disqus_config = function () {
	    this.page.url = "https://pyliaorachel.github.io";
	    this.page.identifier = "/blog/notes/os/2016/10/21/operating-system-basics.html";
	};
	(function() {
	    var d = document, s = d.createElement('script');
	    s.src = '//pyliaorachel.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	
</div>
	</div>
</main>
		<footer>
	<div class="container-fluid">
		<div class="row">
			<div class="col-md-4 footer-link">
				<a href="mailto:rachel5566kk@gmail.com">
					<span class="icon icon-email">
						<img src="/assets/svg/email-logo.svg" alt="Email Logo">
					</span>
					<span class="username">rachel5566kk@gmail.com</span>
				</a>
			</div>
			<div class="col-md-4 footer-link">
				<a href="https://github.com/pyliaorachel"  target="_blank">
					<span class="icon icon-github">
						<img src="/assets/svg/github-logo.svg" alt="GitHub Logo">
					</span>
					<span class="username">pyliaorachel</span>
				</a>
			</div>
			<div class="col-md-4 footer-link">
				<a href="https://tw.linkedin.com/in/peiyu-liao" target="_blank">
					<span class="icon icon-linkedin">
						<img src="/assets/svg/linkedin-logo.svg" alt="LinkedIn Logo">
					</span>
					<span class="username">Peiyu Liao</span>
				</a>
			</div>
		</div><!-- /.row -->
		<div class="row">
			<div class="footer-copy-right">
				<p>2016	&copy; Liao Peiyu</p>
			</div >
		</div><!-- /.row -->
	</div><!-- /.container-fluid -->
</footer>
		<script type="text/javascript" src="/js/main.js"></script>
		<script type="text/javascript" src="/js/home.js"></script>
		<script id="dsq-count-scr" src="//pyliaorachel.disqus.com/count.js" async></script>
	</body>
</html>