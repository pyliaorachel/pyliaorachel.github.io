<!DOCTYPE html>
<html>
	<head>
		<title>Operating System - Paging</title>
		<link rel="stylesheet" href="/css/bootstrap.min.css" type="text/css">
		<link rel="stylesheet" href="/css/main.css" type="text/css">
		<link href="https://fonts.googleapis.com/css?family=Antic+Slab|Catamaran|Hind:300|Inconsolata|Josefin+Sans|Muli:300,400i|Poiret+One|Rajdhani:300|Rock+Salt|Ruda|Scope+One|Shadows+Into+Light|Source+Code+Pro|Space+Mono" rel="stylesheet">
		<link rel="stylesheet" href="/css/github-markdown.css">

		<!-- Place jquery before bootstrap -->
		<script type="text/javascript" src="/js/jquery.min.js"></script>
		<script type="text/javascript" src="/js/bootstrap.min.js"></script>
	</head>
	<body>
		<nav class="navbar navbar-default navbar-fixed-top">
	<div class="container-fluid">

		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">MyCoon</a>
		</div>

		<div class="collapse navbar-collapse" id="navbar-collapse">

			<form class="navbar-form navbar-left">
				<div class="form-group">
					<input type="text" class="form-control" placeholder="Search">
				</div>
				<button type="submit" class="btn btn-default">Submit</button>
			</form>

			<ul class="nav navbar-nav navbar-right" id="nav-links">
				<li class="nav-home"><a href="/">Home</a></li>
				<li class="dropdown nav-blog">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Blog<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="/blog">MyCoon Blog</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="/blog/categories">Categories</a></li>
						
							
						

						
							
							
							<li class="category">
								<a href="/blog/notes">
									<span>Notes</span>
									<span>32</span>
								</a>
							</li>
						
							
							
							<li class="category">
								<a href="/blog/tech">
									<span>Tech</span>
									<span>3</span>
								</a>
							</li>
						
						<li><a href="/blog/tags">Tags</a></li>
					</ul>
				</li>
				<li class="dropdown nav-tutorial">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Tutorials<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="/tutorial">MyCoon Tutorial</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="/tutorial/categories">Categories</a></li>
						
							
						

						
						<li><a href="/tutorial/tags">Tags</a></li>
					</ul>
				</li>
				<li  class="nav-project"><a href="/project">Projects</a></li>
				<li class="nav-special" id="special"><a href="#">?</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</div><!-- /.container-fluid -->
</nav>
		<main class="page-content post" aria-label="Content">
	<div class="post-wrapper">
		<div class="wrapper">
	<article class="post-article" itemscope itemtype="http://schema.org/BlogPosting">

		<header class="post-header">
			<h1 class="post-title" itemprop="name headline">Operating System - Paging</h1>
			<p class="post-meta">Nov 22, 2016
				 • Notes
				 • pyliaorachel
			</p>
		</header>

		

		<span class="separator"> • • • </span>

		<div class="post-content" itemprop="articleBody">
			<h2>Content</h2>

<ol>
<li>Paging Overview

<ol>
<li>Introduction to Virtual Memory</li>
<li>Paging MMU</li>
<li>Page Tables</li>
</ol></li>
<li>Translation Lookaside Buffer (TLB)

<ol>
<li>TLB Basics</li>
<li>Memory Protection</li>
</ol></li>
<li>Demand Paging

<ol>
<li>Demand Paging Overview</li>
<li>Virtual Memory Hierarchy</li>
<li>Managing Virtual Address Space</li>
<li>Managing Physical Memory</li>
<li>Managing Swap Area</li>
</ol></li>
<li>Processes &amp; Virtual Memory

<ol>
<li>Interaction of Processes with VM System</li>
<li>Page Sharing &amp; Memory-Mapped Files</li>
<li>Kernal Address Space</li>
</ol></li>
<li>Page Replacement Algorithms

<ol>
<li>Page Replacement Algorithms Overview</li>
<li>Paging Issues</li>
</ol></li>
</ol>

<!--more-->

<hr>

<h2>Paging Overview</h2>

<h3>Introduction to Virtual Memory</h3>

<h4>Problems with Contiguous Memory</h4>

<ul>
<li>Growing program requires copying entire program</li>
<li>Wasted memory due to <strong>internal &amp; external fragmentation</strong></li>
<li>Running program requires loading entire program</li>
<li>Max program size limited by memory size</li>
</ul>

<h3>Paging MMU</h3>

<h4>Pages &amp; Frames</h4>

<ul>
<li><strong>Page</strong>: contiguous, fixed size chunks in virtual address space</li>
<li><strong>Frame</strong>: physical memory mapped from a page</li>
</ul>

<h4>Virtual &amp; Physical Addresses</h4>
<div class="highlight"><pre><code class="language-" data-lang=""># 32-bit machine, virtual address space 2^32 B
# page size 2^12, # of pages 2^20
|...20 bits...|.12 bits.|
    page num     offset

# e.g. physical address space 2^30 B
# frame size 2^12, # of frames 2^18
|...18 bits...|.12 bits.|
    page num     offset

               VA               PA
          -----------&gt;     -----------&gt;
Processor              MMU              Bus
          &lt;----------------------------
                       data
</code></pre></div>
<h4>Benefits of Paging</h4>

<ul>
<li>Growing program requires allocating a page at a time</li>
<li>No external fragmentation (page granularity); internal fragmentation 1/2 page per region</li>
<li>Pages can be loaded in memory as program runs</li>
<li>Max program size limited by disk size</li>
</ul>

<h3>Page Tables</h3>

<p>Mapping information maintained by MMU.</p>

<h4>Page Table Entries (PTE)</h4>
<div class="highlight"><pre><code class="language-" data-lang="">|...18 bits...|.7 bits.|C|D|R|W|V|
   frame num    unused
</code></pre></div>
<h4>Storing Page Table</h4>

<ul>
<li>Stored in memory

<ul>
<li>Each memory access requires 2 memory accesses: PTE &amp; PA</li>
<li>Solution: Cache PTE in TLB</li>
</ul></li>
<li><strong>Page table register (PTR)</strong>

<ul>
<li>For MMU to store the location of start of page table</li>
<li>OS associates a seperate page table for each process</li>
<li><strong>Address space switch</strong> switches PTR</li>
</ul></li>
</ul>

<h4>Page Table Size</h4>
<div class="highlight"><pre><code class="language-" data-lang="">#pages * PTE size (typically word size)
= (va_size / page_size) * PTE size
</code></pre></div>
<ul>
<li>Smaller page size: lower internal fragmentation</li>
<li>Larger page size: fewer PTE &amp; memory overhead</li>
</ul>

<h4>Multi-Level Page Table</h4>
<div class="highlight"><pre><code class="language-" data-lang="">|.10 bits.|.10 bits.|.12 bits.|
    PT1       PT2      offset
</code></pre></div>
<ul>
<li>Slower than <em>single-level page table</em> because more memory accesses</li>
<li>Saves space</li>
</ul>

<h4>Inverted Page Table</h4>

<p>Maps <strong>frame num -&gt; (thread id, page num)</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">|....|...52 bits...|.12 bits.|
 TID    page num     offset
  |         |
  -----------
       |
   hash func ----&gt; index into page table
</code></pre></div>
<ul>
<li>Exhaustive search is slow

<ul>
<li>Use hash table indexed by page number</li>
</ul></li>
<li>Hashing function needs to be good</li>
<li>Poor cache locality

<ul>
<li>Adjacent pages hashed to scattered locations</li>
</ul></li>
<li>Sharing memory is complicated</li>
</ul>

<h2>Translation Lookaside Buffer (TLB)</h2>

<h3>TLB Basics</h3>

<ul>
<li>H/W cache of PTE

<ul>
<li>Small # of entries</li>
<li>Exploits locality (program uses small # of pages at a time)</li>
</ul></li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang="">|virtual page number (VPN)|...18 bits...|.7 bits.|C|D|R|W|V|
                             frame num    unused
|   key: page number      |             data: PTE          |

V: valid, W: writable, R: referenced (H/W), D: dirty (H/W), C: cacheable
</code></pre></div>
<p>V: is the entry valid or not?<br>
W: is the page writable?<br>
C: is the page cacheable? when not cacheable, processor should bypass the cache when accessing the page, e.g., to access memory-mapped device registers<br>
D: has a writable page been written to (is it dirty with respect to the data on disk)?<br>
R: has a page been referenced?<br>
unused: unused by hardware, can be used by OS  </p>

<p>H/W may or may not need execution bit, but instead use <em>read</em> as <em>execute</em>  </p>

<h4>TLB Operations</h4>

<h5>TLB Lookup</h5>

<p>Fully associative TLB example  </p>

<p><img src="http://www.cems.uwe.ac.uk/%7Ebr-gaster/courses/2015-2016/CNOS/lectures/reveal.js-jade/decks/cnos_lecture9/resources/tlb-lookup.png" alt="TLB lookup"></p>

<h5>TLB cache miss handling</h5>

<ul>
<li>TLB lookup fails -&gt; page table lookup -&gt; TLB cache replaced (<strong>TLB replacement policy</strong>)</li>
<li>Handled by H/W or OS

<ul>
<li>H/W managed TLB

<ul>
<li>H/W defines page table format &amp; replacement policy</li>
<li>PTR to locate page table in physical memory</li>
<li>Fast miss handling</li>
</ul></li>
<li>S/W managed TLB

<ul>
<li>H/W generates trap called <strong>TLB miss fault</strong>

<ul>
<li><strong>Read fault</strong></li>
<li><strong>Write fault</strong></li>
</ul></li>
<li>OS handles TLB miss similar to exception handling</li>
<li>OS figures out correct PTE, add in TLB (CPU has instructions to modify TLB)</li>
<li>Page tables become entirely a OS data structure (no PTR in H/W, H/W doesn&#39;t know about page table)</li>
<li>TLB replacement policy managed in S/W</li>
<li>Slower by more flexible miss handling</li>
</ul></li>
</ul></li>
</ul>

<h5>TLB cache invalidate</h5>

<ul>
<li>Adds cost to context switching

<ul>
<li>Changing PTR + invalidating TLB + TLB misses afterwards</li>
</ul></li>
<li>Invalidate options

<ul>
<li><strong>Clear TLB</strong>: clearing valid bit of all entries</li>
<li><strong>Tagged TLB</strong>: H/W maintains <strong>id tag</strong> on each entry

<ul>
<li>Compare current thread id (stored in register) to the tag</li>
<li>No invalidation; enables space multiplexing of entries</li>
</ul></li>
</ul></li>
</ul>

<h3>Memory Protection</h3>

<ul>
<li>Generate <strong>protection fault</strong> if memory access inconsistent with protection bits

<ul>
<li><strong>Read-only fault</strong></li>
<li><strong>No-execute fault</strong></li>
</ul></li>
</ul>

<h2>Demand Paging</h2>

<h3>Demand Paging Overview</h3>

<ul>
<li>Motivation: program size/# of running programs limited by physical memory

<ul>
<li>Make memory a cache for data on disk</li>
</ul></li>
<li>Basic Mechanism

<ul>
<li>PTE unset for invalid page</li>
<li><strong>Cache miss</strong> when program accesses invalid page</li>
<li>Generates <strong>page fault</strong></li>
<li>OS <strong>page fault handler</strong> performs miss handling: allocate frame, update PTE, set valid bit, restart instruction</li>
</ul></li>
<li>Benefits

<ul>
<li>Allows programs run to exceed available memory (limited by VA space (processor architecture) or disk)</li>
<li>Faster startup programs (no need to load entire program)</li>
</ul></li>
</ul>

<h3>Virtual Memory Hierarchy</h3>

<p><img src="http://images.slideplayer.com/27/9050102/slides/slide_8.jpg" alt="VM hierarchy"></p>

<h4>Swap Handler</h4>

<ol>
<li>Chooses a page to evict using page replacement algorithm</li>
<li>If page modified, write to a free location on <strong>swap</strong></li>
<li>Find pages that map to the evicted frame

<ul>
<li>Need frame-to-page mapping (coremap)</li>
<li>Change all PTEs to invalid</li>
<li>Keep track of the evicted frame location in swap</li>
</ul></li>
<li>Return newly freed frame to page fault handler</li>
</ol>

<h4>Other Notes</h4>

<ol>
<li>If <em>TLB miss handling</em> is performed by H/W, no <em>TLB miss fault</em> generated; if by S/W, H/W doesn&#39;t access PT</li>
<li><strong>Page fault handler</strong>: 

<ul>
<li>checks <strong>segmentation fault</strong>, <strong>protection fault</strong></li>
<li>allocates frame, PTE</li>
<li>loads data from disk into frame</li>
<li>maps page to frame by updating PTE</li>
</ul></li>
<li>Page contents may:

<ul>
<li>be all 0</li>
<li>in <strong>swap</strong></li>
<li>in <strong>executable</strong></li>
</ul></li>
<li>OS accesses PT when:

<ul>
<li>on TLB-miss fault (for h/w managed TLB), it reads the page table</li>
<li>on page fault, it allocates frame and updates page table</li>
<li>whenever address space of current process is modified, (frame is allocated/deallocated, context switch), it updates page table</li>
</ul></li>
</ol>

<h3>Managing Virtual Address Space</h3>

<h4>Address Space</h4>

<ul>
<li>Broken into <strong>regions</strong> or <strong>segments</strong></li>
<li>OS must track the regions within an address space &amp; PT holding translations</li>
<li>API

<ul>
<li><code>id = as_create()</code> create empty address space, allocate new PT with no pages mapped to frames</li>
<li><code>as_destroy(id)</code> destroy as, free PT</li>
<li><code>as_define_region(id,...)</code> add new region</li>
<li><code>as_modify_region(id,...)</code> change size (e.g. heap, stack)</li>
<li><code>as_find_region(id,va)</code> find valid region or give seg fault</li>
<li><code>as_load_page(id,...)</code> load page from file into memory</li>
<li><code>new_id = as_copy(id)</code> create copy of as &amp; PT (actually copy data to other frames)</li>
<li><code>as_switch(id)</code> mappings in TLB must be removed</li>
</ul></li>
</ul>

<h3>Managing Physical Memory</h3>

<h4>Coremap</h4>

<ul>
<li>Array of structures, one per frame</li>
<li>Tracks:

<ul>
<li>whether frame allocated</li>
<li>address spaces &amp; pages map to this frame (list of (pid, page_id))</li>
<li>kernel or user</li>
</ul></li>
<li>API

<ul>
<li><code>frame = allocate_frame(n)</code> alloc n free contiguous frames (user needs 1 frame; kernel needs more)</li>
<li><code>free_frame(frame)</code></li>
<li><code>map(id,page_nr,frame)</code></li>
<li><code>unamp(id,page_nr)</code></li>
<li><code>evict(frame)</code> for swap handler to unmap pages associated with frame</li>
</ul></li>
</ul>

<h3>Managing Swap Area</h3>

<ul>
<li>Dirty pages need to be placed in swap</li>
<li>Bitmap or linked list of <strong>swap frames</strong> on disk; keep location in invalid PTE</li>
<li><p>If loading shared frame from swap and needs to write to it:</p>

<ul>
<li>allocate a frame and keep the swap frame</li>
<li>next time allocate another frame and free the swap frame</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang=""># PTE
|frame number|unused|R|D|C|W|1| virtual page in memory
|000.......................0|0| invalid PTE
|index in swap area.........|0| virtual page in swap
</code></pre></div></li>
</ul>

<h2>Processes &amp; Virtual Memory</h2>

<h3>Interaction of Processes with VM System</h3>

<ul>
<li>OS implements VM system using 3 abstractions: address space, physical memory, &amp; swap management</li>
<li>Rest of OS invokes the VM systems when <strong>address space of current process changes</strong>

<ul>
<li>Process creation <code>fork</code>

<ul>
<li>Create new PT &amp; copy content from parent&#39;s regions</li>
</ul></li>
<li>Process execution <code>execv</code>

<ul>
<li>Destroy old address space structure &amp; create new one</li>
</ul></li>
<li>Process termination <code>exit</code></li>
<li>Context switch

<ul>
<li>H/W managed TLB: change PTR, flush TLB</li>
<li>S/W managed TLB: flush TLB</li>
</ul></li>
<li>Memory allocation/deallocation <code>sbrk, stack</code>

<ul>
<li>Heap: system call (<code>sbrk</code>) to grow; allows OS to <strong>detect errors</strong></li>
<li>Stack: when faulting address <em>close</em> to stack, extend stack region running standard page fault handler</li>
</ul></li>
</ul></li>
</ul>

<h3>Page Sharing &amp; Memory-Mapped Files</h3>

<ul>
<li>Benefits

<ul>
<li>Fast communication between processes</li>
<li>Good isolation (only share when needed)</li>
</ul></li>
<li>Applications

<ul>
<li><strong>Sharing text regions</strong>

<ul>
<li>e.g. dynamically loaded libraries</li>
<li>Must update all pages when frame evicted</li>
</ul></li>
<li><strong>Copy-on-write pages</strong>

<ul>
<li>Child shares pages with parent until pages modified</li>
<li>PTE marks <strong>COW &amp; read-only</strong></li>
<li>On protection fault: allocate new frame, copy, remap, make writable, update TLB, resume</li>
<li>Must update all pages when frame evicted</li>
</ul></li>
<li><strong>Memory-mapped files</strong>

<ul>
<li>Threads r/w files using load/store instead of system calls</li>
<li><code>mmap(addr,length,prot_flags,fd,offset)</code> maps a file at given offset contiguously within address space

<ul>
<li>Storing <code>offset</code> to provide flexibility since different processes may have different addresses of shared memory</li>
</ul></li>
<li>File data loaded on page fault</li>
<li>Instead of swap area, use file itself as backing store</li>
<li>More efficient than r/w system calls because system calls need buffer in kernel to transfer data</li>
</ul></li>
</ul></li>
<li>Shared memory

<ul>
<li>Threads r/w to mapped memory region</li>
<li>PTE can have different protections for different threads</li>
<li>Memory can be mapped at same or different VA in each process</li>
</ul></li>
</ul>

<h3>Kernal Address Space</h3>

<ul>
<li>OS typically lies in <em>low physical memory</em></li>
<li>Options

<ul>
<li><strong>Paging turned off</strong> in kernel mode, OS access physical memory directly

<ul>
<li>OS needs to simulate paging, i.e. do address translation in software, to copy in or out user parameters on a system call, deal with dirty bit, etc.</li>
</ul></li>
<li>OS uses <strong>separate address space</strong>

<ul>
<li>Pros

<ul>
<li>Clean isolation</li>
</ul></li>
<li>Cons

<ul>
<li>System call requires switching MMU -&gt; TLB flush</li>
<li>Copy in/out of system call parameters requires traversing PT in S/W</li>
</ul></li>
</ul></li>
<li>OS maps to <strong>address space of each thread</strong>

<ul>
<li>Typically mapped to high addresses</li>
<li>Pros

<ul>
<li>No system call</li>
<li>Copy in/out of system call parameters can reuse paging H/W<br></li>
</ul></li>
<li>Cons

<ul>
<li>Address space of processes reduces</li>
<li>PT needs to be setup to access OS code

<ul>
<li>H/W may allow OS to bypass PT</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<h2>Page Replacement Algorithms</h2>

<h3>Page Replacement Algorithms Overview</h3>

<ul>
<li>When will paging work?

<ul>
<li>If occurs rarely</li>
<li><strong>Spatial locality</strong> &amp; <strong>temporal locality</strong></li>
</ul></li>
<li><p>Algorithms</p>

<ul>
<li><strong>Optimal algorithm</strong>: page that will not be needed for longest time

<ul>
<li>Need to know the future</li>
<li>Can be used to compare performance

<ul>
<li>Generate a log of VM accesses (<strong>reference string</strong>); use log to simulate various replacement policies</li>
</ul></li>
</ul></li>
<li><strong>FIFO</strong>: oldest page

<ul>
<li>Oldest page may be needed soon</li>
<li>Faults may increase if given more memory (<a href="http://stackoverflow.com/questions/4800285/cant-understand-beladys-anomaly">Belady&#39;s Anomaly</a>)</li>
</ul></li>
<li><p><strong>Clock</strong>: FIFO giving second chance to referenced pages</p>

<ul>
<li><strong>Referenced bit</strong>: set by processor when page read/written; cleared by OS/software</li>
<li><strong>Dirty bit</strong>: set by processor when page written; cleared by OS/software</li>
<li>OS synchronizes R/D bits in TLB with PTE (H/W: write-through or write-back; S/W: needs to implement synchronization)</li>
<li><p>OS simulates the bits if H/W doesn&#39;t maintain</p>

<ul>
<li>When TLB read fault: 

<ul>
<li>Set referenced bit; make page read-only</li>
</ul></li>
<li>When TLB read-only protection fault/write fault: 

<ul>
<li>Set referenced &amp; dirty bits; make page writeable</li>
</ul></li>
<li><p>Algorithm</p>
<div class="highlight"><pre><code class="language-" data-lang="">Choose page starting from clock hand:
    if referenced bit set:
        unset, goto next
    else:
        if page dirty:
            schedule page write, goto next
        else:
            select for replacement
</code></pre></div></li>
</ul></li>
</ul></li>
<li><p><strong>LRU</strong>: page used least recently</p>

<ul>
<li>Updating LRU on each memory access is expensive</li>
<li>If MMU maintains a counter incremented at each clock cycle:

<ul>
<li>When page accessed: 

<ul>
<li>Writes counter value to PTE</li>
</ul></li>
<li>On page fault: 

<ul>
<li>S/W looks through PT, identifies entry with oldest timestamp</li>
</ul></li>
</ul></li>
<li>If MMU doesn&#39;t provide such counter, OS maintains it in S/W (<strong>LRU aprroximation</strong>):

<ul>
<li>Periodically (timer interrupt) increment counter; granularity depends on timer interrupt

<ul>
<li>If referenced bit set:

<ul>
<li></li>
<li></li>
</ul></li>
</ul></li>
<li>On page fault:

<ul>
<li>S/W looks through PT &amp; identify the oldest timestamp</li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>Working set clock</strong>: keep working set in memory</p>

<ul>
<li><strong>Working set</strong>: set of pages a program needs currently

<ul>
<li><strong>Working set interval <code>T</code></strong>: <code>WS(T) = {pages accessed in interval (now, now-T)}</code></li>
<li><strong>Max WS</strong>: how much memory a program needs</li>
</ul></li>
<li><p>Algorithm</p>
<div class="highlight"><pre><code class="language-" data-lang="">Choose page starting from clock hand:
    if referenced bit set:
        update time-of-last-use to current virtual time
        unset, goto next
    else:
        if (current time - time-of-last-use) &lt; T:
            continue
        else:
            if page dirty:
                schedule page write, goto next
            else:
                select for replacement
</code></pre></div></li>
</ul></li>
<li><p><strong>Page fault frequency</strong>: estimate of working set needs of a program</p>

<ul>
<li><p>Measurements</p>
<div class="highlight"><pre><code class="language-" data-lang="">For each thread:
    On fault:
        f = f + 1
    Every second, update faults/sec (fe) via aging:
        fe = (1-a) * fe + a * f, f = 0
        # 0 &lt; a &lt; 1, weighting factor; a -&gt; 1 means history ignored
</code></pre></div></li>
<li><p>Allocate frames s.t. <strong>PFF is equal for programs</strong></p>

<ul>
<li><strong>Global replacement</strong>: victim process has lowest PFF</li>
<li><strong>Local replacement</strong>: use algorithms above (clock, LRU, etc.) to evict a page within the victim process</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Comparison</p>

<table><thead>
<tr>
<th style="text-align: left">Algorithm</th>
<th style="text-align: left">Comment</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">Optimal</td>
<td style="text-align: left">Not implementable; useful as benchmark</td>
</tr>
<tr>
<td style="text-align: left">FIFO</td>
<td style="text-align: left">Might throw out important pages</td>
</tr>
<tr>
<td style="text-align: left">Clock</td>
<td style="text-align: left">Realistic</td>
</tr>
<tr>
<td style="text-align: left">LRU</td>
<td style="text-align: left">Excellent; difficult to implement efficiently</td>
</tr>
<tr>
<td style="text-align: left">WSC</td>
<td style="text-align: left">Efficient working set algorithm</td>
</tr>
<tr>
<td style="text-align: left">PFF</td>
<td style="text-align: left">Fairness in working set allocation</td>
</tr>
</tbody></table></li>
</ul>

<h3>Paging Issues</h3>

<h4>Paging &amp; I/O Interaction</h4>

<ul>
<li>Problem: a frame waiting for I/O may be selected for eviction</li>
<li>Solution: each frame has <strong>do not evict</strong> flag called <strong>pinned page</strong>; un-pin after I/O completes</li>
</ul>

<h4>Paging Performance</h4>

<ul>
<li>Paging works best if many free frames</li>
<li>If pages full of dirty pages, 2 disk operations (swap in/out) needed on each page fault</li>
<li><strong>Paging daemon</strong>: swap out in advance

<ul>
<li>OS maintains a pool of free frames using <strong>paging thread/daemon</strong></li>
<li>Daemon runs replacement algorithm periodically or when pool reaches <strong>low watermark</strong>:

<ul>
<li>Writes out dirty pages</li>
<li>Frees enough pages until pool reaches <strong>high watermark</strong></li>
</ul></li>
<li>Frames can be <strong>rescued</strong> if page referenced before reallocation, because previous content still holds</li>
</ul></li>
<li><strong>Prefetching</strong>: swap in in advance

<ul>
<li>Predict future page usage at current faults</li>
<li>Works well when pages read sequentially</li>
</ul></li>
</ul>

<h4>Thrashing</h4>

<ul>
<li><strong>Livelock</strong>: OS spends time paging data from disk, programs not making progress</li>
<li>Causes

<ol>
<li>Pages replacement algorithm not working</li>
<li>Not enough memory to hold working set of all running programs</li>
</ol></li>
<li>Solutions

<ol>
<li><strong>Swapping</strong>: suspend some programs for a while</li>
<li>Buy more memory</li>
</ol></li>
</ul>

<h4>Resources</h4>

<ul>
<li><a href="https://www.quora.com/What-is-the-differences-between-a-page-table-and-an-inverted-page-table">What are the differences between a page table and an inverted page table?</a></li>
<li><a href="http://f.osdev.org/viewtopic.php?f=1&amp;t=15321">Can I turn off paging in kernel mode?</a></li>
</ul>

		</div>

		<ul class="tag-list">
			

			<li class="tag">
				OS
			</li>

			

			<li class="tag">
				ECE344
			</li>

			

			<li class="tag">
				paging
			</li>

			
		</ul>

	</article>

	
		<div id="disqus_thread"></div>
<script>
	var disqus_config = function () {
	    this.page.url = "https://pyliaorachel.github.io";
	    this.page.identifier = "/blog/notes/os/2016/11/22/operating-system-paging.html";
	};
	(function() {
	    var d = document, s = d.createElement('script');
	    s.src = '//pyliaorachel.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	
</div>
	</div>
</main>
		<footer>
	<div class="container-fluid">
		<div class="row">
			<div class="col-md-4 footer-link">
				<a href="mailto:rachel5566kk@gmail.com">
					<span class="icon icon-email">
						<img src="/assets/svg/email-logo.svg" alt="Email Logo">
					</span>
					<span class="username">rachel5566kk@gmail.com</span>
				</a>
			</div>
			<div class="col-md-4 footer-link">
				<a href="https://github.com/pyliaorachel"  target="_blank">
					<span class="icon icon-github">
						<img src="/assets/svg/github-logo.svg" alt="GitHub Logo">
					</span>
					<span class="username">pyliaorachel</span>
				</a>
			</div>
			<div class="col-md-4 footer-link">
				<a href="https://tw.linkedin.com/in/peiyu-liao" target="_blank">
					<span class="icon icon-linkedin">
						<img src="/assets/svg/linkedin-logo.svg" alt="LinkedIn Logo">
					</span>
					<span class="username">Peiyu Liao</span>
				</a>
			</div>
		</div><!-- /.row -->
		<div class="row">
			<div class="footer-copy-right">
				<p>2016	&copy; Liao Peiyu</p>
			</div >
		</div><!-- /.row -->
	</div><!-- /.container-fluid -->
</footer>
		<script type="text/javascript" src="/js/main.js"></script>
		<script type="text/javascript" src="/js/home.js"></script>
		<script id="dsq-count-scr" src="//pyliaorachel.disqus.com/count.js" async></script>
	</body>
</html>