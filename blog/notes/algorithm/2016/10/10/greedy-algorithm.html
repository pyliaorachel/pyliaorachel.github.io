<!DOCTYPE html>
<html>
	<head>
		<title>Greedy Algorithm</title>
		<link rel="stylesheet" href="/css/bootstrap.min.css" type="text/css">
		<link rel="stylesheet" href="/css/main.css" type="text/css">
		<link href="https://fonts.googleapis.com/css?family=Antic+Slab|Catamaran|Hind:300|Inconsolata|Josefin+Sans|Muli:300,400i|Poiret+One|Rajdhani:300|Rock+Salt|Ruda|Scope+One|Shadows+Into+Light|Source+Code+Pro|Space+Mono" rel="stylesheet">
		<link rel="stylesheet" href="/css/github-markdown.css">

		<!-- Place jquery before bootstrap -->
		<script type="text/javascript" src="/js/jquery.min.js"></script>
		<script type="text/javascript" src="/js/bootstrap.min.js"></script>
	</head>
	<body>
		<nav class="navbar navbar-default navbar-fixed-top">
	<div class="container-fluid">

		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">MyCoon</a>
		</div>

		<div class="collapse navbar-collapse" id="navbar-collapse">

			<form class="navbar-form navbar-left">
				<div class="form-group">
					<input type="text" class="form-control" placeholder="Search">
				</div>
				<button type="submit" class="btn btn-default">Submit</button>
			</form>

			<ul class="nav navbar-nav navbar-right" id="nav-links">
				<li class="nav-home"><a href="/">Home</a></li>
				<li class="dropdown nav-blog">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Blog<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="/blog">MyCoon Blog</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="/blog/categories">Categories</a></li>
						
							
						

						
							
							
							<li class="category">
								<a href="/blog/notes">
									<span>Notes</span>
									<span>21</span>
								</a>
							</li>
						
							
							
							<li class="category">
								<a href="/blog/tech">
									<span>Tech</span>
									<span>1</span>
								</a>
							</li>
						
						<li><a href="/blog/tags">Tags</a></li>
					</ul>
				</li>
				<li class="dropdown nav-tutorial">
					<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
						Tutorials<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="/tutorial">MyCoon Tutorial</a></li>
						<li role="separator" class="divider"></li>
						<li><a href="/tutorial/categories">Categories</a></li>
						
							
						

						
						<li><a href="/tutorial/tags">Tags</a></li>
					</ul>
				</li>
				<li  class="nav-project"><a href="/project">Projects</a></li>
				<li class="nav-special" id="special"><a href="#">?</a></li>
			</ul>
		</div><!-- /.navbar-collapse -->
	</div><!-- /.container-fluid -->
</nav>
		<main class="page-content post" aria-label="Content">
	<div class="post-wrapper">
		<div class="wrapper">
	<article class="post-article" itemscope itemtype="http://schema.org/BlogPosting">

		<header class="post-header">
			<h1 class="post-title" itemprop="name headline">Greedy Algorithm</h1>
			<p class="post-meta">Oct 10, 2016
				 • Notes
				 • pyliaorachel
			</p>
		</header>

		

		<span class="separator"> • • • </span>

		<div class="post-content" itemprop="articleBody">
			<h2>Content</h2>

<ol>
<li>Minimum Spanning Tree</li>
<li>Huffman Encoding</li>
<li>Interval Scheduling</li>
</ol>

<!--more-->

<hr>

<h1>Greedy Algorithms</h1>

<h3>What is greedy?</h3>

<p>Take the best move at the moment without worrying about future outcomes.</p>

<h2>Minimum Spanning Tree</h2>

<ul>
<li>A graph, connecting all nodes with edges that cost the least in total.</li>
<li>No cycle</li>
</ul>

<h4>Definition</h4>

<ul>
<li><em>Input</em>: An undirected graph G = (V, E); edge weights we<br></li>
<li><em>Output</em>: A tree T = (V,E&#39;), with E&#39; ⊆ E, that minimizes weight(T) = Σ(e ⊆ E&#39;)we</li>
</ul>

<h4>Trees</h4>

<p>Undirected graph, connected &amp; acyclic  </p>

<ul>
<li>Removing a cycle edge cannot disconnect a graph</li>
<li>A tree with <code>n</code> nodes has <code>n-1</code> edges</li>
<li>Any connected, undirected graph with <code>|E| = |V| - 1</code> is a tree.</li>
<li>An undirected graph is a tree &lt;- there&#39;s a unique path between any pair of nodes</li>
</ul>

<h3><em>Kruskal&#39;s MST Algorithm</em></h3>

<ol>
<li>Start with empty graph</li>
<li>Add the next lightest edge that doesn&#39;t produce a cycle</li>
<li>Do until all nodes connected</li>
</ol>

<h4>The Cut Property</h4>

<ul>
<li>Cut: any partition of vertices into 2 groups <code>S</code> &amp; <code>V-S</code></li>
<li>Let <code>X</code> be subset of MST not crossing between <code>S</code> &amp; <code>V-S</code></li>
<li>Pick <code>e</code> to be the lightest edge connecting <code>S</code> &amp; <code>V-S</code></li>
<li><code>X ∪ {e}</code> is MST</li>
</ul>

<h4>Implementation</h4>
<div class="highlight"><pre><code class="language-" data-lang="">Kruskal(G, w):
# Input: A connected undirected graph G = (V, E) with edge weights we 
# Output: A minimum spanning tree defined by the edges X

    for all u ∈ V : # =&gt; O(|V|)
        makeset(u) # create a singleton set containing just u

    X = {}
    Sort the edges E by weight # =&gt; O(|E|log|V|) where log|E| ~ log|V|
    for all edges {u, v} ∈ E, in increasing order of weight: # = O(|E|log|V|)
        # find sets to which u &amp; v belong
        if find(u) != find(v):
            add edge {u, v} to X 
            union(u, v) # merging sets
</code></pre></div>
<h4>Running Time</h4>

<p><code>O(|E|log|V|)</code></p>

<h4>Data Structure for Disjoin Sets</h4>

<ul>
<li>Directed tree</li>
<li>Root element as identifier</li>
</ul>
<div class="highlight"><pre><code class="language-" data-lang=""># π = parent pointer
# rank = height of subtree hanging from that node

makeset(x): # = O(1)
    π(x) = x
    rank(x) = 0

find (x): # = O(logn)
    while x != π(x): 
        x = π(x) 
    return x

union(x, y)  # = O(logn)
    rx = find(x)
    ry = find(y)
    if rx = ry: 
        return 
    if rank(rx)  rank(ry):
        π(ry) = rx  # make root of y-tree point to root of x-tree
    else:
        π(rx) = ry
        if rank(rx)=rank(ry): 
            rank(ry)=rank(ry)+1
</code></pre></div>
<ul>
<li>Any root node of rank <code>k</code> has at least <code>2^k</code> nodes in its tree</li>
<li>So if <code>n</code> elements overall, at most <code>n/(2^k)</code> of rank <code>k</code></li>
<li>=&gt; max rank = <code>log(n)</code> (upper bound of <code>find</code> &amp; <code>union</code>)</li>
</ul>

<h4>Optimization - Path Compression</h4>
<div class="highlight"><pre><code class="language-" data-lang="">find(x):
    if x != π(x): 
        π(x) = find(π(x)) 
    return π(x)
</code></pre></div>
<h3><em>Prim&#39;s Algorithm</em></h3>

<ol>
<li>Start with empty graph</li>
<li>Add any vertex to <code>S</code></li>
<li>Add a min-weight edge from <code>S</code> to <code>V-S</code></li>
<li>Repeat until done</li>
</ol>

<h4>Pseudocode</h4>
<div class="highlight"><pre><code class="language-" data-lang="">X = { } (edges picked so far) 
repeat until |X| = |V| − 1:
    pick a set S ⊂ V for which X has no edges between S and V−S
    let e ∈ E be the minimum-weight edge between S and V − S
    # cost(v) = min(u ∈ S)(w(u, v))
    X = X ∪ {e}
</code></pre></div>
<h4>Implementation</h4>
<div class="highlight"><pre><code class="language-" data-lang="">Prim(G, w):
# Input: A connected undirected graph G = (V, E) with edge weights we 
# Output: A minimum spanning tree defined by the array prev
    for all u ∈ V: 
        cost(u) = ∞
        prev(u) = nil
    Pick any initial node u0 
    cost(u0) = 0

    H = makequeue (V) # priority queue, using cost-values as keys 
    while H is not empty:
        v = deletemin(H) 
        for each {v, z} ∈ E:
            if cost(z) &gt; w(v, z): 
                cost(z) = w(v, z) 
                prev(z) = v 
                decreasekey(H, z)
</code></pre></div>
<h4>Running Time</h4>

<p><code>O(|E|log|V|)</code></p>

<h4>Difference with Dijkstra&#39;s Algorithm</h4>

<ul>
<li>Key by with priority queue is ordered

<ul>
<li><strong>Prim&#39;s</strong>: lightest incoming edge from set S</li>
<li><strong>Dijkstra&#39;s</strong>: length of path from start to that node</li>
</ul></li>
</ul>

<h2>Huffman Encoding</h2>

<p>Encode a string of length T over alphabet Γ</p>

<h4>Prefix-free Encoding</h4>

<ul>
<li>No codeword can be a prefix of another</li>
<li>Can be represented by a <em>full</em> binary tree</li>
<li>Leaves: symbols</li>
<li>Path from root to leaf: codeword, left = 0, right = 1</li>
</ul>

<h4>Optimal Coding Tree</h4>

<ul>
<li>A tree whose leaves each correspond to a symbol<br></li>
<li>Min overall length of encoding<br>
<code>cost of tree = Σ(i=1, n) fi * di</code><br></li>
<li>Or, combine freq of 2 decendants into freq of parent:<br>
<code>cost of tree = Σ(leaves) fi + Σ(internal nodes) fi</code> </li>
</ul>

<h4>Construction</h4>

<ul>
<li>Implication: nodes with smallest freq @ bottom of tree<br></li>
<li>Greedy construction:

<ol>
<li>Find 2 smallest freq nodes</li>
<li>Combine into new node, <code>f = f1 + f2</code></li>
<li>Replace 2 nodes with new node</li>
<li>Repeat</li>
</ol></li>
</ul>

<h4>Implementation</h4>
<div class="highlight"><pre><code class="language-" data-lang="">Huffman(f):
# Input: An array f [1 · · · n] of frequencies 
# Output: An encoding tree with n leaves

    let H be a priority queue of integers, ordered by f 
    for i = 1 to n: 
        insert(H,i)
    for k = n + 1 to 2n − 1:
        i = deletemin(H), j = deletemin(H)
        create a node numbered k with children i, j 
        f[k] = f[i] + f[j]
        insert(H, k)
</code></pre></div>
<p>=&gt; Binary heap: <code>O(nlogn)</code></p>

<h2>Interval Scheduling</h2>

<h3><em>Max Compatible Interval Scheduling</em></h3>

<p>A set of requests {1, 2, ..., n}; the ith request starts at s(i) and ends at f(i). Schedule the most intervals.</p>

<h4>Attempts</h4>

<ol>
<li><p>Earliest starting time</p>

<ul>
<li>Earliest request takes long?</li>
</ul></li>
<li><p>Smallest interval</p>
<div class="highlight"><pre><code class="language-" data-lang="">|-------------|    |--------------|
            |----------|
</code></pre></div></li>
<li><p>Fewest conflicts</p>
<div class="highlight"><pre><code class="language-" data-lang="">|------|  |-------|  |-------|  |-------|
    |-------|   |-------|  |-------|
    |-------|              |-------|
    |-------|              |-------|
</code></pre></div></li>
</ol>

<h4>Solution</h4>

<p>Base on earliest finish time.</p>
<div class="highlight"><pre><code class="language-" data-lang="">
# Initially let R be the set of all requests, and let A be empty 

While R is not yet empty
    Choose a request i ∈ R that has the smallest finishing time
    Add request i to A
    Delete all requests from R that are not compatible with request i
EndWhile
Return the set A as the set of accepted requests

</code></pre></div>
<h4>Proof</h4>

<ol>
<li><p>Let <code>O</code> be an optimal set of compatible intervals. Prove that <code>A</code> contains the same # of intervals as <code>O</code>.</p>
<div class="highlight"><pre><code class="language-" data-lang="">Let A = {i1, ..., ik}, O = {j1, ..., jm}. Prove k = m.

From our algo: f(i1) &lt;= f(j1) # we 'stay ahead'
Now prove for each r = 1, f(ir) &lt;= f(jr)
</code></pre></div></li>
<li><p>For all indices r &lt;= k, we have <code>f(ir) &lt;= f(jr)</code></p>
<div class="highlight"><pre><code class="language-" data-lang="">Prove by induction.

For r = 1, true.
Let r  1. Assume f(i_r-1) &lt;= f(j_r-1).
We know f(j_r-1) &lt;= s(jr), since O has compatible intervals.
= f(i_r-1) &lt;= f(j_r-1) &lt;= s(jr)
Thus jr is in set R of available intervals when our algorithm selects ir, hence f(ir) &lt;= f(jr) so that we didn't choose it.
</code></pre></div>
<p>=&gt; for each r, the rth interval we select finishes at least as soon as the rth interval in O.</p></li>
<li><p><code>A</code> is optimal.</p>
<div class="highlight"><pre><code class="language-" data-lang="">Prove by contradiction.

Assume A not optimal, then m  k. # O schedules more than A
By 2., there is request j_k+1 in O.
This request starts after request jk ends &amp; hence after ik ends.
So R still contains j_k+1, which is valid to be put into A.
- Contradiction -
</code></pre></div></li>
</ol>

<h4>Running Time</h4>

<p><code>O(nlogn)</code></p>

<h4>Extension</h4>

<p>Consider cost of rejecting an interval = <strong>Weighted Interval Scheduling Problem</strong></p>

<h3>Schduling All Intervals</h3>

<p>Partition all intervals across multiple resources = <strong>Interval Partitioning/ Coloring Problem</strong></p>

<h4>Lowerbound</h4>

<p>In any instance of interval partitioning, <code># of resources needed = depth of set of intervals</code>.</p>

<h4>Pseudocode</h4>
<div class="highlight"><pre><code class="language-" data-lang=""># Sort the intervals by their start times, breaking ties arbitrarily 

Let I1, I2, . . . , In denote the intervals in this order
For j=1,2,3,...,n
    For each interval Ii that precedes Ij in sorted order and overlaps it 
        Exclude the label of Ii from consideration for Ij
    Endfor
    If there is any label from {1, 2, . . . , d} that has not been excluded then
        Assign a nonexcluded label to Ij 
    Else
        Leave Ij unlabeled 
    Endif
Endfor
</code></pre></div>
<h4>Proof</h4>

<ol>
<li><p>Every interval will be assigned a label. No 2 overlapping intervals receive the same label</p>
<div class="highlight"><pre><code class="language-" data-lang="">1. No interval unlabeled.

Consider Ij, suppose t intervals precedes it and overlap it.
These t intervals + Ij = t+1 intervals all passes over s(Ij), so 
    t+1 &lt;= d
    t &lt;= d-1
Hence there will be a label to assign to Ij.

2. No 2 overlapping intervals assigned the same label.

I precedes I', and when I' is considered, we will not assign the label of I to I' from our algorithm.
</code></pre></div></li>
<li><p>You will hence never reach a point where all labels are currently in use, which matches the lower bound and is optimal.</p></li>
</ol>

<h3><em>Minumum Maximum Lateness</em></h3>

<p>A set of n requests, resource available from time s, requiring t to finish, and deadline d. Schedule all requests while minimizing lateness.</p>

<h4>Attempts</h4>

<ol>
<li><p>In order of increasing length ti</p>

<ul>
<li>t1 = 2, d1 = 100; t2 = 10, d2 = 10?</li>
</ul></li>
<li><p>In order of increasing <em>slack</em> time <code>di - ti</code></p>

<ul>
<li>t1 = 1, d1 = 2; t2 = 10, d2 = 10?</li>
</ul></li>
</ol>

<h4>Solution</h4>

<p>Base on earlier deadlines.</p>
<div class="highlight"><pre><code class="language-" data-lang=""># Order the jobs in order of their deadlines
# Assume for simplicity of notation that d1 ≤ ... ≤ dn 

Initially, f = s
Consider the jobs i = 1, ..., n in this order
    Assign job i to the time interval from s(i) = f to f(i) = f + ti 
    Let f = f + ti
End
Return the set of scheduled intervals [s(i), f (i)] for i = 1, . . . , n
</code></pre></div>
<h4>Proof</h4>

<ol>
<li>Schedule has no <strong>gaps</strong>, i.e. no idle time.</li>
<li><p>There is an optimal schedule with no idle time.</p>
<div class="highlight"><pre><code class="language-" data-lang="">Prove by exchange argument.

Suppose schedule A' has an inversion if job i with di scheduled before job j with dj, but dj &lt; di. Our algorithm has no inversions.
</code></pre></div></li>
<li><p>All schedules with no inversions &amp; no idle time have the same max lateness.</p>
<div class="highlight"><pre><code class="language-" data-lang="">2 schedules with these properties can only differ in the order in which jobs with the same deadlines are scheduled.

Let such deadline be d. There are some jobs with deadline d and scheduled consecutively. Among them, the latest scheduled one has the greatest lateness. This lateness does not depend on the order of the jobs!
</code></pre></div></li>
<li><p>There is an optimal schedule with no inversions and no idle time.</p>
<div class="highlight"><pre><code class="language-" data-lang="">a. If O has an inversion, there is a pair of jobs i &amp; j s.t. j is schedules immediately after i, but dj &lt; di.
b. Swapping i, j, we get a schedule with one less inversion.
c. The new max lateness &lt;= original lateness.

    Assume each request r is scheduled [sr, fr] with lateness lr. Let L = max_r(lr).

    Let O' be the swapped schedule.

    = fi = sj, f'j = s'i

    All other jobs remain finishing at the same time after the swap, since t(i)+t(j) is the same.

    Job j will not have lateness increased, since it is put forward.

    For job i:
        If i not delayed, we're done.
        If i delayed:
            l'i = f'i - di = fj - di. Since di  dj:
                l'i = fj - di &lt; fj - dj = lj

    Since L = lj  l'i, the swap doesn't increase max lateness.
</code></pre></div></li>
<li><p>An optimal schedule with no inversions exists. And all such schedules have the same max lateness. Hence algorithm optimal.</p></li>
</ol>

<h4>Extension</h4>

<ul>
<li>Includes release time?</li>
</ul>

<h2>References</h2>

<ul>
<li>Dasguptap, S., Papadimitriou, C.H., &amp; Vazirani, U.V. Algorithms. Chapter 5.1-5.2.</li>
<li>Kleinberg, J., Tardos, E. Algorithm Design. Chapter 4.1-4.2.</li>
</ul>

		</div>

		<ul class="tag-list">
			

			<li class="tag">
				minimum spanning tree
			</li>

			

			<li class="tag">
				huffman encoding
			</li>

			

			<li class="tag">
				interval scheduling
			</li>

			

			<li class="tag">
				greedy
			</li>

			

			<li class="tag">
				algorithm
			</li>

			

			<li class="tag">
				CSC373
			</li>

			
		</ul>

	</article>

	
		<div id="disqus_thread"></div>
<script>
	var disqus_config = function () {
	    this.page.url = "https://pyliaorachel.github.io";
	    this.page.identifier = "/blog/notes/algorithm/2016/10/10/greedy-algorithm.html";
	};
	(function() {
	    var d = document, s = d.createElement('script');
	    s.src = '//pyliaorachel.disqus.com/embed.js';
	    s.setAttribute('data-timestamp', +new Date());
	    (d.head || d.body).appendChild(s);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	
</div>
	</div>
</main>
		<footer>
	<div class="container-fluid">
		<div class="row">
			<div class="col-md-4 footer-link">
				<a href="mailto:rachel5566kk@gmail.com">
					<span class="icon icon-email">
						<img src="/assets/svg/email-logo.svg" alt="Email Logo">
					</span>
					<span class="username">rachel5566kk@gmail.com</span>
				</a>
			</div>
			<div class="col-md-4 footer-link">
				<a href="https://github.com/pyliaorachel"  target="_blank">
					<span class="icon icon-github">
						<img src="/assets/svg/github-logo.svg" alt="GitHub Logo">
					</span>
					<span class="username">pyliaorachel</span>
				</a>
			</div>
			<div class="col-md-4 footer-link">
				<a href="https://tw.linkedin.com/in/peiyu-liao" target="_blank">
					<span class="icon icon-linkedin">
						<img src="/assets/svg/linkedin-logo.svg" alt="LinkedIn Logo">
					</span>
					<span class="username">Peiyu Liao</span>
				</a>
			</div>
		</div><!-- /.row -->
		<div class="row">
			<div class="footer-copy-right">
				<p>2016	&copy; Liao Peiyu</p>
			</div >
		</div><!-- /.row -->
	</div><!-- /.container-fluid -->
</footer>
		<script type="text/javascript" src="/js/main.js"></script>
		<script type="text/javascript" src="/js/home.js"></script>
		<script id="dsq-count-scr" src="//pyliaorachel.disqus.com/count.js" async></script>
	</body>
</html>