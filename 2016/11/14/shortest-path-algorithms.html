<h2 id="content">Content</h2>

<ol>
  <li>Dijkstra’s Algorithm</li>
  <li>Bellman-Ford Algorithm</li>
  <li>Floyd–Warshall Algorithm</li>
  <li>Shortest Paths in DAGs</li>
</ol>

<!--more-->
<hr />
<h2 id="dijkstras-algorithm">Dijkstra’s Algorithm</h2>

<p><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/">GeeksForGeeks</a><br />
<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Wiki</a></p>

<h4 id="features">Features</h4>

<ul>
  <li>Only handles positive edges</li>
  <li>Need <strong>global information</strong></li>
  <li>Similar to <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/">Prim’s</a></li>
</ul>

<h4 id="implementation">Implementation</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Dijkstra(G, l, s):
# Input: Graph G = (V, E), directed or undirected;
		 positive edge lengths {le : e ∈ E}; vertex s ∈ V
# Output: For all vertices u reachable from s, dist(u) is set to the distance from s to u

	for all u ∈ V : 
		dist(u) = ∞
		prev(u) = nil 
	dist(s) = 0

	H = makequeue(V) # using dist-values as keys 
	while H is not empty:
		u = deletemin(H) # = |V| times
		for all edges (u, v) ∈ E:
			if dist(v) &gt; dist(u) + l(u, v): 
				dist(v) = dist(u) + l(u, v) 
				prev(v) = u 
				decreasekey(H, v) # = |V| + |E| times
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code># Alternative

Initialize dist(s) to 0, other dist(·) values to ∞ 
R = { } # the "known region"
while R != V:
	Pick the node v !∈ R with smallest dist(·) 
	Add v to R
	for all edges (v, z) ∈ E:
		if dist(z) &gt; dist(v) + l(v, z): 
			dist(z) = dist(v) + l(v, z)
</code></pre>
</div>

<h4 id="runtime">Runtime</h4>

<ul>
  <li>Binary heap: <code class="highlighter-rouge">O(|E|log|V|)</code></li>
  <li>Array: <code class="highlighter-rouge">O(|V|^2)</code></li>
</ul>

<h2 id="bellman-ford-algorithm">Bellman-Ford Algorithm</h2>

<p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/">GeeksForGeeks</a><br />
<a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Wiki</a></p>

<h4 id="features-1">Features</h4>

<ul>
  <li>Handles <strong>negative edges</strong></li>
  <li>Only need <strong>local information</strong> <a href="http://stackoverflow.com/questions/16273092/difference-between-bellman-ford-and-dijkstras-algorithm">StackOverflow</a></li>
</ul>

<h4 id="implementation-1">Implementation</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Bellman-Ford(G, l, s):
# Input: Directed graph G = (V, E);
		 edge lengths {le : e ∈ E} with no negative cycles; 
		 vertex s ∈ V
# Output: For all vertices u reachable from s, dist(u) is set to the distance from s to u

	for all u ∈ V : 
		dist(u) = ∞
		prev(u) = nil
	
	dist(s) = 0
	repeat |V| − 1 times:
		for all e ∈ E: 
			update(e)
</code></pre>
</div>

<h4 id="runtime-1">Runtime</h4>

<p><code class="highlighter-rouge">O(|V||E|)</code></p>

<h4 id="negative-cycle-detection">Negative Cycle Detection</h4>

<p>After <code class="highlighter-rouge">|V|-1</code> times of iterations, apply 1 extra round. If some <code class="highlighter-rouge">dist</code> reduced, then there is negative cycle.</p>

<h2 id="floyd-warshal-algorithm">Floyd-Warshal Algorithm</h2>

<p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/">GeeksForGeeks</a><br />
<a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Wiki</a></p>

<h4 id="features-2">Features</h4>

<ul>
  <li>Handles <strong>negative edges</strong></li>
  <li>Find shortest paths between <strong>all pairs of vertices</strong></li>
  <li>No <strong>negative cycles</strong></li>
</ul>

<h4 id="implementation-2">Implementation</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Floyd-Warshal(G, l, s):

	for all u ∈ V: 
		dist(u,u) = 0
	for all (u,v) ∈ E:
		dist(u,v) = l(u,v)

	for k = 1..|V|:
		for i = 1..|V|:
			for j = 1..|V|:
				if dist(i,j) &gt; dist(i,k) + dist(k,j)
					dist(i,j) = dist(i,k) + dist(k,j)
</code></pre>
</div>

<h4 id="runtime-2">Runtime</h4>

<p><code class="highlighter-rouge">O(|V|^3)</code></p>

<h2 id="shortest-paths-in-dags">Shortest Paths in DAGs</h2>

<h4 id="features-3">Features</h4>

<ul>
  <li>Vertices appear in <strong>increasing linearized order</strong> in any paths</li>
</ul>

<h4 id="implementation-3">Implementation</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Dag-shortest-paths(G, l, s):
# Input: DagG = (V,E);
		 edge lengths { le: e ∈ E };
		 vertex s ∈ V
# Output: For all vertices u reachable from s, dist(u) is set to the distance from s to u

for all u ∈ V: 
	dist(u) = ∞
	prev(u) = nil

dist(s) = 0
Linearize G # DFS
for each u ∈ V, in linearized order:
	for all edges (u, v) ∈ E: 
		update(u, v)
</code></pre>
</div>

