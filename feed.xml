<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MyCoon</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 04 Dec 2016 17:37:31 -0500</pubDate>
    <lastBuildDate>Sun, 04 Dec 2016 17:37:31 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Operating System - File Systems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Overview of File Systems&lt;/li&gt;
&lt;li&gt;File System Design&lt;/li&gt;
&lt;li&gt;Sharing Files&lt;/li&gt;
&lt;li&gt;Unix File System&lt;/li&gt;
&lt;li&gt;Consistency &amp;amp; Crash Recovery&lt;/li&gt;
&lt;li&gt;Journaling File Systems&lt;/li&gt;
&lt;li&gt;Log-Structured File Systems (LFS)&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Overview of File Systems&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Abstraction for storing, organizing, &amp;amp; accessing &lt;strong&gt;persistent data&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Data organized as objects called &lt;strong&gt;files&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Files accessed via &lt;strong&gt;system calls&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Basic File-Related Calls&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Open&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Program can keep the &lt;strong&gt;file description&lt;/strong&gt; returned to imporve file access efficiency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Read/Write&lt;/strong&gt;: r/w bytes from/to current position; update position&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Seek&lt;/strong&gt;: move to new position&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Close&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt;, &lt;strong&gt;rename&lt;/strong&gt;, &lt;strong&gt;delete&lt;/strong&gt;, &lt;strong&gt;get/set attributes&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Basic Directory-Related Calls&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Open&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Readdir&lt;/strong&gt;: read entries in a directory

&lt;ul&gt;
&lt;li&gt;No &lt;strong&gt;writedir&lt;/strong&gt; to avoid dir metadata corruption&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Seekdir&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Close&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt;, &lt;strong&gt;rename&lt;/strong&gt;, &lt;strong&gt;delete&lt;/strong&gt;, &lt;strong&gt;get/set attributes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Link/Unlink&lt;/strong&gt;: add/remove a name for an existing file

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hard link&lt;/strong&gt;: different directory entries have same inode number

&lt;ul&gt;
&lt;li&gt;Inodes maintains reference count&lt;/li&gt;
&lt;li&gt;Points to files not directories to avoid cycles (ensure directory deletion ok)&lt;/li&gt;
&lt;li&gt;Becomes &lt;strong&gt;DAG&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Symbolic link (short cut)&lt;/strong&gt;: a file containing data of another file&amp;#39;s name (redirect)

&lt;ul&gt;
&lt;li&gt;File type: shortcut (l)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;File System Design&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS needs to:

&lt;ul&gt;
&lt;li&gt;maintain information about files &amp;amp; directories&lt;/li&gt;
&lt;li&gt;store files durably&lt;/li&gt;
&lt;li&gt;handle machine crashes e.g. recover data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Disk Blocks&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Disks are accessed at the granularity of sectors; a file system allocates data in &lt;strong&gt;blocks&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Reduces overhead managing individual blocks&lt;/li&gt;
&lt;li&gt;Increase internal fragmentation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;File System Tasks&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Free block management&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bitmap&lt;/strong&gt;: separate area on disk

&lt;ul&gt;
&lt;li&gt;Allows allocating contiguous blocks to file easily&lt;/li&gt;
&lt;li&gt;Only need 1 bitmap block in memory at a time&lt;/li&gt;
&lt;li&gt;Extra space for bitmap&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Block allocation &amp;amp; replacement&lt;/strong&gt;: maps (potentially non-contiguous) blocks to file&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Contiguous allocation&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Good performance for sequential reading&lt;/li&gt;
&lt;li&gt;File growth requires copying&lt;/li&gt;
&lt;li&gt;Fragmentation; need periodic compaction&lt;/li&gt;
&lt;li&gt;Good for &lt;strong&gt;CD-ROMS&lt;/strong&gt;: file sizes known, files never deleted&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linked list allocation&lt;/strong&gt;: first word in block points to next block

&lt;ul&gt;
&lt;li&gt;Random accesses slow&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File allocation table (FAT)&lt;/strong&gt;: keep linked list information in memory

&lt;ul&gt;
&lt;li&gt;Random accesses faster&lt;/li&gt;
&lt;li&gt;Entire table in memory, poor scalibility of file system&lt;/li&gt;
&lt;li&gt;More efficient than i-node on small files&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I-node based allocation&lt;/strong&gt;: tree to store index information&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Allows growth of index information without spreading this information too much&lt;/li&gt;
&lt;li&gt;Optimized for small files&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Root of tree: &lt;strong&gt;inode&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;12 &lt;strong&gt;direct block pointers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1 &lt;strong&gt;indirect pointer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1 &lt;strong&gt;double indirect pointer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;1 &lt;strong&gt;triple indirect pointer&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;                    disk partitions
|MBR||||    |                                  |    |   |
            /                                   \
           |Super|Inode |Block |Inode |File &amp;amp; dir|
           |block|bitmap|bitmap|blocks|blocks    |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block placement&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Problems

&lt;ul&gt;
&lt;li&gt;Data blocks scatter across disk in &lt;em&gt;aging&lt;/em&gt; file systems -&amp;gt; long seeks&lt;/li&gt;
&lt;li&gt;Inodes at beginning of disk, far from data -&amp;gt; going back and forth -&amp;gt; long seeks&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;BSD Fast File System&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Disk partitioned into groups of cylinders&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Superblocks&lt;/strong&gt; placed in every group &amp;amp; in offset manner to recover from damage&lt;/li&gt;
&lt;li&gt;Place these in same cylinder group:

&lt;ul&gt;
&lt;li&gt;Inode, data blocks in a file&lt;/li&gt;
&lt;li&gt;Files in a directory&lt;/li&gt;
&lt;li&gt;Place in nearby group if group full&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Directory management&lt;/strong&gt;: map file names to location of starting block of file&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|file name|file attributes|starting block #|
...

# Unix
|file name|i-node #| # i-node contains file attributes
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;File names&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Short, fixed length names&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Variable length names&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Size of directory entry variable&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Options&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Entries allocated contiguously: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|len|name|inode|len|name|inode|...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-&amp;gt; Inefficient for search; fragmentation  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Allocate pointers to file names in the beginning of directory; heap at end to store names&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|p1|hash of name1| # fixed size
|p2|hash of name2|
...
p1-&amp;gt; |name1|inode| # variable size
p2-&amp;gt; |name2|inode|name3|inode|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;File deletion&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Directory entry removed from directory&lt;/li&gt;
&lt;li&gt;All blocks in file returned to free list&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Path lookup: e.g. &lt;code&gt;/D1/D2/F&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Super block (locatin of inode blocks area; typically already cached in memory)&lt;/li&gt;
&lt;li&gt;Inode of &lt;code&gt;/&lt;/code&gt; -&amp;gt; data blocks of &lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Inode of &lt;code&gt;D1&lt;/code&gt; -&amp;gt; data blocks of &lt;code&gt;D1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Inode of &lt;code&gt;D2&lt;/code&gt; -&amp;gt; data blocks of &lt;code&gt;D2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Inode of &lt;code&gt;F&lt;/code&gt; (returned in &lt;code&gt;open&lt;/code&gt;) -&amp;gt; data blocks of &lt;code&gt;F&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Buffer cache management&lt;/strong&gt;: cache disk block in memory&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Operations&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Block lookup&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# hash table to lookup blocks in memory

      key
|device|block #| -&amp;gt; |disk block in memory| -&amp;gt; ...
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Block miss&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Block flush&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Limited size: need replacement algorithms&lt;/li&gt;
&lt;li&gt;Competes with VM system about frames

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Separate cache&lt;/strong&gt;: inefficient use of cache if not doing file I/O&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unified cache&lt;/strong&gt;: large file I/O affects performance of other programs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Read ahead&lt;/strong&gt;: prefetch next block from disk&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Sharing Files&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Issues

&lt;ul&gt;
&lt;li&gt;Concurrent access

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sequential consistency&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;read&lt;/code&gt; call sees data from most recently &lt;strong&gt;finished&lt;/strong&gt; &lt;code&gt;write&lt;/code&gt; call&lt;/li&gt;
&lt;li&gt;All processors see same order of writes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Protection

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Subject&lt;/strong&gt;: &lt;strong&gt;who&lt;/strong&gt; can access a file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object&lt;/strong&gt;: the file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action&lt;/strong&gt;: how can they access a file

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;change protection&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Mechanisms

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Access control lists (ACL)&lt;/strong&gt;: object -&amp;gt; subjects &amp;amp; actions

&lt;ul&gt;
&lt;li&gt;Easy to grant, revoke&lt;/li&gt;
&lt;li&gt;Becomes large when heavily shared -&amp;gt; use &lt;strong&gt;groups&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Capabilities&lt;/strong&gt;: subject -&amp;gt; objects &amp;amp; actions

&lt;ul&gt;
&lt;li&gt;Easy to transfer&lt;/li&gt;
&lt;li&gt;Hard to revoke&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Unix File System&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# In memory

Parent's fd table   Open file table
-----------         |File position|
-----------         |R/W          |
----------- ------&amp;gt; |Ptr to i-node|
...                 ---------------
                    |             |
Child's fd table  / |             |
-----------      /  ...
----------- -----
-----------
...

# Child can copy parent's fd table when forked
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;File-Related System Calls&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fd = open(name,mode)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Path lookup: find inode of file&lt;/li&gt;
&lt;li&gt;Cache inode in buffer cache&lt;/li&gt;
&lt;li&gt;Check permissions&lt;/li&gt;
&lt;li&gt;Set up entry in open file table&lt;/li&gt;
&lt;li&gt;Set up entry in fd table&lt;/li&gt;
&lt;li&gt;Return fd&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byte_count = read(fd, buffer, buffer_size)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt; Figure out data/indirect blocks to read&lt;/li&gt;
&lt;li&gt;Read from disk into buffer cache&lt;/li&gt;
&lt;li&gt;Copy data to user buffer&lt;/li&gt;
&lt;li&gt;Update file position&lt;/li&gt;
&lt;li&gt;Return # of bytes read&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byte_count = write(fd, buffer, num_bytes)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt; Figure out data/indirect blocks to write&lt;/li&gt;
&lt;li&gt;Read from disk into buffer cache&lt;/li&gt;
&lt;li&gt;Copy data from user buffer to buffer cache&lt;/li&gt;
&lt;li&gt;Update i-node&lt;/li&gt;
&lt;li&gt;Mark modified buffers dirty (inode, free maps, indirect, data blocks, etc.)&lt;/li&gt;
&lt;li&gt;Schedule writing dirty buffers to disk&lt;/li&gt;
&lt;li&gt;Update file position&lt;/li&gt;
&lt;li&gt;Return # of bytes written&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close(fd)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Mounting File Systems&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;File system namespace&lt;/strong&gt;: set of names for all files in a file system&lt;/li&gt;
&lt;li&gt;File system &lt;strong&gt;mounting&lt;/strong&gt; glues a file system namespace into the namespace of another file system&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Consistency &amp;amp; Crash Recovery&lt;/h2&gt;

&lt;h4&gt;Deleting a Unix File&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Remove file&amp;#39;s directory entry in directory data block&lt;/li&gt;
&lt;li&gt;Mark inode of file as free in inode bitmap; mark file blocks as free in block bitmap; update metadata in inode of directory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Crash in between leads to &lt;strong&gt;storage leak&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Switch steps. Crash in between leads to &lt;strong&gt;dangling pointer&lt;/strong&gt;.&lt;/p&gt;

&lt;h4&gt;Reducing File System Inconsistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Write-through metadata blocks

&lt;ul&gt;
&lt;li&gt;Avoid dangling pointers&lt;/li&gt;
&lt;li&gt;Still inconsistent for the last file system operation before a crash&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Write-back data blocks

&lt;ul&gt;
&lt;li&gt;Most blocks are data blocks, improves file system performance&lt;/li&gt;
&lt;li&gt;Data blocks can be lost without affecting file system consistency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Crash recovery&lt;/strong&gt;: restore file system consistency
    - Full scan of file system to recover inconsistent states
    - Long time since disk capacities increase faster than disk throughput&lt;/li&gt;
&lt;li&gt;Avoid crash recovery:

&lt;ul&gt;
&lt;li&gt;Use &lt;strong&gt;battery-backed RAM&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Ensure enough power to write all dirty blocks to disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Failure atomicity&lt;/strong&gt;: a file system operation either doesn&amp;#39;t happen at all or happens completely

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Undo recovery&lt;/strong&gt;

&lt;ol&gt;
&lt;li&gt;Copy old block on disk to spare block on disk (mark done)&lt;/li&gt;
&lt;li&gt;Copy new block in memory to block on disk&lt;/li&gt;
&lt;li&gt;Remove spare block&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redo recovery&lt;/strong&gt;

&lt;ol&gt;
&lt;li&gt;Copy new block in memory to spare block on disk (mark done)&lt;/li&gt;
&lt;li&gt;Copy new block in memory to old block on disk&lt;/li&gt;
&lt;li&gt;Remove spare block&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Journaling File Systems&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Write-ahead logging&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Write new versions of blocks in a &lt;strong&gt;journal&lt;/strong&gt; (circular log)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt; when done&lt;/li&gt;
&lt;li&gt;File system then updates asynchronously&lt;/li&gt;
&lt;li&gt;Copy journal blocks to file system on crash where commit is present&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Steps&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Write blocks (e.g. B,I,D) to journal &lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write commit block to journal&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|...|TransactionHeaderBlock|B'|I'|D'|Commit|

# TransactionHeaderBlock contains block # of the following blocks
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install: copy updated B,I,D to file system&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Free transaction in journal&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Observation based on FFS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;As memory gets larger, need to &lt;strong&gt;optimize for writes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Reads: read from buffer cache, less of performance problem&lt;/li&gt;
&lt;li&gt;Writes: becomes heavy for synchronous operations &amp;amp; data integrity

&lt;ul&gt;
&lt;li&gt;Also, writes are not well clustered i.e. directory, inodes, data are scattered&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Log-Structured File Systems (LFS)&lt;/h2&gt;

&lt;p&gt;Write all file system data &amp;amp; metadata in a contiguous log.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LFS reads&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;When inodes updated, written in log (scattered in log)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inode-map&lt;/strong&gt;: an array in memory to locate inodes

&lt;ul&gt;
&lt;li&gt;Inode # -&amp;gt; inode location in log&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LFS writes&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When inodes updated, inode-map has to be updated &amp;amp; stored on disk (inode-map itself stored in the log)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Uses &lt;strong&gt;checkpoint region&lt;/strong&gt; in a fixed area on disk&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Locates inode-map blocks in log&lt;/li&gt;
&lt;li&gt;Serves as a commit point&lt;/li&gt;
&lt;li&gt;Region updated when inode-map blocks written&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|superblock|checkpoint region|      segment       |segment|...|
                            /                      \
                            |segment|inode|inode|...|
                            |header |     |map  |...|

# Checkpoint region -&amp;gt; inode map -&amp;gt; inode -&amp;gt; data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Kepp 2 checkpoint regions to ensure faulure atomicity on checkpoint region itself&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Log space reclamation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reclaim segments when:

&lt;ul&gt;
&lt;li&gt;blocks overwritten&lt;/li&gt;
&lt;li&gt;blocks deleted&lt;/li&gt;
&lt;li&gt;live blocks have to be copied out of segments&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Wear leveling&lt;/strong&gt;: writing to SSD in log fashion&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Since each block in SSD has limited endurance, log fashion ensures writes to be spread evenly on disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Comparison on Journaling File Systems &amp;amp; Log-Structured File Systems&lt;/h3&gt;

&lt;h4&gt;Journaling&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Motivation: speed up crash recovery&lt;/li&gt;
&lt;li&gt;Benefit: speeds up crash recovery&lt;/li&gt;
&lt;li&gt;Drawback: every block write becomes two block writes&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Log-Structured&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Motivation: reads will be absorbed by buffer cache, optimize for writes by issuing all writes sequentially&lt;/li&gt;
&lt;li&gt;Drawback: 

&lt;ol&gt;
&lt;li&gt;Reads not sequential if file created sequentially&lt;/li&gt;
&lt;li&gt;Need garbage collection -&amp;gt; affect normal I/O performance&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Writes: 1 or more; 1 for writing to log, more for cleaning process&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://pages.cs.wisc.edu/%7Eremzi/OSTEP/file-lfs.pdf&quot;&gt;Log-structured File Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Dec 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/os/2016/12/02/operating-system-file-systems.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/12/02/operating-system-file-systems.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>file system</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>Operating System - Disk &amp; RAID</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Disks

&lt;ul&gt;
&lt;li&gt;Disk Scheduling Algorithms&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redundant Array of Inexpensive Disks (RAID)&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Disks&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Disk&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Platters&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;1 &lt;strong&gt;arm&lt;/strong&gt;: move together&lt;/li&gt;
&lt;li&gt;1 &lt;strong&gt;head&lt;/strong&gt;: access data in parallel&lt;/li&gt;
&lt;li&gt;Concentric &lt;strong&gt;tracks&lt;/strong&gt;: same track across different platters

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sectors&lt;/strong&gt;: preamble + data + 16B of ECC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disk access delays

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Seek time&lt;/strong&gt;: move head to correct track&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rotational delay&lt;/strong&gt;: rotate to correct sector&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transfer time&lt;/strong&gt;: r/w bits of sector (fastest among all)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disk performance trends

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Capacity&lt;/strong&gt;: 2x every 2 years&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transfer rate (BW)&lt;/strong&gt;: 2x every 2 years&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Seek &amp;amp; rotation time&lt;/strong&gt;: 1/2 every 10 years&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disk performance

&lt;ul&gt;
&lt;li&gt;Highest bandwidth for sequential access&lt;/li&gt;
&lt;li&gt;Worst bandwidth for random access&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disk scheduling

&lt;ul&gt;
&lt;li&gt;Aims to minimize &lt;strong&gt;seek time&lt;/strong&gt; (&lt;strong&gt;rotational delay&lt;/strong&gt; hard to control)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Addressing disks

&lt;ul&gt;
&lt;li&gt;Older disks: require OS to specify all parameters e.g. cylinder, track, sector, transfer size, etc.&lt;/li&gt;
&lt;li&gt;Modern disks: complicated e.g. not all sectors the same size, sectors are remapped, etc.&lt;/li&gt;
&lt;li&gt;Current disks: higher-level interface, exports data as logical array of sectors &amp;amp; maps logical sectors to its surface&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disk errors

&lt;ul&gt;
&lt;li&gt;Latent sector errors, mis-directed writes&lt;/li&gt;
&lt;li&gt;Transient v.s. hard errors&lt;/li&gt;
&lt;li&gt;Some errors can be masked by &lt;strong&gt;ECC&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bad sectors&lt;/strong&gt;: physical damage; mapped to spare in factory, by disk controller&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Disk Scheduling Algorithms&lt;/h3&gt;

&lt;p&gt;Aims to minimize &lt;strong&gt;seek time&lt;/strong&gt; (&lt;strong&gt;rotational delay&lt;/strong&gt; hard to control).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 methods

&lt;ul&gt;
&lt;li&gt;Reduce seek &amp;amp; rotation&lt;/li&gt;
&lt;li&gt;Read several sectors at once&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Algorithms

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FCFS&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Simple, fair, slow&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shortest seek time first (SSF)&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Starvation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SCAN (elevator)&lt;/strong&gt;: serve next request in same direction (a bit to track arm direction)

&lt;ul&gt;
&lt;li&gt;Benefits tracks in the middle more&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-SCAN&lt;/strong&gt;: SCAN in one direction&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Redundant Array of Inexpensive Disks (RAID)&lt;/h2&gt;

&lt;p&gt;Use many disks in parallel; increases storage bandwidth, improves reliability.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stripe&lt;/strong&gt;: unit of r/w to RAID

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Chunks/Strips&lt;/strong&gt;: unit of r/w to a single disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Improving storage bandwidth

&lt;ul&gt;
&lt;li&gt;Chunks on different disks can be r/w in parallel&lt;/li&gt;
&lt;li&gt;Large chunk size:

&lt;ul&gt;
&lt;li&gt;Fewer seeks across disks -&amp;gt; better throughput&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;More disks:

&lt;ul&gt;
&lt;li&gt;Bandwidth increases&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Large stripe size:

&lt;ul&gt;
&lt;li&gt;Internal fragmentation&lt;/li&gt;
&lt;li&gt;Should be based on average file size&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;RAID Level 0: Disk Striping&lt;/h3&gt;

&lt;p&gt;Distributes data across several disks for speed. No redundancy.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;| Strip 0 | | Strip 1 | | Strip 2 | | Strip 3 |
| Strip 4 | | Strip 5 | | Strip 6 | | Strip 7 |
| Strip 8 | | Strip 9 | | Strip 10| | Strip 11|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RAID Level 1: Mirroring&lt;/h3&gt;

&lt;p&gt;Backup. Write both, read either.&lt;br&gt;
Utilization: 50%&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;| Strip 0 | | Strip 1 | | Strip 2 | | Strip 3 | | Strip 0 | | Strip 1 | | Strip 2 | | Strip 3 |
| Strip 4 | | Strip 5 | | Strip 6 | | Strip 7 | | Strip 4 | | Strip 5 | | Strip 6 | | Strip 7 |
| Strip 8 | | Strip 9 | | Strip 10| | Strip 11| | Strip 8 | | Strip 9 | | Strip 10| | Strip 11|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RAID Level 4: Dedicated Parity Disk&lt;/h3&gt;

&lt;p&gt;Calculate XOR value of chunks and store on parity disk.
Utilization: (N-1)/N&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# P0-3 = S0 ^ S1 ^ S2 ^ S3
# P'0-3 = S'0 ^ S1 ^ S2 ^ S3 = S'0 ^ S0 ^ P0-3

| Strip 0 | | Strip 1 | | Strip 2 | | Strip 3 | | P0-3 |
| Strip 4 | | Strip 5 | | Strip 6 | | Strip 7 | | P4-7 |
| Strip 8 | | Strip 9 | | Strip 10| | Strip 11| | P8-11|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RAID Level 5: Distributed Parity&lt;/h3&gt;

&lt;p&gt;Parity information distributed across all disks. Avoids bottleneck for parity disk.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;| Strip 0 | | Strip 1 | | Strip 2 | | Strip 3 | | P0-3    |
| Strip 4 | | Strip 5 | | Strip 6 | | P4-7    | | Strip 7 |
| Strip 8 | | Strip 9 | | P8-11   | | Strip 10| | Strip 11|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zdnet.com/article/chunks-the-hidden-key-to-raid-performance/&quot;&gt;Chunks: the hidden key to RAID performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pcguide.com/ref/hdd/perf/raid/concepts/perfStripe-c.html&quot;&gt;Stripe Width and Stripe Size&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 01 Dec 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/os/2016/12/01/operating-system-disk-and-raid.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/12/01/operating-system-disk-and-raid.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>disk</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>Coping with NP-Complete Problems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Intelligent Exhaustive Search

&lt;ol&gt;
&lt;li&gt;Backtracking&lt;/li&gt;
&lt;li&gt;Branch-and-Bound&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Approximation Algorithms

&lt;ol&gt;
&lt;li&gt;Vertex Cover&lt;/li&gt;
&lt;li&gt;Clustering&lt;/li&gt;
&lt;li&gt;TSP&lt;/li&gt;
&lt;li&gt;Knapsack&lt;/li&gt;
&lt;li&gt;Approximability Hierarchy&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Local Search Heuristics

&lt;ol&gt;
&lt;li&gt;TSP&lt;/li&gt;
&lt;li&gt;Graph Partitioning&lt;/li&gt;
&lt;li&gt;Dealing with Local Optima&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Intelligent Exhaustive Search&lt;/h2&gt;

&lt;h3&gt;Backtracking&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Start with some problem P0
Let S = {P0}, the set of active subproblems 
Repeat while S is nonempty:
    choose a subproblem P ∈ S and remove it from S 
    expand it into smaller subproblems P1, P2, ..., Pk 
    For each Pi:
        If test(Pi) succeeds: halt and announce this solution
        If test(Pi) fails: discard Pi
        Otherwise: add Pi to S # uncertainty
Announce that there is no solution
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Branch-and-Bound&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Start with some problem P0
Let S = {P0}, the set of active subproblems bestsofar = ∞
Repeat while S is nonempty:
    choose a subproblem (partial solution) P ∈ S and remove it from S 
    expand it into smaller subproblems P1, P2, ..., Pk
    For each Pi:
        If Pi is a complete solution: update bestsofar
        else if lowerbound(Pi) &amp;lt; bestsofar: add Pi to S
return bestsofar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jot.fm/issues/issue_2003_05/column7/&quot;&gt;TSP example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Approximation Algorithms&lt;/h2&gt;

&lt;p&gt;Minimize &lt;code&gt;αA = max_I(A(I)/OPT(I))&lt;/code&gt;, where &lt;code&gt;αA&lt;/code&gt; is the &lt;strong&gt;approximation ratio&lt;/strong&gt; of algorithm &lt;code&gt;A&lt;/code&gt;.  &lt;/p&gt;

&lt;h3&gt;Vertex Cover&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Input: undirected graph G = (V, E)
Output: a subset of the vertices S ⊆ V that touches every edge
Goal: Minimize |S|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Greedy algorithm (used for &lt;strong&gt;set cover&lt;/strong&gt; problem)&lt;/p&gt;

&lt;p&gt;Repeatedly include the highest degree in the vertex cover.&lt;br&gt;
=&amp;gt; factor &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Matching&lt;/p&gt;

&lt;p&gt;A subset of edges that have no vertices in common.&lt;br&gt;
If &lt;code&gt;S&lt;/code&gt; is the set containing both endpoints of each edge in maximal matching &lt;code&gt;M&lt;/code&gt;, then &lt;code&gt;S&lt;/code&gt; is vertex cover.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Any matching is a &lt;strong&gt;lower bound&lt;/strong&gt; on &lt;code&gt;OPT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Maximal matching with &lt;code&gt;M&lt;/code&gt; edges provides &lt;code&gt;2M&lt;/code&gt; &lt;strong&gt;upper bound&lt;/strong&gt; on &lt;code&gt;OPT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Find a maximal matching M ⊆ E
Return S = {all endpoints of edges in M }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; factor &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Clustering&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Divide some data into groups. Distances between data points are defined:

1. d(x,y) ≥ 0 for all x,y
2. d(x,y) = 0 iff x = y
3. d(x,y) = d(y,x)
4. (Triangle inequality) d(x,y) ≤ d(x,z) + d(z,y)

k-CLUSTER:

Input: points X = {x1, ..., xn} with underlying distance metric d(·,·); integer k 
Output: a partition of points into k clusters C1, ..., Ck
Goal: minimize diameter of the clusters,
        max_j(max_xa,xb∈Cj(d(xa,xb))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Farthest-first traversal&lt;/p&gt;

&lt;p&gt;Pick k of the data points as cluster centers one at a time and always pick the next center to be as far as possible from the centers chosen so far.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Pick any point μ1 ∈ X as the first cluster center 
for i = 2 to k:
    Let μi be the point in X that is farthest from μ1, ..., μi−1 (i.e. maximizes min_j&amp;lt;i(d(·,μj)))
Create k clusters: Ci = {all x ∈ X whose closest center is μi}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; factor &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Argument

1.
Let x ∈ X be the point farthest from μ1, ..., μk
Let r be its distance to closest center
=&amp;gt; every point in X must be within distance r of its cluster center
=&amp;gt; every cluster has diameter &amp;lt;= 2r

2.
{μ1, ..., μk, x} are all at distance &amp;gt;= r
=&amp;gt; any partition into k clusters must put 2 of them in same cluster
=&amp;gt; diameter at least r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;TSP&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MST for metric TSP&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TSP cost ≥ cost of this path ≥ MST cost&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;From MST, going through each edge twice ends up with a TSP, so &lt;code&gt;length &amp;lt;= 2 * MST cost &amp;lt;= 2 * TSP cost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further skip any city about to revisit and instead move directly to the next new city.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;General TSP -&amp;gt; Rudrata Path&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;For an instance I(G, C) of the TSP:
    If G has a Rudrata path, then OPT(I(G,C)) = n
    If G has no Rudrata path, then OPT(I(G,C)) ≥ n + C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Given any graph G:
    compute I(G,C) (with C = n * αA)
    run approximation algorithm A for TSP on it 
    if the resulting tour has length ≤ nαA:
        G has a Rudrata path 
    else: 
        G has no Rudrata path
# can find the path by calling procedure polynomial number of times
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If TSP has a polynomial-time approximation algorithm, then there is a polynomial algorithm for Rudrata path problem. So unless P = NP, there cannot exist an efficient approximation algorithm for TSP.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Knapsack&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. Change O(nW) algorithm into O(nV)
2. Scale v'i = ⌊vi * n/εvmax⌋
3. Since rescaled values v'i are all at most n/ε, DP runs in O(n^3/ε)

Discard any item with weight &amp;gt; W
Let v_max = max_i(vi)
Rescale values v'i = ⌊vi * n/εvmax⌋
Run DP with values {v'i} 
Output the resulting choice of items

Let K* be the total value of the original optimal solution.

sum_i∈S(v'i) = sum_i∈S(⌊vi * n/εvmax⌋) &amp;gt;= sum_i∈S(vi * n/εvmax - 1) &amp;gt;= K* * (n/εvmax) - n

Scaling back:

sum_i∈S'(vi) &amp;gt;= sum_i∈S'(v'i * εvmax/n) &amp;gt;= (K* * (n/εvmax) - n)* εvmax/n = K* - εvmax &amp;gt;= K* * (1-ε)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Approximability Hierarchy&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;No finite approximation ratio possible (TSP)&lt;/li&gt;
&lt;li&gt;Approximation ratio possible, but with limits (Vertex Cover, k-Cluster, Metric TSP)&lt;/li&gt;
&lt;li&gt;Approximation ratio possible with no limits (Knapsack)&lt;/li&gt;
&lt;li&gt;Approximation ration about &lt;code&gt;logn&lt;/code&gt; (Set Cover)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Local Search Heuristics&lt;/h2&gt;

&lt;p&gt;Introduce small mutations, try them out, keep them if work well.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;let s be any initial solution
while there is some solution s' in the neighborhood of s
for which cost(s′) &amp;lt; cost(s): 
    replace s by s' 
return s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;TSP&lt;/h3&gt;

&lt;h4&gt;2-Change Neighborhood&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;o---o  o---o        o---o--o---o
|    \/    |    -&amp;gt;  |          |
|    /\    |        |          |
o---o  o---o        o---o--o---o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Runtime

&lt;ul&gt;
&lt;li&gt;A tour has &lt;code&gt;O(n^2)&lt;/code&gt; neighbors&lt;/li&gt;
&lt;li&gt;# of iterations unknown&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimality

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Locally optimal&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Efficiency &amp;amp; Tradeoffs&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Less neighbors -&amp;gt; searched quickly -&amp;gt; efficient

&lt;ul&gt;
&lt;li&gt;Higher chance of low-quality local optima&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Graph Partitioning&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Input: undirected graph with nonnegative edge weights; a real number α ∈ (0, 1/2]
# Output: a partition of vertices into groups A &amp;amp; B, each of size &amp;gt;= α|V|
# Goal: minimize capacity of cut (A, B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;If no restriction on size, then &lt;strong&gt;min cut problem&lt;/strong&gt; -&amp;gt; can be solved efficiently&lt;/li&gt;
&lt;li&gt;Suppose &lt;code&gt;α = 1/2&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;Randomly choose a partition &lt;code&gt;(A,B)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Neighbor: &lt;code&gt;(A-{a}+{b}, B-{b}+{a})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dealing with Local Optima&lt;/h3&gt;

&lt;h4&gt;Randomization &amp;amp; Restarts&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;If probability of reaching a gool local optimum on any given run is &lt;code&gt;p&lt;/code&gt;, then within &lt;code&gt;O(1/p)&lt;/code&gt; runs, such a solution is likely to be found&lt;/li&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;As problem size grows, the ratio of bad to good local optima often increases&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Simulated annealing&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Start with large temperature T (probability big), gradually reduce to 0 (probability small)

let s be any starting solution repeat
randomly choose a solution s' in the neighborhood of s if ∆ = cost(s') − cost(s) is negative:
    replace s by s' 
else:
    replace s by s' with probability e^(−∆/T)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Initially: 

&lt;ul&gt;
&lt;li&gt;Local search wanders around freely&lt;/li&gt;
&lt;li&gt;Mild preference for low-cost solutions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;As time goes on: 

&lt;ul&gt;
&lt;li&gt;Preference becomes stronger and sticks to lower-cost region&lt;/li&gt;
&lt;li&gt;Random excursions to escape local optima&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cost

&lt;ul&gt;
&lt;li&gt;More local moves needed until convergence due to initial freedom&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Annealing schedule&lt;/strong&gt;: timetable to decrease temperature&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cseweb.ucsd.edu/%7Edasgupta/291-geom/kcenter.pdf&quot;&gt;UCSD Notes on Clustering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mathworld.wolfram.com/SimulatedAnnealing.html&quot;&gt;Wolfram - Simulated Annealing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://artint.info/html/ArtInt_89.html&quot;&gt;Simulated Annealing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 28 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/28/coping-with-np-complete-problems.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/28/coping-with-np-complete-problems.html</guid>
        
        <category>np-complete</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Parallelism Overview

&lt;ol&gt;
&lt;li&gt;Standard Models of Parallelism&lt;/li&gt;
&lt;li&gt;Speedup&lt;/li&gt;
&lt;li&gt;Dependence&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Threads &amp;amp; Processes

&lt;ol&gt;
&lt;li&gt;Pthreads&lt;/li&gt;
&lt;li&gt;Synchronization&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Data Parallelism

&lt;ol&gt;
&lt;li&gt;Matrix Multiplication (Regular)&lt;/li&gt;
&lt;li&gt;SOR (Regular)&lt;/li&gt;
&lt;li&gt;Molecular Dynamics (Irregular)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Task Parallelism

&lt;ol&gt;
&lt;li&gt;PIPE (Pipelines)&lt;/li&gt;
&lt;li&gt;TSP (Task Queue)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Parallelism Overview&lt;/h2&gt;

&lt;h3&gt;Standard Models of Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shared memory (pthreads)&lt;/li&gt;
&lt;li&gt;Shared memory + data parallelism (OpenMP)&lt;/li&gt;
&lt;li&gt;Message passing (MPI)&lt;/li&gt;
&lt;li&gt;Transactional memory (TM)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Speedup&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;speedup on problem = sequential execution time of best known sequential algorithm / execution time on p processors&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Avoids picking easily parallelizable algorithm with poor sequential execution time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linear speedup is best to be achieved

&lt;ul&gt;
&lt;li&gt;Sub-linear speedup: due to overhead of &lt;em&gt;startup&lt;/em&gt;, &lt;em&gt;synchronization&lt;/em&gt;, &lt;em&gt;communication&lt;/em&gt;, ...&lt;/li&gt;
&lt;li&gt;Super-linear speedup

&lt;ul&gt;
&lt;li&gt;Cache/memory effects&lt;/li&gt;
&lt;li&gt;Nondeterminism in search problems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amdahl&amp;#39;s Law&lt;/strong&gt;: if &lt;code&gt;1/s&lt;/code&gt; of program is sequential, speedup will not be better than &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dependence&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;True dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; reads a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value read by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Output dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop carried dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Statements are part of the execution of a loop&lt;/li&gt;
&lt;li&gt;e.g. &lt;code&gt;a[i] = f(a[i-1]) + 1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Prevents loop iteration parallelization&lt;/li&gt;
&lt;li&gt;Level of loop carried dependence: nesting depth of loop that carries dependence&lt;/li&gt;
&lt;li&gt;&amp;lt;-&amp;gt; &lt;strong&gt;Loop independent dependence&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Threads &amp;amp; Processes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Similarities

&lt;ul&gt;
&lt;li&gt;Own logical control flow&lt;/li&gt;
&lt;li&gt;Run concurrently with others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Differences

&lt;ul&gt;
&lt;li&gt;Threads share code &amp;amp; data, processes don&amp;#39;t&lt;/li&gt;
&lt;li&gt;Process control &amp;amp; context switches more expensive than thread control &amp;amp; thread switches&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Pthreads&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;User has to:

&lt;ul&gt;
&lt;li&gt;Decompose computation into parallel parts&lt;/li&gt;
&lt;li&gt;Create/destroy threads&lt;/li&gt;
&lt;li&gt;Add synchronization to ensure dependences covered&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pthread_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_join()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Synchronization&lt;/h3&gt;

&lt;h4&gt;Parallelization Options&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Course-grained locking&lt;/strong&gt;: 1 big lock for critical section

&lt;ul&gt;
&lt;li&gt;Limited parallelism&lt;/li&gt;
&lt;li&gt;Easy to implement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fine-grained locking&lt;/strong&gt;: 1 lock per variable used in critical section

&lt;ul&gt;
&lt;li&gt;Good parallelism: less dependencies&lt;/li&gt;
&lt;li&gt;Hard to implement

&lt;ul&gt;
&lt;li&gt;Deadlock, fault tolerance, priority inversion, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semaphores&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fork-Join&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Barriers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reductions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Data Parallelism&lt;/h2&gt;

&lt;p&gt;Processors do the same thing on different data.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regular&lt;/strong&gt;: linear indexing

&lt;ul&gt;
&lt;li&gt;All arrays accessed through linear expressions of loop indices, known at compile time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Irregular&lt;/strong&gt;: non-linear indexing

&lt;ul&gt;
&lt;li&gt;Some arrays accessed through non-linear expressions of loop indices, some only known at runtime&lt;/li&gt;
&lt;li&gt;Difficult for parallelism based on &lt;em&gt;data distribution&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Not difficult for parallelism based on &lt;em&gt;iteration distribution&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Matrix Multiplication (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    for (j = 0; j &amp;lt; n; j++)
        c[i][j] = 0.0; 
for (i = 0; i &amp;lt; n; i++)
    for (j = 0; j &amp;lt; n; j++)
        for (k = 0; k &amp;lt; n; k++)
            c[i][j] += a[i][k] * b[k][j];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences on i-/j- loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence&lt;/strong&gt; on k-loop&lt;/li&gt;
&lt;li&gt;Data Distribution

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block distribution&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by row&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cyclic distrubution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block cyclic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Combinations&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;SOR (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps/iterations {
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            temp[i][j] = 0.25 *
                (grid[i-1][j] + grid[i+1][j] + grid[i][j-1] + grid[i][j+1]);
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            grid[i][j] = temp[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No dependences between 1st &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;No dependences between 2nd &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd loop nest in the same timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 2nd &amp;amp; 1st loop nest of next timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Molecular Dynamics (Irregular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps { 
    for all molecules i
        for all nearby molecules j
            force[i] += f(loc[i], loc[j]);
    for all molecules i
        loc[i] = g(loc[i], force[i]);
}

for each molecule i
    number of nearby molecules count[i]
    array of indices of nearby molecules index[j] // 0 &amp;lt;= j &amp;lt; count[i]

for some number of timesteps { 
    for (i = 0; i &amp;lt; num_mol; i++)
        for (j = 0; j &amp;lt; count[i]; j++)
            force[i] += f(loc[i], loc[index[j]]);
    for (i = 0; i &amp;lt; num_mol; i++)
        loc[i] = g(loc[i], force[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences in 1st i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;li&gt;May have &lt;strong&gt;load balancing&lt;/strong&gt; problem&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence (reduction)&lt;/strong&gt; on j-loop&lt;/li&gt;
&lt;li&gt;No loop-carried dependences in 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Fork-join between loops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Task Parallelism&lt;/h2&gt;

&lt;p&gt;Processors do different tasks.&lt;/p&gt;

&lt;h3&gt;PIPE (Pipelines)&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Case 1&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i =0 ; i &amp;lt; num_pic, read(in_pic[i]); i++) {    
    int_pic_1[i] = trans1(in_pic[i]); 
    int_pic_2[i] = trans2(int_pic_1[i]); 
    int_pic_3[i] = trans3(int_pic_2[i]); 
    out_pic[i] = trans4(int_pic_3[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;// Assign each transformation to a processor
// Processor 1
for (i = 0; i &amp;lt; num_pics, read(in_pic[i]); i++) { 
    int_pic_1[i] = trans1(in_pic[i]); 
    signal(event_1_2[i]);
}
// Processor 2
for (i = 0; i &amp;lt; num_pics; i++) {
    wait(event_1_2[i]);
    int_pic_2[i] = trans1(int_pic_1[i]);
    signal(event_2_3[i]);
}
// Processor 3
...
// Processor 4
for (i = 0; i &amp;lt; num_pics; i++) {
    wait(event_3_4[i]);
    out_pic[i] = trans1(int_pic_3[i]); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;Each stage (transformation) may take different time to finish&lt;/li&gt;
&lt;li&gt;Stages take a variable amount of time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;semaphore_wait/signal&lt;/strong&gt; with &lt;code&gt;pthread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Case 2&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i =0 ; i &amp;lt; num_pic, read(in_pic[i]); i++) {    
    int_pic_1 = trans1(in_pic); 
    int_pic_2 = trans2(int_pic_1); 
    int_pic_3 = trans3(int_pic_2); 
    out_pic = trans4(int_pic_3);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Anti-dependence between stages -&amp;gt; no parallelism

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Privatization&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buffer&lt;/strong&gt; between stages; block when buffers are full/empty&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;TSP (Task Queue)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;init_q(); init_best();
while ((p = de_queue()) != NULL) {
    for each expansion by one city { 
        q = add_city(p);
        if (complete(q)) { update_best(q) } 
        else { en_queue(q) }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Balance between &lt;strong&gt;granularity for load balance&lt;/strong&gt; and &lt;strong&gt;overhead for synchronization&lt;/strong&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each process one expansion&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each process do expansion of one partial path&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;en_queue()/de_queue() {
    pthreads_mutex_lock(&amp;amp;queue);
    ...;
    pthreads_mutex_unlock(&amp;amp;queue);
}
update_best() {
    pthreads_mutex_lock(&amp;amp;best);
    ...;
    pthreads_mutex_unlock(&amp;amp;best);
}
de_queue() {
    while ((q is empty) and (not done)) {
        waiting++;
        if (waiting == p) {
            done = true;
            pthreads_cond_broadcast(&amp;amp;empty, &amp;amp;queue);
        }
        else {
            pthreads_cond_wait(&amp;amp;empty, &amp;amp;queue);
            waiting--; 
        }
    }
    if (done) return null; 
    else remove and return head of the queue; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each process do expansion of multiple partial path&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Busy Waiting&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;initially: flag = 0;
P1: produce data; flag = 1;
P2: while (!flag); consume data;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Used when &lt;strong&gt;few threads competing for core&lt;/strong&gt; or &lt;strong&gt;short critical sections&lt;/strong&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/threads-and-parallel-programming.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/threads-and-parallel-programming.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming III</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Big Picture of Architecture &amp;amp; Memory Access

&lt;ol&gt;
&lt;li&gt;Virtual Memory

&lt;ul&gt;
&lt;li&gt;Memory Access&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Multithreading Basics

&lt;ul&gt;
&lt;li&gt;Parallelism within Processor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Connection between Memory Access, Memory Allocation and Cache Efficiency&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Cache Coherence

&lt;ol&gt;
&lt;li&gt;Cache Coherence Overview&lt;/li&gt;
&lt;li&gt;CC Protocols&lt;/li&gt;
&lt;li&gt;Locality in Parallel Programming&lt;/li&gt;
&lt;li&gt;True &amp;amp; False Sharing&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Big Picture of Architecture &amp;amp; Memory Access&lt;/h2&gt;

&lt;h3&gt;Virtual Memory&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Protection&lt;/strong&gt;: each process has its own private memory space&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sharing&lt;/strong&gt;: processes can share physical memory frames&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hide fragmentation&lt;/strong&gt;: can run if not enough total/contiguous memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Memory Access&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://wdxtub.com/images/14583140218329.jpg&quot; alt=&quot;memory access&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Processor sends VA to MMU&lt;/li&gt;
&lt;li&gt;MMU fetches PTE from PT in memory&lt;/li&gt;
&lt;li&gt;PTE absent, MMU triggers &lt;em&gt;page fault exception&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Handler identifies victim page (if dirty, page it out to disk)&lt;/li&gt;
&lt;li&gt;Handler pages in new page; update PTE&lt;/li&gt;
&lt;li&gt;Handler returns to original process; restart faulting instruction&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Multithreading Basics&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.adobe.com/content/docs/en/aem/6-0/manage/capacity-guide/capacity-guide/_jcr_content/par/image_7.img.png/1346079308000.png&quot; alt=&quot;thread x throughput&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;linear increase -&amp;gt; increase slowdown -&amp;gt; degrade&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Parallelism within Processor&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Example
&lt;code&gt;x = x * (data[i] * data[i+1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Limitations

&lt;ul&gt;
&lt;li&gt;# of functional units&lt;/li&gt;
&lt;li&gt;Latency of operation causing dependency&lt;/li&gt;
&lt;li&gt;# of registers to hold temporaries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Connection between Memory Access, Memory Allocation and Cache Efficiency&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Dynamic memory allocation

&lt;ul&gt;
&lt;li&gt;Space utilization&lt;/li&gt;
&lt;li&gt;Time complexity on malloc/free&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory-wall&lt;/strong&gt;: growing desparity of CPU &amp;amp; RAM speeds&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;Caching effectiveness important&lt;/li&gt;
&lt;li&gt;Padding not cache-friendly: avoid internal fragmentation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;False sharing&lt;/strong&gt;: occurs when &amp;gt;= 2 processors access different data in &lt;em&gt;same cache line&lt;/em&gt;, and at least one of them writes

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory arenas&lt;/strong&gt;: 1 thread only use memory from a single arena (continuous blocks of memory)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Cache Coherence&lt;/h2&gt;

&lt;h3&gt;Cache Coherence Overview&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shared memory machines

&lt;ul&gt;
&lt;li&gt;Small # of processors: shared memory with coherent caches (SMP)&lt;/li&gt;
&lt;li&gt;Large # of processors: distributed shared memory with coherent caches (CC-NUMA)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Caches in multiprocessors

&lt;ul&gt;
&lt;li&gt;Same line appears in &amp;gt;= 2 caches, one write, others read&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;CC Protocols&lt;/h3&gt;

&lt;h4&gt;MSI Protocol&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Input/Action
                PrWr/BuRdX
    ⬈-----------------------------------⬊
      PrRd/BuRd     PrRd/-  PrWr/BuRdX
I ------------------&amp;gt; S ------------------&amp;gt; M
  &amp;lt;------------------   &amp;lt;------------------
      BuRdX/-       BuRd/-  BuRd/Flush
    ⬉-----------------------------------⬋
                BuRdX/Flush
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Assumption: bus based architecture

&lt;ul&gt;
&lt;li&gt;Bus is reliable, ordered broadcast bus (snooping bus)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;States of a cache line

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invalid&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared&lt;/strong&gt;: one of many cached copies&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modified&lt;/strong&gt;: sole valid copy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Processor events

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PrRd&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PrWr&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bus Transactions

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BusRd&lt;/strong&gt;: simply asks for copy&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BusRdX&lt;/strong&gt;: asks for copy to modify&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flush&lt;/strong&gt;: updates memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Actions

&lt;ul&gt;
&lt;li&gt;Update state, perform bus transaction, flush value onto bus&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;Reading &amp;amp; modifying data is 2 bus xactions (BusRd(I-&amp;gt;S) + BusRdX)&lt;/li&gt;
&lt;li&gt;A write to &lt;em&gt;shared&lt;/em&gt;_ will generate invalidation request&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;MESI Protocol&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;One more state

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Exclusive/Exclusive-clean&lt;/strong&gt;: only this cache has copy but not modified&lt;/li&gt;
&lt;li&gt;A write to &lt;em&gt;exclusive&lt;/em&gt;_ will not generate invalidation request&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Typically built on write-back caches&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Locality in Parallel Programming&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Cache-aware access

&lt;ul&gt;
&lt;li&gt;Cache invalidation traffic important&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Awareness of data placement in memory

&lt;ul&gt;
&lt;li&gt;Important for CC-NUMA because long memory latencies for non-local memory access&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Awareness of data assignment to threads when load balancing&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    a[i] = i;
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++)
    b[i] = f(a[i-1], a[i]);

-&amp;gt; better locality
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) 
    a[i] = i;
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++)
    b[i] = f(a[i-1], a[i]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;True &amp;amp; False Sharing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;True sharing&lt;/strong&gt;: 2 threads accessing &lt;strong&gt;same&lt;/strong&gt; locations on one block&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;False sharing&lt;/strong&gt;: 2 threads accessing &lt;strong&gt;distinct&lt;/strong&gt; locations on one block&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Block will ping-pong

&lt;ul&gt;
&lt;li&gt;Ensure they map to separate cache blocks e.g. insert padding&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Example&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# processor = 2, cache line fit 8 elements
#pragma omp parallel for schedule(cyclic) 
for (i = 0; i &amp;lt; n; i++)
    a[i] = b[i];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-iii.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-iii.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming II</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Locking Parallelization Options&lt;/li&gt;
&lt;li&gt;Basic Parallel Improvements

&lt;ol&gt;
&lt;li&gt;OpenMP &amp;amp; Code Restructuring Optimizations&lt;/li&gt;
&lt;li&gt;Characteristics of Parallel Code&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Locking Parallelization Options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Course-grained locking: easy to program; limited parallelism&lt;/li&gt;
&lt;li&gt;Fine-grained locking: hard to program; good parallelism

&lt;ul&gt;
&lt;li&gt;Deadlock, fault tolerance, priority inversion, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Transactional memory: easy to program, promise good parallelism

&lt;ul&gt;
&lt;li&gt;Checkpoints execution -&amp;gt; detects conflicts -&amp;gt; commits/aborts and reexecutes&lt;/li&gt;
&lt;li&gt;Machine limits: abort if transaction too long and has to evict L1 cahce&lt;/li&gt;
&lt;li&gt;Overhead&lt;/li&gt;
&lt;li&gt;Bookkeeping&lt;/li&gt;
&lt;li&gt;Failure recovery&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Basic Parallel Improvements&lt;/h2&gt;

&lt;h3&gt;OpenMP &amp;amp; Code Restructuring Optimizations&lt;/h3&gt;

&lt;p&gt;Compiler &amp;amp; library implementation.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;annotated source -&amp;gt; OpenMP compiler -&amp;gt; sequential program
                                        (compiler switch)
                                    -&amp;gt; parallel program
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;OpenMP Directives&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Parallelization directives

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma omp parallel for&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;#pragma omp parallel for schedule &amp;lt;block/cyclic&amp;gt;&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Data environment directives

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shared&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;threadprivate&lt;/code&gt;, &lt;code&gt;reduction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Code Restructuring Optimizations&lt;/h4&gt;

&lt;p&gt;Eliminate/reduce dependences by restructuring the code.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Private variables&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#pragma omp parallel for private(tmp)
for (i = 0; i &amp;lt; n; i++) { 
    tmp = a[i];
    a[i] = b[i];
    b[i] = tmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Induction variable elimination&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0, index = 0; i &amp;lt; n; i++) { 
    index += i;
    a[i] = b[index];
}

-&amp;gt;
#pragma omp parallel for
for (i = 0, index = 0; i &amp;lt; n; i++) { 
    a[i] = b[i*(i+1)/2];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop splitting&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0, index = 0; i &amp;lt; n; i++) { 
    index += f(i);
    b[i] = g(a[index]);
}

-&amp;gt;
for (i = 0; i &amp;lt; n; i++) { 
    index[i] += f(i);
}
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) { 
    b[i] = g(a[index[i]]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;while (*a) { 
    process(a); 
    a++;
}

-&amp;gt;
for (count = 0, p = a; p != NULL; count++, p++);
#pragma omp parallel for
for (i = 0; i &amp;lt; count; i++) 
    process(a[i]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop reordering&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (k = 0; k &amp;lt; n; k++) 
    for (i = 0; i &amp;lt; n; i++)
        for (j = 0; j &amp;lt; n; j++)
            a[i][j] += b[i][k] + c[k][j];

-&amp;gt;
#pragma omp parallel for 
for (i = 0; i &amp;lt; n; i++)
    for (j = 0; j &amp;lt; n; j++)
        for (k = 0; k &amp;lt; n; k++)
            a[i][j] += b[i][k] + c[k][j];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop Fusion: reduce loop startup &amp;amp; thread overhead&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) 
    a[i] = b[i];
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) 
    c[i] = b[i]^2;

-&amp;gt;
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) {
    a[i] = b[i];
    c[i] = b[i]^2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop peeling&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0, wrap = n; i &amp;lt; n; i++) { 
    b[i] = a[i] + a[wrap]; 
    wrap = i;
}

-&amp;gt;
b[0] = a[0] + a[n];
#pragma omp parallel for 
for (i = 1; i &amp;lt; n; i++) {
    b[i] = a[i] + a[i-1]; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    a[i+m] = a[i] + b[i];

-&amp;gt;
if (m &amp;gt; n) {
    #pragma omp parallel for 
    for (i = 0; i &amp;lt; n; i++)
        a[i+m] = a[i] + b[i]; 
} else {
    ... cannot be parallelized
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Characteristics of Parallel Code&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Granularity&lt;/li&gt;
&lt;li&gt;Load balance&lt;/li&gt;
&lt;li&gt;Locality&lt;/li&gt;
&lt;li&gt;Communication &amp;amp; synchronization&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Granularity&lt;/h4&gt;

&lt;p&gt;Size of program unit executed by a single processor.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fine granularity

&lt;ul&gt;
&lt;li&gt;Ability to use many processors&lt;/li&gt;
&lt;li&gt;Finer-grain load balancing&lt;/li&gt;
&lt;li&gt;Increased overhead&lt;/li&gt;
&lt;li&gt;More critical section accesses &amp;amp; contention&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Load balance&lt;/h4&gt;

&lt;p&gt;Different in execution time between processors between barriers.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Execution time predictable?

&lt;ul&gt;
&lt;li&gt;Regular data parallel: yes&lt;/li&gt;
&lt;li&gt;Irregular data paralle or pipeline: perhaps&lt;/li&gt;
&lt;li&gt;Task queue: no&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static load balancing&lt;/strong&gt;: done once by programmer

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block&lt;/strong&gt;: good locality, poor load balance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cyclic&lt;/strong&gt;: good load balance, poor locality&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block-cyclic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Fine for regular data parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic load balancing&lt;/strong&gt;: done at runtime; task queue

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Centralized&lt;/strong&gt;: easy to program, good load balance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed&lt;/strong&gt;: less communication/synchronization&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task stealing&lt;/strong&gt;: extra overhead, difficult to program, better load balance&lt;/li&gt;
&lt;li&gt;Unpredictable execution times&lt;/li&gt;
&lt;li&gt;Regular data parallel in heterogeneous/multitasked environment&lt;/li&gt;
&lt;li&gt;Usually high overhead&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semi-static load balancing&lt;/strong&gt;: done once at runtime

&lt;ul&gt;
&lt;li&gt;Partition computation using measurements of cost of program parts&lt;/li&gt;
&lt;li&gt;Done once, done every iteration, done every n iterations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-ii.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-ii.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Locks &amp; Cache Coherence</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Locks &amp;amp; Cache Coherence

&lt;ol&gt;
&lt;li&gt;Atomic Operations&lt;/li&gt;
&lt;li&gt;Ticket Lock&lt;/li&gt;
&lt;li&gt;Array-Based Queueing Locks&lt;/li&gt;
&lt;li&gt;List-Based Queueing Locks (MCS Locks)&lt;/li&gt;
&lt;li&gt;Summary&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Case Studies&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Locks &amp;amp; Cache Coherence&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Criteria for evaluating spin locks

&lt;ul&gt;
&lt;li&gt;Scalability &amp;amp; induced network load&lt;/li&gt;
&lt;li&gt;Single-processor latency&lt;/li&gt;
&lt;li&gt;Space requirements&lt;/li&gt;
&lt;li&gt;Fairness&lt;/li&gt;
&lt;li&gt;Implementability with available atomic operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Atomic Operations&lt;/h3&gt;

&lt;p&gt;H/W support is required to implement synchronization primitives.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Test &amp;amp; set&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Steps

&lt;ol&gt;
&lt;li&gt;Load old value to register&lt;/li&gt;
&lt;li&gt;Set value in memory to 1&lt;/li&gt;
&lt;li&gt;Return old value&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lock implementation (TAS)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;struct lock { 
    int held = 0;
}
void acquire (lock) {
    while (test-and-set(&amp;amp;lock-&amp;gt;held)); 
}
void release (lock) { 
    lock-&amp;gt;held = 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Contentions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 threads contending to acquire lock &amp;amp; modify lock to 1&lt;/li&gt;
&lt;li&gt;Caused by spinning on &lt;em&gt;global&lt;/em&gt; variables&lt;/li&gt;
&lt;li&gt;Poor scalability&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Improved lock implementation (TATAS)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;void test_and_test_and_set (lock) { 
    do {
        while (lock-&amp;gt;held == 1) // only read
            ; // spin 
        }
    } while (test_and_set(lock-&amp;gt;held));
}
void release (lock) {
    lock-&amp;gt;held = 0; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Further improved lock implementation (TAS with backoff)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;while test&amp;amp;set (L) fails { 
    pause (delay);
    delay = delay * 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swap&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fetch &amp;amp; Op&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compare &amp;amp; swap&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Ticket Lock&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;my_ticket = fetch_and_increment(next_ticket); 
while (my_ticket != now_serving)
    pause(); //back-off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Improvements

&lt;ul&gt;
&lt;li&gt;Only 1 process try to get lock upon release&lt;/li&gt;
&lt;li&gt;Only 1 process have read miss upon release (not achieved)&lt;/li&gt;
&lt;li&gt;Locked acquired in FIFO (fairness)&lt;/li&gt;
&lt;li&gt;Further improvement: proportional backoff&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;2 counters: &lt;code&gt;next_ticket&lt;/code&gt;, &lt;code&gt;now_serving&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lock acquire: &lt;code&gt;fetch-and-increment&lt;/code&gt; on &lt;code&gt;next_ticket&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lock release: increment on &lt;code&gt;now_serving&lt;/code&gt; -&amp;gt; cuases contention&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Array-Based Queueing Locks&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;Queue &lt;code&gt;slots[N]&lt;/code&gt;, each element lies in different cache line

&lt;ul&gt;
&lt;li&gt;Has-lock (HL)&lt;/li&gt;
&lt;li&gt;Must-wait (MW)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next_slot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Steps

&lt;ol&gt;
&lt;li&gt;Incoming processes enqueued (&lt;code&gt;my_place = fetch-and-inc(next_slot)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Lock-acquire: &lt;code&gt;while(slots[my_place] == MW);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lock-release: &lt;code&gt;slots[(my_place+1)%N] = HL;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;Atomic ops &lt;code&gt;fetch-and-inc&lt;/code&gt; to obtain location to spin on&lt;/li&gt;
&lt;li&gt;Each CPU spins on different location in a distinct cache line&lt;/li&gt;
&lt;li&gt;Each CPU clears the lock for its successor (must-wait -&amp;gt; has-lock)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Space complexity &lt;code&gt;O(N)&lt;/code&gt;(bounded by # of processors)&lt;/li&gt;
&lt;li&gt;Queue is static&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;List-Based Queueing Locks (MCS Locks)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Steps&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Incoming processes enqueued (&lt;code&gt;predecessor = fetch-and-store(L,me)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Lock-acquire: wait for predecessor to signal&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lock-release: remove &lt;code&gt;me&lt;/code&gt; from &lt;code&gt;L&lt;/code&gt; &amp;amp; signal successor&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If no successor, spin on myself using &lt;code&gt;compare-and-swap(L,me,nil)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;L -&amp;gt; me
     new

# compare-and-swap fails
L    me
  ⬊  
     new

# spin on while I-&amp;gt;next = nil
L    me
  ⬊   ↓
     new
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Properties&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lock points at tail of queue&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compare-and-swap&lt;/strong&gt; for detection if it is the only processor in queue &amp;amp; atomic removal of self from queue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pros&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Spins on local flag variables only&lt;/li&gt;
&lt;li&gt;Requires a small constant amount of space per lock (bounded by # of requests)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Summary&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TAS&lt;/strong&gt; with proper backoffs

&lt;ul&gt;
&lt;li&gt;Scale well&lt;/li&gt;
&lt;li&gt;More network load&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ticket lock&lt;/strong&gt; with proper backoffs 

&lt;ul&gt;
&lt;li&gt;Scale well&lt;/li&gt;
&lt;li&gt;More network load&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Array-based locks&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Scales best&lt;/li&gt;
&lt;li&gt;Least interconnect contention&lt;/li&gt;
&lt;li&gt;High space requirement for large numbers of CPUs&lt;/li&gt;
&lt;li&gt;Fair&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MCS&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Scales best&lt;/li&gt;
&lt;li&gt;Least interconnect contention&lt;/li&gt;
&lt;li&gt;Low space requirement&lt;/li&gt;
&lt;li&gt;Fair&lt;/li&gt;
&lt;li&gt;Benefits from &lt;strong&gt;compare-and-swap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Case Studies&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;48-core AMD Opteron

&lt;ul&gt;
&lt;li&gt;6 cores per die, total 8 dies&lt;/li&gt;
&lt;li&gt;LLC not shared&lt;/li&gt;
&lt;li&gt;Directory-based cache coherence&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;80-core Intel Xeon

&lt;ul&gt;
&lt;li&gt;10 cores per die, total 8 dies&lt;/li&gt;
&lt;li&gt;LLC shared&lt;/li&gt;
&lt;li&gt;Snooping-based cache coherence&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Cross-sockets communication can be 2-hops

&lt;ul&gt;
&lt;li&gt;Cross-socket communication expensive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Latency of remote access

&lt;ul&gt;
&lt;li&gt;Read

&lt;ul&gt;
&lt;li&gt;Opteron

&lt;ul&gt;
&lt;li&gt;Uniform latency regardless of cache state (directory-based cache coherence)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Xeon

&lt;ul&gt;
&lt;li&gt;Shared state faster (served from LLC)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Write

&lt;ul&gt;
&lt;li&gt;Opteron

&lt;ul&gt;
&lt;li&gt;Store to shared expensive (wait for all invalidations to complete)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Xeon

&lt;ul&gt;
&lt;li&gt;Uniform latency regardless of cache state (snooping-based cache coherence)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Implications

&lt;ul&gt;
&lt;li&gt;Cache coherence is expensive

&lt;ul&gt;
&lt;li&gt;Avoid unnecessary sharing &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Crossing sockets is expensive

&lt;ul&gt;
&lt;li&gt;Can be clower than running on single core&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread&lt;/code&gt; CPU affinity mask: pin cooperative threads on cores within same die&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Loads &amp;amp; stores can be as expensive as atomic operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://people.eecs.berkeley.edu/%7Epattrsn/252F96/Lecture18.pdf&quot;&gt;Snooping vs. Directory Based Coherency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/%7Edbfaria/quals/summaries/Culler-chap8.txt&quot;&gt;Directory-Based Cache Coherence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=xjRDejGF26M&quot;&gt;Video: Directory Based Coherence - Georgia Tech&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/locks-and-cache-coherence.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/locks-and-cache-coherence.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>NP-Complete Problems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Search Problems

&lt;ol&gt;
&lt;li&gt;Satisfiability Problem (SAT)&lt;/li&gt;
&lt;li&gt;Traveling Salesman Problem (TSP)&lt;/li&gt;
&lt;li&gt;Integer Linear Programming (ILP)

&lt;ul&gt;
&lt;li&gt;Zero-One Equations (ZOE)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Three-Dimensional Matching (3D Matching)&lt;/li&gt;
&lt;li&gt;Independent Set&lt;/li&gt;
&lt;li&gt;Clique&lt;/li&gt;
&lt;li&gt;Knapsack Problem&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;NP-Complete Problems&lt;/li&gt;
&lt;li&gt;Reductions

&lt;ol&gt;
&lt;li&gt;Generalization/Special Case&lt;/li&gt;
&lt;li&gt;Rudrata Path -&amp;gt; Rudrata Cycle&lt;/li&gt;
&lt;li&gt;3SAT -&amp;gt; Independent Set&lt;/li&gt;
&lt;li&gt;SAT -&amp;gt; 3SAT&lt;/li&gt;
&lt;li&gt;Independent Set -&amp;gt; Vertex Cover&lt;/li&gt;
&lt;li&gt;Independent Set -&amp;gt; Clique&lt;/li&gt;
&lt;li&gt;3SAT -&amp;gt; 3D Matching&lt;/li&gt;
&lt;li&gt;3D Matching -&amp;gt; ZOE&lt;/li&gt;
&lt;li&gt;ZOE -&amp;gt; Subset Sum&lt;/li&gt;
&lt;li&gt;ZOE -&amp;gt; Rudrata Cycle&lt;/li&gt;
&lt;li&gt;Rudrata Cycle -&amp;gt; TSP&lt;/li&gt;
&lt;li&gt;Any Problem in NP -&amp;gt; SAT&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Search Problems&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Instance I&lt;/strong&gt;: input data specifying the problem&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solution S&lt;/strong&gt;: object meeting particular specification&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Algorithm C&lt;/strong&gt; s.t. &lt;code&gt;C(I,S) = true&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;S&lt;/code&gt; is a solution to &lt;code&gt;I&lt;/code&gt;; &lt;em&gt;quick checking&lt;/em&gt; &amp;lt;=&amp;gt; &lt;code&gt;C&lt;/code&gt; runs in polynomial-time in &lt;code&gt;|I|&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Can be reduced to/from &lt;strong&gt;optimization problems&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Satisfiability Problem (SAT)&lt;/h4&gt;

&lt;p&gt;Boolean formula in conjunctive normal form (CNF), find a set of assignments s.t. every clause contains a literal that is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;Traveling Salesman Problem (TSP)&lt;/h4&gt;

&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; vertices and all connected with a cost &lt;code&gt;c&lt;/code&gt;, find a permutation of vertices s.t. the total cost is at most the budget &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Search problem is polynomial-time checkable:

&lt;ul&gt;
&lt;li&gt;Each vertex is visited exactly once&lt;/li&gt;
&lt;li&gt;Total cost &amp;lt;= &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CANNOT check optimality

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Binary search&lt;/strong&gt; to find optimum cost&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Integer Linear Programming (ILP)&lt;/h4&gt;

&lt;p&gt;Given a set of linear inequalities &lt;code&gt;Ax ≤ b&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;m × n&lt;/code&gt; matrix and &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;m-vector&lt;/code&gt;; an objective function specified by an &lt;code&gt;n-vector&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;; and finally, a goal &lt;code&gt;g&lt;/code&gt;. Find a nonnegative integer &lt;code&gt;n-vector&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;Ax ≤ b&lt;/code&gt; and &lt;code&gt;cx ≥ g&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;Zero-One Equations (ZOE)&lt;/h5&gt;

&lt;p&gt;Find a vector &lt;code&gt;x&lt;/code&gt; of 0&amp;#39;s and 1&amp;#39;s satisfying &lt;code&gt;Ax = 1&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;m × n&lt;/code&gt; matrix with 0−1 entries and &lt;code&gt;1&lt;/code&gt; is the &lt;code&gt;m-vector&lt;/code&gt; of all 1&amp;#39;s.&lt;/p&gt;

&lt;h4&gt;Three-Dimensional Matching (3D Matching)&lt;/h4&gt;

&lt;p&gt;Find a matching (&lt;code&gt;n&lt;/code&gt; disjoint edges) between 3 sets of &lt;code&gt;n&lt;/code&gt; nodes.&lt;/p&gt;

&lt;h4&gt;Independent Set&lt;/h4&gt;

&lt;p&gt;Given a graph and an integer &lt;code&gt;g&lt;/code&gt;, find &lt;code&gt;g&lt;/code&gt; vertices that are independent, i.e. no edges between them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dual: &lt;strong&gt;vertex cover&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Special case of &lt;strong&gt;set cover&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Clique&lt;/h4&gt;

&lt;p&gt;Given a graph and a goal &lt;code&gt;g&lt;/code&gt;, find a set of &lt;code&gt;g&lt;/code&gt; vertices such that the induced subgraph is complete.&lt;/p&gt;

&lt;h4&gt;Knapsack Problem&lt;/h4&gt;

&lt;p&gt;Given integer weights &lt;code&gt;w1,...,wn&lt;/code&gt; and integer values &lt;code&gt;v1, ..., vn&lt;/code&gt; for &lt;code&gt;n&lt;/code&gt; items. Find a set of items with total weight &amp;lt;= &lt;code&gt;W&lt;/code&gt; and total value &amp;gt;= &lt;code&gt;g&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Unary knapsack&lt;/strong&gt;: encode integers in unary&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subset sum&lt;/strong&gt;: item&amp;#39;s value equals its weight

&lt;ul&gt;
&lt;li&gt;Find a subset of items that adds up to exactly &lt;code&gt;W&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;NP-Complete Problems&lt;/h2&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: center&quot;&gt;Hard problems (NP-complete)&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Easy problems (in P)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;3SAT&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;2SAT, HORN SAT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;TRAVELING SALESMAN PROBLEM&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;MINIMUM SPANNING TREE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;LONGEST PATH&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SHORTEST PATH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;3D MATCHING&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;BIPARTITE MATCHING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;KNAPSACK&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UNARY KNAPSACK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;INDEPENDENT SET&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;INDEPENDENT SET on trees&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;INTEGER LINEAR PROGRAMMING&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;LINEAR PROGRAMMING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;RUDRATA PATH&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;EULER PATH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;BALANCED CUT&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;MINIMUM CUT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;NP-complete problems can be reduced to/from any of the others.&lt;/p&gt;

&lt;h4&gt;P, NP, NP-Complete&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NP&lt;/strong&gt;: class of search problems s.t. any proposed solution can be quickly checked for correctness&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;: class of search problems that can be solved in polynomial time, and correctly reports no solution if so&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;: search problem where all other search problems reduce to it&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|--------NP-------|
|P|...|NP-complete|
      |-------NP Hard-------|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Reductions&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# f, h are polynomial transformation algorithms

    |----------------Algorithm for A-----------------|
I ---&amp;gt; f --f(I)--&amp;gt; Algorithm for B --S of f(I)--&amp;gt; h --&amp;gt; h(S) of I
                                   -------------------&amp;gt; No solution to I
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Reduction from A to B:
    A --&amp;gt; B
If we know A is hard, then B is hard as well. All problems in NP reduce to B via A.

If A --&amp;gt; B and B --&amp;gt; C, then A --&amp;gt; C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;                                All NP
                                   |
                                  SAT
                                   |
                                  3SAT
                                  ⬋  ⬊
                    Independent Set  3D Matching
                        ⬋  ⬊            |
            Vertex Cover    Clique     ZOE
                                     ⬋  |  ⬊
                            Subset Sum ILP Rudrata Cycle
                                                |
                                               TSP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Generalization/Special Case&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Circuit SAT&lt;/strong&gt; is a generalization of &lt;strong&gt;SAT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SAT&lt;/strong&gt; is a generalization of &lt;strong&gt;3SAT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set cover&lt;/strong&gt; is a generalization of &lt;strong&gt;vertex cover&lt;/strong&gt; and &lt;strong&gt;3D matching&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ILP&lt;/strong&gt; is a generatlization of &lt;strong&gt;ZOE&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Rudrata Path -&amp;gt; Rudrata Cycle&lt;/h4&gt;

&lt;p&gt;Given a graph, is there a path starting at s and ending at t that goes through each vertex exactly once?&lt;br&gt;
-&amp;gt; Is there a cycle that passes through each vertex exactly once?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reduce &lt;code&gt;G&lt;/code&gt; in rudrata path to &lt;code&gt;G&amp;#39;&lt;/code&gt; in rudrata cycle:

&lt;ul&gt;
&lt;li&gt;Add vertex &lt;code&gt;x&lt;/code&gt; and edges &lt;code&gt;(s,x)&lt;/code&gt;, &lt;code&gt;(x,t)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3SAT -&amp;gt; Independent Set&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt; Graph &lt;code&gt;G&lt;/code&gt; has a triangle for each clause (or an edge if clause of two literals), with vertices labeled by the clause&amp;#39;s literals&lt;/li&gt;
&lt;li&gt;Add edges between any two vertices that represent opposite literals&lt;/li&gt;
&lt;li&gt;Goal &lt;code&gt;g&lt;/code&gt; is the number of clauses&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;SAT -&amp;gt; 3SAT&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt; Any clause with &amp;gt; 3 literals in instance &lt;code&gt;I&lt;/code&gt; of SAT, transform:&lt;br&gt;
&lt;code&gt;(a1 ∨ a2 ∨ ... ∨ ak)  -&amp;gt; (a1 ∨ a2 ∨ y1)(~y1 ∨ a3 ∨ y2)...(~yk−3 ∨ ak−1 ∨ ak)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Further restriction: no variable appears in &lt;code&gt;k&lt;/code&gt; &amp;gt; 3 clauses

&lt;ul&gt;
&lt;li&gt;Replace variable &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x1, x2, ..., xk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add clauses &lt;code&gt;(~x1 ∨ x2)(~x2 ∨ x3)...(~xk ∨ x1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Independent Set -&amp;gt; Vertex Cover&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Independent set &lt;code&gt;S&lt;/code&gt;, vertex cover &lt;code&gt;V - S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Independent Set -&amp;gt; Clique&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Map instance &lt;code&gt;(G, g)&lt;/code&gt; of independent set to complement graph &lt;code&gt;(~G, g)&lt;/code&gt; of clique&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3SAT -&amp;gt; 3D Matching&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cs.cmu.edu/%7Eckingsf/bioinfo-lectures/3dm.pdf&quot;&gt;CMU Notes&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;3D Matching -&amp;gt; ZOE&lt;/h4&gt;

&lt;p&gt;Given an &lt;code&gt;m × n&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; with 0−1 entries, and we must find a 0−1
vector &lt;code&gt;x = (x1, ..., xn)&lt;/code&gt; such that the &lt;code&gt;m&lt;/code&gt; equations &lt;code&gt;Ax = 1&lt;/code&gt; are satisfied.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let columns of &lt;code&gt;A&lt;/code&gt; be triples in 3D matching&lt;/li&gt;
&lt;li&gt;Let rows of &lt;code&gt;A&lt;/code&gt; be all matching items&lt;/li&gt;
&lt;li&gt;Aij is 1 if the triple inclues the item&lt;/li&gt;
&lt;li&gt;Choose a set of triples &lt;code&gt;X&lt;/code&gt; to be 1 s.t. the resulting column is all 1 (i.e. all items chosen once)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;ZOE -&amp;gt; Subset Sum&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Let columns of &lt;code&gt;A&lt;/code&gt; be representations of (n+1)-ary integers&lt;/li&gt;
&lt;li&gt;Choose a set of integers s.t. sum is 11...1 (won&amp;#39;t be affected by &lt;em&gt;carry&lt;/em&gt; because base &lt;code&gt;n+1&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;ZOE -&amp;gt; ILP&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;Ax ≤ b&lt;/code&gt;, rewrite each equation as 2 inequalities&lt;/li&gt;
&lt;li&gt;Add for each variable &lt;code&gt;xi&lt;/code&gt; inequalities &lt;code&gt;xi ≤ 1&lt;/code&gt; and &lt;code&gt;−xi ≤ 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;ZOE -&amp;gt; Rudrata Cycle&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ZOE -&amp;gt; Rudrata cycle with paired edges&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each variable &lt;code&gt;xi&lt;/code&gt; =&amp;gt; two parallel edges (xi = 1 and 0)&lt;/li&gt;
&lt;li&gt;Each equation &lt;code&gt;xj1 + ... + xjk = 1&lt;/code&gt;involving &lt;code&gt;k&lt;/code&gt; variables =&amp;gt; &lt;code&gt;k&lt;/code&gt; parallel edges&lt;/li&gt;
&lt;li&gt;Every equation and every variable xi appearing in it, add to &lt;code&gt;C&lt;/code&gt; the pair &lt;code&gt;(e,e&amp;#39;)&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt; = the edge &lt;code&gt;xi&lt;/code&gt; in that equation, &lt;code&gt;e&amp;#39;&lt;/code&gt; = the edge xi = 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rudrata cycle with paired edges -&amp;gt; Rudrata cycle&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Replace every pair &lt;code&gt;(e,e&amp;#39;)&lt;/code&gt; as &lt;code&gt;({a,b},{c,t})&lt;/code&gt;with:
&lt;img src=&quot;http://i40.tinypic.com/1pfazb.png&quot; alt=&quot;gadget&quot;&gt;&lt;/li&gt;
&lt;li&gt;Every other pair involving &lt;code&gt;{a,b}&lt;/code&gt;, set it to be &lt;code&gt;{a,f}&lt;/code&gt; and repeat the replacement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Rudrata Cycle -&amp;gt; TSP&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt; = set of cities&lt;/li&gt;
&lt;li&gt;Distance between &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;{u,v}&lt;/code&gt; is an edge; otherwise &lt;code&gt;1 + α&lt;/code&gt; for some &lt;code&gt;α &amp;gt; 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Budget = &lt;code&gt;|V|&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;α = 1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;TSP satisfies triangle inequality &lt;code&gt;dij + djk ≥ dik&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can be approximated&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;α&lt;/code&gt; is large

&lt;ul&gt;
&lt;li&gt;Solution either has cost &lt;code&gt;n&lt;/code&gt; or less, or has cost at least &lt;code&gt;n + α&lt;/code&gt; (&lt;strong&gt;gap property&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Any Problem in NP -&amp;gt; SAT&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Circuit SAT&lt;/p&gt;

&lt;p&gt;Given a circuit, find a truth assignment for the unknown inputs s.t. the output gate evaluates to T, or report that no such assignment exists.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;- AND/OR gates: indegree 2
- NOT gates: indegree 1
- Known input gates: no incoming edges, labeled F/T
- Unknown input gates: no incoming edges, labeled '?'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;SAT -&amp;gt; Circuit SAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clause: OR of literals&lt;/li&gt;
&lt;li&gt;Joining clauses: AND of clauses&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Circuit SAT -&amp;gt; SAT&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;T: g
F: ~g
OR: (g v ~h1)(g v ~h2)(~g v h1 v h2)
AND: (~g v h1)(~g v h2)(g v ~h1 v ~h2)
NOT: (g v h)(~g v ~h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Any Problem in NP -&amp;gt; Circuit SAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Problem in NP is a search problem &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution checking is polynomial-time&lt;/li&gt;
&lt;li&gt;Polynomial algorithm can be rendered as a circuit&lt;/li&gt;
&lt;li&gt;Given instance &lt;code&gt;I&lt;/code&gt; and solution &lt;code&gt;S&lt;/code&gt; of problem &lt;code&gt;A&lt;/code&gt;, construct a polynomial-time circuit with known inputs the bits of &lt;code&gt;I&lt;/code&gt;, unknown inputs the bits of &lt;code&gt;S&lt;/code&gt; s.t. output is T&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.fas.harvard.edu/%7Elibcs124/CS/lec7.pdf&quot;&gt;Harvard Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard&quot;&gt;What are the differences between NP, NP-complete, and NP-hard?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mlnotes.com/2013/04/29/npc.html&quot;&gt;mlnotes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://staff.ustc.edu.cn/%7Ecsli/graduate/algorithms/book6/chap36.htm&quot;&gt;USTC Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/26/np-complete-problems.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/26/np-complete-problems.html</guid>
        
        <category>np-complete</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Linear Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Linear Programming &amp;amp; Reduction Overview&lt;/li&gt;
&lt;li&gt;Duality&lt;/li&gt;
&lt;li&gt;Simplex Algorithm&lt;/li&gt;
&lt;li&gt;Circuit Evaluation&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Linear Programming &amp;amp; Reduction Overview&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LP &amp;amp; Reductions ---&amp;gt; Flows &amp;amp; matching
                ---&amp;gt; Duality            ---&amp;gt; Games
                ---&amp;gt; Simplex
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Linear Programming&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Objective function

&lt;ul&gt;
&lt;li&gt;Line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maximization&lt;/strong&gt; or &lt;strong&gt;minimization&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Constraints

&lt;ul&gt;
&lt;li&gt;Feasible region&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Equations&lt;/strong&gt; or &lt;strong&gt;inequalities&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimum achieved at a &lt;strong&gt;vertex of feasible region&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Simplex method&lt;/strong&gt;: &lt;em&gt;hill-climbing&lt;/em&gt; on vertices

&lt;ul&gt;
&lt;li&gt;Local = global optimality for linear functions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Reduction&lt;/h4&gt;

&lt;p&gt;If any subroutine for task Q can also be used to solve P, we say &lt;strong&gt;P reduces to Q&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;x ---&amp;gt; Preprocess --y-&amp;gt; Algorithm for Q --Q(y)--&amp;gt; Postprocess ---&amp;gt; P(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Variants of Linear Programming&lt;/h4&gt;

&lt;p&gt;Reduction of variants into &lt;em&gt;standard form&lt;/em&gt;:  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maximization to minimization:

&lt;ul&gt;
&lt;li&gt;Coefficients * (-1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Inequality to equation:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sum_i_to_n(ai*xi) &amp;lt;= b&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;sum_i_to_n(ai*xi) + s = b &amp;amp;&amp;amp; s &amp;gt;= 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; = slack variable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Equation to inequality:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ax = b&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;ax &amp;lt;= b &amp;amp;&amp;amp; ax &amp;gt;= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Unsigned variables to signed:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;x+ - x-&lt;/code&gt; where &lt;code&gt;x+, x- &amp;gt;= 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;min cTx s.t. Ax = b and x ≥ 0&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Matrix-Vector Notation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Objective function:
    c^Tx
    c = [c1, c2, ...], x = [x1, x2, ...]
Constraints:
    Ax &amp;lt;= b
    A = [[c11, c12, ...], [c21, c22, ...], ...], b = [b1, b2, ...]
x &amp;gt;= 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Duality&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Primal LP:
max cTx 
Ax ≤ b 
x ≥ 0

# Dual LP:
min yTb 
yTA ≥ cT 
y ≥ 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Primal LP:
max c1x1 +···+cnxn 
ai1x1+···+ainxn ≤ bi for i ∈ I (inequalities)
ai1x1+···+ainxn = bi for i ∈ E (equalities)
xj ≥ 0 for j ∈ N

# Dual LP:
min b1y1 +···+bmym 
a1jy1+···+amjym ≥ cj for j ∈ N 
a1jy1+···+amjym = cj for j !∈ N 
yi ≥ 0 for i ∈ I # equalities can have unrestricted variables (signed)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Duality Theorm&lt;/h4&gt;

&lt;p&gt;If a linear program has a bounded optimum, then so does its dual, and the two optimum values coincide.&lt;/p&gt;

&lt;h4&gt;Duality in Shortest-Path Problem&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://math.stackexchange.com/questions/861079/shortest-path-problem-dual-formulation-and-proof-of-total-unimodularity&quot;&gt;StackExchange&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem#Linear_programming_formulation&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;max xs - xt
|xu - xv| &amp;lt;= w_uv for all edges {u,v}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Simplex Algorithm&lt;/h2&gt;

&lt;h4&gt;Visualization&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;let v be any vertex of the feasible region
while there is a neighbor v' of v with better objective value:
    set v = v'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;x1, ..., xn variables -&amp;gt; n-tuple in n-dimensional space
A linear equation     -&amp;gt; hyperplane in R^n
A linear inequality   -&amp;gt; half-space in R^n
Linear program        -&amp;gt; convex polyhedron in R^n; intersection of all half-spaces
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Vertex: 
    Pick a subset of the inequalities. A vertex is a unique point that satisfies them with equality, and this point happens to be feasible.

Each vertex is specified by a set of n inequalities. (n linear equations to uniquely identify a point)

Neighbor:
    Two vertices are neighbors if they have n-1 defining inequalities in common.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Algorithm&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;max cTx 
Ax ≤ b 
x ≥ 0

1. Set origin to be current vertex.
2. Check whether the current vertex is optimal, i.e. coordinates of local cost vector (c) all &amp;lt;= 0.
3. If so, halt. Else, determine where to move next by increasing some xi for which ci &amp;gt; 0 until we hit some other constraint.
4. Transform the next vertex into origin and repeat.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;Transformation into Origin&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;For inequality ai*x ≤ bi, to turn into yi ≥ 0:
    yi = bi - ai*x

Cost function:
    max cu + (c')^T y, cu = value of objective function at u, c' = transformed cost vector
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Issues&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;How to find the starting vertex?&lt;/p&gt;

&lt;p&gt;General LPs won&amp;#39;t always have inequalities with positive right-hand sides.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. Rewrite LP into standard form:
    min cTx s.t. Ax = b and x ≥ 0
2. Make sure right-hand sides of equations are nonnegative:
    if bi &amp;lt; 0, multiply both sides of the ith equation by -1
3. Create new LP:
    - Create m new artificial variables z1, ..., zm &amp;gt;= 0
    - Add zi to left-hand side of the ith equation
    - Objective function: minimize z1+...+zm
4. Starting vertex for new LP:
    zi = bi for all i, other variables 0
5. Run simplex on new LP

If zi+...+zm = 0:
    Optimum vertex of new LP = starting feasible vertex of original LP
Else:
    Original LP not feasible
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Degeneracy?&lt;/p&gt;

&lt;p&gt;An LP is &lt;strong&gt;degenerate&lt;/strong&gt; if in a basic feasible solution, one of the basic variables takes on a zero value.&lt;/p&gt;

&lt;p&gt;In geometry, this means there is an intersection of more than &lt;code&gt;n&lt;/code&gt; faces of the polyhedron.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Problem:

&lt;ul&gt;
&lt;li&gt;May return &lt;strong&gt;suboptimal&lt;/strong&gt; degenerate vertex, because all neighbors are identical and no better objective&lt;/li&gt;
&lt;li&gt;May &lt;strong&gt;loop forever&lt;/strong&gt;, bacause if modify simplex, continue to hop from vertex to vertex without improvement&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perturbation&lt;/strong&gt;: change each &lt;code&gt;bi&lt;/code&gt; by a tiny random amount to &lt;code&gt;bi += εi&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unboundedness?&lt;/p&gt;

&lt;p&gt;Objective function can be arbitrarily large/small.  &lt;/p&gt;

&lt;p&gt;Simplex will discover it: when exploring the neighborhood of a vertex, taking out an inequality and adding another leads to underdetermined system of equations that has infinite solutions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Running Time&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Generic LP:
    max cTx s.t. Ax ≤ 0 and x ≥ 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;A vertex is where &lt;code&gt;n&lt;/code&gt; inequality constraints are satisfied with equality&lt;/li&gt;
&lt;li&gt;Each of its neighbors shares &lt;code&gt;n-1&lt;/code&gt; inequalities =&amp;gt; &lt;code&gt;n * m&lt;/code&gt; neighbors&lt;/li&gt;
&lt;li&gt;Finding cost &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Checking whether is a true vertex - solving &lt;code&gt;n&lt;/code&gt; equations in &lt;code&gt;n&lt;/code&gt; unknowns:

&lt;ul&gt;
&lt;li&gt;Gaussian elimination &lt;code&gt;O(n^3)&lt;/code&gt; =&amp;gt; total &lt;code&gt;O(nb^4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;move to origin&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O((m+n)n)&lt;/code&gt; overhead to rewrite&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max cu + (c&amp;#39;)^T y&lt;/code&gt;, pick any &lt;code&gt;c&amp;#39;i &amp;gt; 0&lt;/code&gt; to move to&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(mn)&lt;/code&gt; in total&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C(m+n,n)&lt;/code&gt; vertices =&amp;gt; upper bound on # of iterations&lt;/li&gt;
&lt;li&gt;So &lt;strong&gt;simplex is exponential&lt;/strong&gt;; but in practice not exponential&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Gaussian Elimination&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Gauss(E,X):
    # Input: A system E = {e1,...,en} of equations in n unknowns X = {x1,...,xn}:
    e1: a11x1 + a12x2 +···+ a1nxn = b1; ···; en: an1x1 + an2x2 +···+ annxn = bn 
    # Output: A solution of the system, if one exists

    if all coefficients ai1 are zero:
        halt with message &quot;either infeasible or not linearly independent&quot;
    if n = 1: return b1/a11

    choose the coefficient ap1 of largest magnitude, and swap equations e1, ep 
    for i = 2 to n:
        ei = ei  − (ai1/a11) * e1
    (x2, . . . , xn) = Gauss(E − {e1}, X − {x1}) 
    x1 = (b1 − sum_j&amp;gt;1(a1j * xj))/a11

    return (x1,...,xn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Circuit Evaluation&lt;/h2&gt;

&lt;p&gt;The most general problem solvable in polynomial time.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|true| xg = 1
|false| xg = 0
|OR|  &amp;lt;- h   xg &amp;gt;= xh, xg &amp;gt;= xh'
      &amp;lt;- h'  xg &amp;lt;= xh + xh'
|AND| &amp;lt;- h   xg &amp;lt;= xh, xg &amp;lt;= xh'
      &amp;lt;- h'  xg &amp;gt;= xh + xh' - 1
|NOT| &amp;lt;- h   xg = 1 - xh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.utdallas.edu/%7Escniu/OPRE-6201/documents/LP4-Simplex.html&quot;&gt;The Simplex Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.yale.edu/homes/aspnes/pinewiki/LinearProgramming.html&quot;&gt;Yale LP Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pitt.edu/%7Ekaveh/Lin-programming-notes.pdf&quot;&gt;Pitt LP Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://courses.csail.mit.edu/6.854/06/scribe/s15.pdf&quot;&gt;MIT LP Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://home.ubalt.edu/ntsbarsh/opre640a/partIII.htm#rsppr&quot;&gt;UBalt Flow Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://neos-guide.org/content/diet-problem&quot;&gt;The Diet Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 24 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/24/linear-programming.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/24/linear-programming.html</guid>
        
        <category>linear programming</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Serverside Swift</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Basics

&lt;ol&gt;
&lt;li&gt;Terminologies&lt;/li&gt;
&lt;li&gt;Commands&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Docker Images

&lt;ol&gt;
&lt;li&gt;Image Types&lt;/li&gt;
&lt;li&gt;Create Images&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Docker Compose

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run Application&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Create Swift Package&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;swift package init&lt;/code&gt;&lt;br&gt;
&lt;code&gt;swift build&lt;/code&gt;&lt;br&gt;
&lt;code&gt;swift package generate-xcodeproj&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Package.swift&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;name: name of package
targets: binary files
dependencies: [
  .Package(url: &quot;url&quot;, majorVersion: version, minor: version)
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Swift Basics&lt;/h2&gt;

&lt;h5&gt;Strongly-Typed&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;var myVar = &amp;quot;string&amp;quot;&lt;/code&gt; or &lt;code&gt;var myVar: String&lt;/code&gt;&lt;br&gt;
&lt;code&gt;var myInt = Int(myVar)&lt;/code&gt; or &lt;code&gt;var myInt = (myVar as NSString).integerValue&lt;/code&gt;  &lt;/p&gt;

&lt;h5&gt;Constants &amp;amp; Variables&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;let const = value&lt;/code&gt; vs &lt;code&gt;var const = value&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;Class&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;myName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// unnamed parameter&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myStaticFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// named parameter&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myStaticFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Building Swift Applicstions&lt;/h2&gt;

&lt;h4&gt;Targets&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Library&lt;/li&gt;
&lt;li&gt;Executable (terminal-like icon)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Settings&lt;/h4&gt;

&lt;p&gt;Target &amp;gt; Edit Scheme &amp;gt; Run &amp;gt; Options &amp;gt; Use custom working directory: [project-directory]&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/swift/2016/11/24/serverside-swift.html</link>
        <guid isPermaLink="true">/blog/notes/swift/2016/11/24/serverside-swift.html</guid>
        
        <category>swift</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Swift</category>
        
      </item>
    
  </channel>
</rss>
