<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MyCoon</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 07 Nov 2016 16:07:03 -0500</pubDate>
    <lastBuildDate>Mon, 07 Nov 2016 16:07:03 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Dynamic Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Shortest Paths in DAGs&lt;/li&gt;
&lt;li&gt;Longest Increasing Subsequences&lt;/li&gt;
&lt;li&gt;Edit Distance&lt;/li&gt;
&lt;li&gt;Knapsack Problem&lt;/li&gt;
&lt;li&gt;Chain Matrix Multiplication&lt;/li&gt;
&lt;li&gt;Shortest Paths

&lt;ol&gt;
&lt;li&gt;Shortest Reliable Paths&lt;/li&gt;
&lt;li&gt;All-Pairs Shortest Paths&lt;/li&gt;
&lt;li&gt;The Traveling Salesman Problem&lt;/li&gt;
&lt;li&gt;Independent Sets in Trees&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;Comparison to &lt;em&gt;divide-and-conquer&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Divide-and-conquer&lt;/strong&gt;: subproblems &lt;em&gt;substantially smaller&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DP&lt;/strong&gt;: subproblems &lt;em&gt;slightly smaller&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;So &lt;strong&gt;recursion&lt;/strong&gt; works well with &lt;em&gt;DAC&lt;/em&gt; but not &lt;em&gt;DP&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Define a collection of subproblems which follows:

&lt;ul&gt;
&lt;li&gt;There is an &lt;strong&gt;ordering&lt;/strong&gt; on the subproblems, and a &lt;strong&gt;relation&lt;/strong&gt; that shows how to solve a subproblem given the answers to &amp;quot;smaller&amp;quot; subproblems, that is, subproblems that appear earlier in the ordering.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Relation with DAGs

&lt;ul&gt;
&lt;li&gt;Node: subproblem&lt;/li&gt;
&lt;li&gt;Incoming edges: subproblems needed to be pre-solved (precedence constraints)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Common subproblems&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1.  
    O(n)
    [x1, x2, ..., xi], ..., xn
2. 
    O(mn)
    [x1, x2, ..., xi], ..., xn
    [y1, y2, ..., yj], ..., ym
3. 
    O(n^2)
    x1, ..., [xi, ..., xj], ..., xn
4. 
                x1
               /  \
              x2  x3
             .       .
            .         .
           xi   ...   xn

    Subproblem - rooted subtree
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Shortest Paths in DAGs&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DAG&lt;/strong&gt;: directed acyclic graph&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nodes can be &lt;strong&gt;linearized&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    A -&amp;gt; B                  __________
  ➚        ➘               ➚           ➘
S   ↑    ↓   D      S -&amp;gt; C -&amp;gt; A -&amp;gt; B -&amp;gt; D -&amp;gt; E
  ➘        ➚         ➘_______➚      ➘_______➚
    C -&amp;gt; D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;initialize all dist(·) values to ∞ 
dist(s) = 0

for each v ∈ V\{s}, in linearized order:
    dist(v) = min_(u,v)∈E { dist(u) + l(u,v) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Longest Increasing Subsequences&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Given a sequence of numbers, find a subset taken in order in which the numbers are getting strictly larger.&lt;/p&gt;

&lt;h4&gt;Viewing LIS as DAG&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Node &lt;code&gt;i&lt;/code&gt;: element &lt;code&gt;i&lt;/code&gt; in the sequence&lt;/li&gt;
&lt;li&gt;Directed edge &lt;code&gt;(i,j)&lt;/code&gt;: if element &lt;code&gt;j&lt;/code&gt; &amp;gt; element &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;L(j) = length of LIS ending at j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;L(j) = 1 + max{L(i): (i,j) ∈ E}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for j = 1..n:
    L(j) = 1 + max{L(i): (i,j) ∈ E}
return max_j L(j)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(|E|) = O(n^2)&lt;/code&gt; &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Edit Distance&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;For 2 strings, the &lt;em&gt;cost&lt;/em&gt; of an alignment between them is the # of &lt;em&gt;edits&lt;/em&gt; (insertion, deletion, substitution) needed to transform string 1 to string 2. Find the &lt;em&gt;min&lt;/em&gt; cost.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Strings &lt;code&gt;x, y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;E(i,j) = edit distance between x[1..i] &amp;amp; y[1..j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;E(i,j) = min{ 1+E(i−1,j), 1+E(i,j−1), diff(i,j)+E(i−1,j−1) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for i = 0..m: 
    E(i,0) = i
for j = 1..n: 
    E(0,j) = j
for i = 1..m: 
    for j = 1..n:
        E(i,j) = min{ E(i − 1,j) + 1, E(i,j − 1) + 1, E(i − 1,j − 1)+diff(i,j) }
return E(m,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(mn)&lt;/code&gt; &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Knapsack Problem&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; items of weight &lt;code&gt;w1, ..., wn&lt;/code&gt; and value &lt;code&gt;v1, ..., vn&lt;/code&gt;, what is the most valuable combination of items that the total weight is at most &lt;code&gt;W&lt;/code&gt; pounds?&lt;/p&gt;

&lt;h4&gt;Allows Repetition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;K(w) = max value achievable with knapsack of capacity w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;K(w) = max_i:wi&amp;lt;=w { K(w−wi)+vi }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;K(0) = 0
for w = 1 to W:
    K(w) = max { K(w−wi)+vi: wi ≤w } 
return K(W)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;h4&gt;Memoization&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;A hash table, initially empty, holds values of K(w) indexed by w
function knapsack(w):
  if w is in hash table: 
      return K(w) 
  K(w) = max { knapsack(w−wi) + vi: wi≤w } 
  insert K(w) into hash table, with key w 
  return K(w)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only store information needed, unlike DP storing all&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;No Repetition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;K(w,j) = max value achievable with knapsack of capacity w and items 1..j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;K(w,j) = max { K(w−wj,j-1) + vj, K(w,j-1) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Initialize all K(0, j) = 0 and all K(w, 0) = 0 
for j = 1 to n:
    for w = 1 to W:
        if wj &amp;gt; w: 
            K(w,j) = K(w,j−1)
        else: 
            K(w,j) = max { K(w,j−1),K(w−wj,j−1) + vj }
return K(W,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Chain Matrix Multiplication&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Four matrices &lt;code&gt;A x B x C x D&lt;/code&gt;, find the way of chaining that uses the least computations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Abstraction&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Binary trees&lt;/strong&gt;: &lt;code&gt;node = product of children&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Ex.
        []
       /  \
      []   D
     /  \
    []   C
   /  \
  A    B    

(((A x B) x C) x D)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Subproblem:&lt;br&gt;
&lt;code&gt;C(i,j) = min cost of multiplying Ai..Aj&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;C(i,j) = min_i&amp;lt;=k&amp;lt;j { C(i,k) + C(k+1,j) + m_i-1 * mk * mj }&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;fori = 1 to n: 
    C(i,i) = 0 
for s=1 to n−1:
    for i=1 to n−s: 
        j = i + s
        C(i,j) = min { C(i,k) + C(k+1,j) + m_i−1 * mk * mj: i ≤ k &amp;lt; j } 
return C(1,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(n^3)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Shortest Paths&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;Shortest Reliable Paths&lt;/h4&gt;

&lt;p&gt;Find the shortest path in a graph from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; using at most &lt;code&gt;k&lt;/code&gt; edges.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;dist(v,i) = length of shortest path from s to v using i edges&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;dist(v,i) = min_(u,v)∈E { dist(u,i−1) + l(u,v) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Initial values:&lt;br&gt;
&lt;code&gt;dist(v, 0) = infinity, dist(s, 0) = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;All-Pairs Shortest Paths&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Floyd-Warshall algorithm&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;dist(i,j,k) = length of shortest path from i to j using only nodes {1..k}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;dist(i,j,k) = min { dist(i,k,k−1) + dist(k,j,k−1), dist(i,j,k−1) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for i = 1 to n: 
    for j = 1 to n:
        dist(i,j,0) = ∞
for all (i,j) ∈ E: 
    dist(i,j,0) = l(i,j)
for k = 1 to n: 
    for i = 1 to n:
        for j = 1 to n:
            dist(i,j,k) = min{ dist(i,k,k−1) + dist(k,j,k−1), dist(i,j,k−1) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;The Traveling Salesman Problem&lt;/h4&gt;

&lt;p&gt;Find a min cost path in a graph that starts and end at 1 and goes through all nodes exactly once.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;C(S,j) = length of shortest path visiting nodes in S exactly once, starting at 1 and ending at j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;C(S,j) = min_i∈S:i!=j { C(S-{j}, i) + dij }&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;C({1},1) = 0
for s = 2 to n:
    for all subsets S ⊆ {1..n} of size s and containing 1: 
        C(S,1) = ∞
        for all j ∈ S, j != 1: 
            C(S,j) = min { C(S−{j},i) + dij: i∈S,i!=j}
return min_j { C({1..n},j) + dj1 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(n^2*2^n)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2^n*n&lt;/code&gt; subproblems, each &lt;code&gt;O(n)&lt;/code&gt; time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Independent Sets in Trees&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Independent sets&lt;/em&gt;: for graph &lt;code&gt;G = (V,E)&lt;/code&gt;, a subset of nodes &lt;code&gt;S ⊂ V&lt;/code&gt; is an independent set if there are no edges between them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;I(u) = size of largest independent set of subtree hanging from u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblem:&lt;br&gt;
&lt;code&gt;u&lt;/code&gt; is either included in the largest independent set or not&lt;br&gt;
&lt;code&gt;I(u) = max { 1 + sum_grandchildren_w_of_u I(w), sum_children_w_of_u I(w) }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 02 Nov 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/algorithm/2016/11/02/dynamic-programming.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/02/dynamic-programming.html</guid>
        
        <category>DP</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Parallelism Overview

&lt;ol&gt;
&lt;li&gt;Standard Models of Parallelism&lt;/li&gt;
&lt;li&gt;Speedup&lt;/li&gt;
&lt;li&gt;Dependence&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Threads &amp;amp; Processes

&lt;ol&gt;
&lt;li&gt;Pthreads&lt;/li&gt;
&lt;li&gt;Synchronization&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Data Parallelism

&lt;ol&gt;
&lt;li&gt;Matrix Multiplication (Regular)&lt;/li&gt;
&lt;li&gt;SOR (Regular)&lt;/li&gt;
&lt;li&gt;Molecular Dynamics (Irregular)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Parallelism Overview&lt;/h2&gt;

&lt;h3&gt;Standard Models of Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shared memory (pthreads)&lt;/li&gt;
&lt;li&gt;Shared memory + data parallelism (OpenMP)&lt;/li&gt;
&lt;li&gt;Message passing (MPI)&lt;/li&gt;
&lt;li&gt;Transactional memory (TM)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Speedup&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;speedup on problem = sequential execution time of best known sequential algorithm / execution time on p processors&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Avoids picking easily parallelizable algorithm with poor sequential execution time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linear speedup is best to be achieved

&lt;ul&gt;
&lt;li&gt;Sub-linear speedup: due to overhead of &lt;em&gt;startup&lt;/em&gt;, &lt;em&gt;synchronization&lt;/em&gt;, &lt;em&gt;communication&lt;/em&gt;, ...&lt;/li&gt;
&lt;li&gt;Super-linear speedup

&lt;ul&gt;
&lt;li&gt;Cache/memory effects&lt;/li&gt;
&lt;li&gt;Nondeterminism in search problems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amdahl&amp;#39;s Law&lt;/strong&gt;: if &lt;code&gt;1/s&lt;/code&gt; of program is sequential, speedup will not be better than &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dependence&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;True dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; reads a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value read by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Output dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop carried dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Statements are part of the execution of a loop&lt;/li&gt;
&lt;li&gt;e.g. &lt;code&gt;a[i] = f(a[i-1]) + 1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Prevents loop iteration parallelization&lt;/li&gt;
&lt;li&gt;Level of loop carried dependence: nesting depth of loop that carries dependence&lt;/li&gt;
&lt;li&gt;&amp;lt;-&amp;gt; &lt;strong&gt;Loop independent dependence&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Threads &amp;amp; Processes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Similarities

&lt;ul&gt;
&lt;li&gt;Own logical control flow&lt;/li&gt;
&lt;li&gt;Run concurrently with others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Differences

&lt;ul&gt;
&lt;li&gt;Threads share code &amp;amp; data, processes don&amp;#39;t&lt;/li&gt;
&lt;li&gt;Process control &amp;amp; context switches more expensive than thread control &amp;amp; thread switches&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Pthreads&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;User has to:

&lt;ul&gt;
&lt;li&gt;Decompose computation into parallel parts&lt;/li&gt;
&lt;li&gt;Create/destroy threads&lt;/li&gt;
&lt;li&gt;Add synchronization to ensure dependences covered&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pthread_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_join()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Synchronization&lt;/h3&gt;

&lt;h4&gt;Parallelization Options&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Course-grained locking&lt;/strong&gt;: 1 big lock for critical section

&lt;ul&gt;
&lt;li&gt;Limited parallelism&lt;/li&gt;
&lt;li&gt;Easy to implement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fine-grained locking&lt;/strong&gt;: 1 lock per variable used in critical section

&lt;ul&gt;
&lt;li&gt;Good parallelism: less dependencies&lt;/li&gt;
&lt;li&gt;Hard to implement

&lt;ul&gt;
&lt;li&gt;Deadlock, fault tolerance, priority inversion, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semaphores&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fork-Join&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Barriers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reductions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Data Parallelism&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Processors do the same thing on different data

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regular&lt;/strong&gt;: linear indexing

&lt;ul&gt;
&lt;li&gt;All arrays accessed through linear expressions of loop indices, known at compile time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Irregular&lt;/strong&gt;: non-linear indexing

&lt;ul&gt;
&lt;li&gt;Some arrays accessed through non-linear expressions of loop indices, some only known at runtime&lt;/li&gt;
&lt;li&gt;Difficult for parallelism based on &lt;em&gt;data distribution&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Not difficult for parallelism based on &lt;em&gt;iteration distribution&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;v.s. &lt;strong&gt;Task Parallelism&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Processors do different tasks&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Matrix Multiplication (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    for (j = 0; j &amp;lt; n; j++)
        c[i][j] = 0.0; 
for (i = 0; i &amp;lt; n; i++)
    for (j = 0; j &amp;lt; n; j++)
        for (k = 0; k &amp;lt; n; k++)
            c[i][j] += a[i][k] * b[k][j];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences on i-/j- loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence&lt;/strong&gt; on k-loop&lt;/li&gt;
&lt;li&gt;Data Distribution

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block distribution&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by row&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cyclic distrubution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block cyclic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Combinations&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;SOR (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps/iterations {
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            temp[i][j] = 0.25 *
                (grid[i-1][j] + grid[i+1][j] + grid[i][j-1] + grid[i][j+1]);
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            grid[i][j] = temp[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No dependences between 1st &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;No dependences between 2nd &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd loop nest in the same timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 2nd &amp;amp; 1st loop nest of next timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Molecular Dynamics (Irregular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps { 
    for all molecules i
        for all nearby molecules j
            force[i] += f(loc[i], loc[j]);
    for all molecules i
        loc[i] = g(loc[i], force[i]);
}

for each molecule i
    number of nearby molecules count[i]
    array of indices of nearby molecules index[j] // 0 &amp;lt;= j &amp;lt; count[i]

for some number of timesteps { 
    for (i = 0; i &amp;lt; num_mol; i++)
        for (j = 0; j &amp;lt; count[i]; j++)
            force[i] += f(loc[i], loc[index[j]]);
    for (i = 0; i &amp;lt; num_mol; i++)
        loc[i] = g(loc[i], force[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences in 1st i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;li&gt;May have &lt;strong&gt;load balancing&lt;/strong&gt; problem&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence (reduction)&lt;/strong&gt; on j-loop&lt;/li&gt;
&lt;li&gt;No loop-carried dependences in 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Fork-join between loops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/threads-and-parallel-programming.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/threads-and-parallel-programming.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Memory Optimization</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Data Representation &amp;amp; Alignment&lt;/li&gt;
&lt;li&gt;Cache Performance

&lt;ol&gt;
&lt;li&gt;Cache Organization&lt;/li&gt;
&lt;li&gt;Cache Performance Metrics&lt;/li&gt;
&lt;li&gt;Code Scheduling&lt;/li&gt;
&lt;li&gt;Blocking/Tiling&lt;/li&gt;
&lt;li&gt;The Memory Moutain&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Virtual Memory

&lt;ol&gt;
&lt;li&gt;Virtual Memory Access&lt;/li&gt;
&lt;li&gt;Page Table &amp;amp; TLB&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Prefetching

&lt;ol&gt;
&lt;li&gt;H/W Prefetching&lt;/li&gt;
&lt;li&gt;S/W Prefetching&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Machine-Dependent Optimizations

&lt;ol&gt;
&lt;li&gt;Pointer Code&lt;/li&gt;
&lt;li&gt;Instruction-Level Parallelism&lt;/li&gt;
&lt;li&gt;Parallel Loop Unrolling&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Data Representation &amp;amp; Alignment&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Primitive data type requires K bytes -&amp;gt; address must be multiple of K&lt;/li&gt;
&lt;li&gt;Structures align with the &lt;em&gt;largest alignment requirement of any element&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Cache Performance&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Keep working set small (temporal locality)&lt;/li&gt;
&lt;li&gt;Use small strides (spacial locality)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Cache Organization&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;address: | tag | index | offset |
cache block: | v | tag | data |
S - 2^s sets
E - 2^e blocks/lines per set
B - 2^b bytes per cache block

Cach size = S * E * B bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Cache Performance Metrics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Miss rate&lt;/li&gt;
&lt;li&gt;Hit time

&lt;ul&gt;
&lt;li&gt;isLineInCache? + deliver block to CPU (+virtual memory translation)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Miss penalty&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Code Scheduling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Factors

&lt;ul&gt;
&lt;li&gt;Reordering of loops&lt;/li&gt;
&lt;li&gt;# of read/write operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Blocking/Tiling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Traverse array in blocks&lt;/li&gt;
&lt;li&gt;Imporves &lt;strong&gt;temporal locality&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The Memory Moutain&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Measure &lt;strong&gt;read throughput&lt;/strong&gt; as a function of &lt;strong&gt;spatial &amp;amp; temporal locality&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://cfile22.uf.tistory.com/image/112730164AC0AFAB36962C&quot; alt=&quot;Memory Mountain&quot;&gt;&lt;/p&gt;

&lt;h2&gt;Virtual Memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why virtual memory?

&lt;ul&gt;
&lt;li&gt;Capacity/Portability&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;Sharing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Virtual Memory Access&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Type of cache misses

&lt;ul&gt;
&lt;li&gt;Cold/compulsory miss&lt;/li&gt;
&lt;li&gt;Conflict miss

&lt;ul&gt;
&lt;li&gt;Avoided by &lt;em&gt;set-associative caches&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Capacity miss *

&lt;ul&gt;
&lt;li&gt;Keep working set within on-chip cache capacity&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Write

&lt;ul&gt;
&lt;li&gt;Write-back (on write-hit)&lt;/li&gt;
&lt;li&gt;Write-allocate (on write-miss)&lt;/li&gt;
&lt;li&gt;Write-through&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Page Table &amp;amp; TLB&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MMU keep mapping of VA to PA in &lt;strong&gt;page table&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Page table kept in main memory, can be cached&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Translation lookaside buffer (TLB)&lt;/strong&gt;: cache for page table

&lt;ul&gt;
&lt;li&gt;TLB hit: &lt;code&gt;CPU -&amp;gt; MMU -&amp;gt; TLB -&amp;gt; MMU -&amp;gt; Mem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TLB miss: &lt;code&gt;CPU -&amp;gt; MMU -&amp;gt; TLB -&amp;gt; Mem -&amp;gt; TLB -&amp;gt; MMU -&amp;gt; Mem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TLB reach: &lt;code&gt;(# TLB entries) * (page size)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Working set&lt;/strong&gt; : a set of active virtual pages

&lt;ul&gt;
&lt;li&gt;Page miss: &lt;code&gt;(working set size) &amp;gt; (main mem size)&lt;/code&gt; -&amp;gt; &lt;strong&gt;thrashing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;TLB miss: &lt;code&gt;(# working set pages) &amp;gt; (# TLB entries)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Prefetching&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bring into cache elements expected to be accessed in future&lt;/li&gt;
&lt;li&gt;Effective if:

&lt;ul&gt;
&lt;li&gt;Spare memory bandwidth&lt;/li&gt;
&lt;li&gt;Accurate&lt;/li&gt;
&lt;li&gt;Timely&lt;/li&gt;
&lt;li&gt;Doesn&amp;#39;t displace other in-use data&lt;/li&gt;
&lt;li&gt;Latency hidden by prefetched outweighs their cost&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;H/W Prefetching&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Prefetch adjacent block&lt;/li&gt;
&lt;li&gt;Recognize a &lt;em&gt;stream&lt;/em&gt;: addresses separated by a &lt;em&gt;stride&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Prefetch within a page boundary&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;S/W Prefetching&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Insert special &lt;code&gt;prefetch&lt;/code&gt; instructions into code

&lt;ul&gt;
&lt;li&gt;Patterns that H/W wouldn&amp;#39;t recognize e.g. linked list&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Machine-Dependent Optimizations&lt;/h2&gt;

&lt;h3&gt;Pointer Code&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Not necessarily better than array code; some compilers do better job optimizing array code&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Instruction-Level Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Limiting factor

&lt;ul&gt;
&lt;li&gt;Latency of instructions&lt;/li&gt;
&lt;li&gt;# of functional units available

&lt;ul&gt;
&lt;li&gt;1 load&lt;/li&gt;
&lt;li&gt;1 store&lt;/li&gt;
&lt;li&gt;2 int (1 may be branch)&lt;/li&gt;
&lt;li&gt;1 FP add&lt;/li&gt;
&lt;li&gt;1 FP mul/div&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Parallel Loop Unrolling&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Accumulate in 2 different products, combine at end

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(1 * x2 * ... * xn) * (1 * x1 * ... * x_n-1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Dual product 

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(1 * x1) * (x2 * x3) * ... * (x_n-1 * xn)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Limitations

&lt;ul&gt;
&lt;li&gt;Need lots of registers to hold sums/products&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/memory-optimization.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/memory-optimization.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Memory Allocation</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dynamic Memory Allocation

&lt;ol&gt;
&lt;li&gt;Memory Allocator&lt;/li&gt;
&lt;li&gt;Performance Goals&lt;/li&gt;
&lt;li&gt;Fragmentation&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Garbage Collection&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Memory-Related Bugs&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Dynamic Memory Allocation&lt;/h2&gt;

&lt;h3&gt;Memory Allocator&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Explicit memory allocator&lt;/strong&gt;: &lt;code&gt;malloc&lt;/code&gt; &amp;amp; &lt;code&gt;free&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implicit memory allocator&lt;/strong&gt;: garbage collection&lt;/li&gt;
&lt;li&gt;Provides abstraction of memory as a set of blocks&lt;/li&gt;
&lt;li&gt;Constraints

&lt;ul&gt;
&lt;li&gt;Alignment&lt;/li&gt;
&lt;li&gt;No compaction on allocated blocks&lt;/li&gt;
&lt;li&gt;Only manipulate free memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Goal

&lt;ul&gt;
&lt;li&gt;Good time performance for &lt;code&gt;malloc&lt;/code&gt; &amp;amp; &lt;code&gt;free&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Good space utilization&lt;/li&gt;
&lt;li&gt;Good locality properties

&lt;ul&gt;
&lt;li&gt;Allocation close in time should be close in space&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Performance Goals&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Throughput&lt;/strong&gt;: # of completed requests per unit time&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peak memory utilization&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Aggregate payload &lt;code&gt;Pk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Current heap size &lt;code&gt;Hk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Peak memory utilization &lt;code&gt;Uk = (max_i&amp;lt;k Pi) / Hk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Fragmentation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Internal fragmentation&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Depends on pattern of &lt;em&gt;previous&lt;/em&gt; requests&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;External fragmentation&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Depends on pattern of &lt;em&gt;future&lt;/em&gt; requests&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;| size | a | - header
| payload  |
| padding  |
| size | a | - footer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Keep track of &lt;strong&gt;size&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Overhead: size + allocated bit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Keep track of &lt;strong&gt;free blocks&lt;/strong&gt;

&lt;ol&gt;
&lt;li&gt;Implicit list: length to link all blocks&lt;/li&gt;
&lt;li&gt;Explicit list: pointers to link free blocks&lt;/li&gt;
&lt;li&gt;Segregated free list&lt;/li&gt;
&lt;li&gt;Blocks sorted by size&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Implicit List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Placement policy

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;First fit&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Next fit&lt;/strong&gt;: fragmentation worse&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best fit&lt;/strong&gt;: slower&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Coalescing policy

&lt;ul&gt;
&lt;li&gt;Join adjacent free blocks&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Immediate coalescing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deferred coalescing&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Until &lt;code&gt;malloc&lt;/code&gt; or external fragmentation reaches threshold&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Explicit Free List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Extra data space for link pointers&lt;/li&gt;
&lt;li&gt;Need boundary tags for coalescing&lt;/li&gt;
&lt;li&gt;Insertion policy

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LIFO&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address-ordered&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Segragated Free List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Each size class  has own collection of blocks

&lt;ul&gt;
&lt;li&gt;Separate size class for small sizes&lt;/li&gt;
&lt;li&gt;Typically size classes for power of 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Garbage Collection&lt;/h3&gt;

&lt;h4&gt;Mark and Sweep Collecting&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mark&lt;/strong&gt;: scan over blocks, mark all reachable memory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sweep&lt;/strong&gt;: scan over blocks, free blocks not marked&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Memory-Related Bugs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dereferencing bad pointers 

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scanf(&amp;quot;%d&amp;quot;, val)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Reading uninitialized memory &lt;/li&gt;
&lt;li&gt;Overwriting memory

&lt;ul&gt;
&lt;li&gt;Allocating wrong sized object&lt;/li&gt;
&lt;li&gt;Off-by-one error&lt;/li&gt;
&lt;li&gt;Not checking max string size&lt;/li&gt;
&lt;li&gt;Referencing a pointer instead of the object it points to: &lt;code&gt;*size--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pointer arithmetic: &lt;code&gt;p += sizeof(int)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Referencing nonexistent variables 

&lt;ul&gt;
&lt;li&gt;Return pointer to local variable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Freeing blocks multiple times &lt;/li&gt;
&lt;li&gt;Referencing freed blocks&lt;/li&gt;
&lt;li&gt;Failing to free blocks&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/memory-allocation.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/memory-allocation.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Code Optimization Principles &amp; Profiling</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Measurements of Programs &amp;amp; Computers

&lt;ol&gt;
&lt;li&gt;Measurements&lt;/li&gt;
&lt;li&gt;Amdahl&amp;#39;s Law&lt;/li&gt;
&lt;li&gt;Tools for Measuring&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Compiler Optimizations

&lt;ol&gt;
&lt;li&gt;Common Compiler Optimizations&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Basics of Computer Architecture

&lt;ol&gt;
&lt;li&gt;Pipelines&lt;/li&gt;
&lt;li&gt;Branch Prediction&lt;/li&gt;
&lt;li&gt;Out-of-Order Execution&lt;/li&gt;
&lt;li&gt;Superscalar &amp;amp; Simultaneous Multithreading(SMT)/Hyperthreading&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Measurements of Programs &amp;amp; Computers&lt;/h2&gt;

&lt;h3&gt;Measurements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IPS&lt;/strong&gt;: instructions per second&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FLOPS&lt;/strong&gt;: floating point operations per second&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPC&lt;/strong&gt;: instructions per cycle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPI&lt;/strong&gt;: cycles per instruction&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Amdahl&amp;#39;s Law&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;speedup = OldTime/NewTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewTime = OldTime x [(1 - f) + f/s]&lt;/code&gt;&lt;br&gt;
&lt;code&gt;speedup = 1 / (1 - f + f/s)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; = fraction of execution time the optimization applies to&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; = improvement factor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Tools for Measuring&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S/W timers&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;C library: &lt;code&gt;&amp;lt;sys/times.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OS-level timers: &lt;code&gt;/usr/bin/time&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;H/W timers &amp;amp; performance counters&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Built into processor chip: low-level architecture events e.g. cache misses, branch mispredictions, ...&lt;/li&gt;
&lt;li&gt;S/W packages to make them easier to use: &lt;code&gt;perf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Instrumentation&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Self implemented codes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gprof&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Periodically interrupt program&lt;/li&gt;
&lt;li&gt;Measure &lt;em&gt;time spent&lt;/em&gt; &amp;amp; &lt;em&gt;# of calls made&lt;/em&gt; in each function&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gcov&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Profile of execution within a function e.g. # of times each line of code was executed, which loops/conditional statements are important&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disturbing the system slows down execution&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comparison&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;gprof&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;gcov&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Compile&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;faster (insert counter func for each function)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;slower (insert counter func for each line)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Size&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;smaller&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;bigger&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Runtime&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;slower (frequent interrupts)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;faster&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Compiler Optimizations&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Preserve correctness&lt;/li&gt;
&lt;li&gt;Improve performance

&lt;ul&gt;
&lt;li&gt;Fewer CPI

&lt;ul&gt;
&lt;li&gt;Schedule instructions&lt;/li&gt;
&lt;li&gt;Improve cache/memory behavior&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Fewer instructions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Worth the effort&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;---&amp;gt; Front End ---&amp;gt; Optimizer ---&amp;gt; Code Generator ---&amp;gt;
 HLL            IR             IR                 LLL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Limitations

&lt;ul&gt;
&lt;li&gt;Cannot change program behavior&lt;/li&gt;
&lt;li&gt;Inter-procedural analysis too expensive -&amp;gt; most analysis performed within procedures&lt;/li&gt;
&lt;li&gt;Hard to anticipate run-time inputs -&amp;gt; most analysis based on static information&lt;/li&gt;
&lt;li&gt;Must be conservative&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Programmers should:

&lt;ul&gt;
&lt;li&gt;Select best algorithm&lt;/li&gt;
&lt;li&gt;Write readable &amp;amp; maintainable code&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eliminate optimization blockers&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Memory aliasing

&lt;ul&gt;
&lt;li&gt;2 different memory references specific single location&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pocedural side-effects&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Common Compiler Optimizations&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Machine independent

&lt;ul&gt;
&lt;li&gt;Constant propagation&lt;/li&gt;
&lt;li&gt;Constant folding&lt;/li&gt;
&lt;li&gt;Common subexpression elimination&lt;/li&gt;
&lt;li&gt;Dead code elimination&lt;/li&gt;
&lt;li&gt;Loop invariant code motion&lt;/li&gt;
&lt;li&gt;Function inlining

&lt;ul&gt;
&lt;li&gt;Space-speed tradeoff&lt;/li&gt;
&lt;li&gt;Overloading issue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Reduction in strength: replace costly operation with simpler one

&lt;ul&gt;
&lt;li&gt;Shifting (machine-dependent)&lt;/li&gt;
&lt;li&gt;Make use of registers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Direct access

&lt;ul&gt;
&lt;li&gt;Avoid bound checking&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Machine dependent

&lt;ul&gt;
&lt;li&gt;Instruction scheduling&lt;/li&gt;
&lt;li&gt;Loop unrolling

&lt;ul&gt;
&lt;li&gt;Enables more aggressive instruction scheduling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel unrolling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Basics of Computer Architecture&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RISC: simpler instructions -&amp;gt; &lt;strong&gt;pipeline&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;64-bit: larger databases, counter not overflowing, better math performance -&amp;gt; code size increases&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Pipelines&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Important factors

&lt;ul&gt;
&lt;li&gt;Branch prediction&lt;/li&gt;
&lt;li&gt;Data dependency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pipeline deeper -&amp;gt; misprediction penalty larger&lt;/li&gt;
&lt;li&gt;Multiple instruction issue: flushing &amp;amp; refetching more instructions&lt;/li&gt;
&lt;li&gt;OOP: More indirect branches to be predicted&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Branch Prediction&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Predict future based on history&lt;/li&gt;
&lt;li&gt;Global predictor: predict based on &lt;em&gt;global&lt;/em&gt; &amp;amp; &lt;em&gt;local&lt;/em&gt; history

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(m, n) prediction&lt;/strong&gt;: m-bit global x n-bit local&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Out-of-Order Execution&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Solve &lt;strong&gt;data dependency&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Mask &lt;strong&gt;cache miss delay&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Superscalar &amp;amp; Simultaneous Multithreading(SMT)/Hyperthreading&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    1               1 2             1 2 6
    2               3 4 5           3 4 5   
    3               6               7 8
    4               7 8             9
    5               9
    6
    7
    8
    9
single-issue     superscalar    out-of-order superscalar

    1   1'          1 2 6           1 2 1'
    2   2'          3 4 5           2'6 6'
    3   3'          7 8             3'3 5
    4   4'          9               4 4'5'
    5   5'          1'2'6'          7 8 7'
    6   6'          3'4'5'          9 8'
    7   7'          7'8'            9'
    8   8'          9'
    9   9'
2 applications      fast        hyperthreading
                context switching
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/code-optimization-principles-and-profiling.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/code-optimization-principles-and-profiling.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Constraint Satisfaction Problems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Constraint Satisfaction Problems (Backtracking Search) Overview

&lt;ol&gt;
&lt;li&gt;CSP v.s Traditional Search Problems&lt;/li&gt;
&lt;li&gt;Feature Vectors&lt;/li&gt;
&lt;li&gt;Constraint Graph&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Solving CSPs

&lt;ol&gt;
&lt;li&gt;Viewing CSP as Search Problem&lt;/li&gt;
&lt;li&gt;Backtracking Search Algorithm&lt;/li&gt;
&lt;li&gt;Constraint Propagation

&lt;ol&gt;
&lt;li&gt;Forward Checking&lt;/li&gt;
&lt;li&gt;Generalizaed Arc Consistency&lt;/li&gt;
&lt;li&gt;Heuristics&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Constraint Satisfaction Problems (Backtracking Search) Overview&lt;/h2&gt;

&lt;h3&gt;CSP v.s Traditional Search Problems&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;CSP does not care about the &lt;em&gt;sequence of moves&lt;/em&gt; to reach goal state&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Feature Vectors&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Represent states as &lt;strong&gt;vectors of feature values&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Formalization

&lt;ul&gt;
&lt;li&gt;A set of &lt;strong&gt;features/variables&lt;/strong&gt; &lt;code&gt;V1, ... Vn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain&lt;/strong&gt; for each variable &lt;code&gt;Dom[Vi]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A set of &lt;strong&gt;constraints&lt;/strong&gt; &lt;code&gt;C1, ..., Cm&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scope&lt;/strong&gt;: a set of variables it operates over&lt;/li&gt;
&lt;li&gt;Unary, binary, higher-order constraints&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;State&lt;/strong&gt;: assignment of value for each variable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partial state&lt;/strong&gt;: assignment of value for some variables&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Goal state&lt;/strong&gt;: a state satisfying all &lt;strong&gt;constraints&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Constraint Graph&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nodes: &lt;strong&gt;variables&lt;/strong&gt;; arcs: &lt;strong&gt;constraints&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Solving CSPs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Search through the space of partial assignments&lt;/li&gt;
&lt;li&gt;Order of assignments does not matter&lt;/li&gt;
&lt;li&gt;If we falsify a constraint, we immediately reject the current partial assignment&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Viewing CSP as Search Problem&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Initial state&lt;/strong&gt;: empty assignment&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Successor function&lt;/strong&gt;: a value assigned to any unassigned variable s.t. no constraints return false&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Goal test&lt;/strong&gt;: complete assignment&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Backtracking Search Algorithm&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Similar to DFS&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;BT(Level):
    If all variables assigned:
        PRINT Value of each Variable
        RETURN

    V := PickUnassignedVariable()
    Assigned[V] := TRUE
    for d := each member of Domain(V):
        Value[V] := d
        ConstraintsOK = TRUE
        for each constraint C such that
            a) V is a variable of C and
            b) all other variables of C are assigned: 
            If C is not satisfied by the set of current assignments:
                ConstraintsOK = FALSE
                break
        If ConstraintsOk == TRUE:
            BT(Level+1)
    Assigned[V] := FALSE //UNDO as we have tried all of V’s values return
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Constraint Propagation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Look ahead&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Forward Checking&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;When instantiating a variable, check all constrants with &lt;strong&gt;only one ininstantiated variable&lt;/strong&gt; remaining&lt;/li&gt;
&lt;li&gt;Prune values of that variable that violate the constraint&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;FCCheck(C,x):
    // C is a constraint with all its variables already assigned, except for variable x

    for d := each member of CurDom[x]:
        If making x = d together with previous assignments
    to variables in scope C falsifies C:
            remove d from CurDom[x]

    If CurDom[x] = {}:
        return DWO (Domain Wipe Out)
    Else:
        return ok

FC(Level):
    If all variables assigned:
        PRINT Value of each Variable
        RETURN

    V := PickAnUnassignedVariable()
    Assigned[V] := TRUE
    for d := each member of CurDom(V):
        Value[V] := d
        DWOoccured:= False
        for each constraint C over V such that
            a) C has only one unassigned variable X in its scope:
            If (FCCheck(C,X) == DWO):
                DWOoccurred:= True
                break
        If(not DWOoccured)
            FC(Level+1)
        RestoreAllValuesPrunedByFCCheck()
    Assigned[V] := FALSE
    return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Generalizaed Arc Consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C(V1, ..., Vn)&lt;/code&gt; is GAC with regard to &lt;code&gt;Vi&lt;/code&gt; iff for every value of &lt;code&gt;Vi&lt;/code&gt;, there exist values of &lt;code&gt;V1, ..., Vn&lt;/code&gt; that satisfy C&lt;/li&gt;
&lt;li&gt;If for &lt;code&gt;Vi = d&lt;/code&gt; is not consistent wrt the constraint, &lt;code&gt;d&lt;/code&gt; is &lt;strong&gt;arc inconsistent&lt;/strong&gt; and can be removed from domain of &lt;code&gt;Vi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A constraint that is GAC may become non-GAC due to pruning of domain values during search&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;GAC_Enforce():
// GAC-Queue contains all constraints one of whose variables has had its domain reduced

while GACQueue not empty:
    C = GACQueue.extract()
    for V := each member of scope(C):
        for d := CurDom[V]:
            Find an assignment A for all other variables in scope(C) such that C(A ∪ V=d) = True
            if A not found:
                CurDom[V] = CurDom[V] – d 
            if CurDom[V] = ∅:
                empty GACQueue
                return DWO
            else:
                push all constraints C’ s.t. V ∈ scope(C’) and C’ !∈ GACQueue on to GACQueue
return TRUE

GAC(Level):
    If all variables are assigned:
        PRINT Value of each Variable
        RETURN

    V := PickAnUnassignedVariable()
    Assigned[V] := TRUE
    for d := each member of CurDom(V):
        Value[V] := d
        Prune all values of V != d from CurDom[V]
        for each constraint C whose scope contains V:
            Put C on GACQueue
        if(GAC_Enforce() != DWO):
            GAC(Level+1)
        RestoreAllValuesPrunedFromCurDoms()

    Assigned[V] := FALSE
    return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;May keep track of &lt;strong&gt;supports&lt;/strong&gt; to avoid having to search through all possible assignments and check satisfication&lt;/li&gt;
&lt;li&gt;Check if current support still valie, i.e. all values it assigns still lie in the variables&amp;#39; current domains&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Heuristics&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ordering of variables

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minimum Remaining Values (MRV)&lt;/strong&gt;: returns the variable with the most constrained current domain&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Degree Heuristic (DH)&lt;/strong&gt;: returns variable imposing the most constraints on remaining unassigned variables&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ordering of values

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Least Constraining Value (LCV)&lt;/strong&gt;: the best value is the one ruling out the fewest domain values in other variables that share at least one constraint with var&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/ai/2016/10/30/constraint-satisfaction-problems.html</link>
        <guid isPermaLink="true">/blog/notes/ai/2016/10/30/constraint-satisfaction-problems.html</guid>
        
        <category>AI</category>
        
        <category>CSC384</category>
        
        <category>CSP</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>Search</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Search Overview

&lt;ol&gt;
&lt;li&gt;Formalism of Search&lt;/li&gt;
&lt;li&gt;Searching Template&lt;/li&gt;
&lt;li&gt;Critical Properties of Search&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Uninformed Search

&lt;ol&gt;
&lt;li&gt;BFS&lt;/li&gt;
&lt;li&gt;DFS&lt;/li&gt;
&lt;li&gt;Depth Limited Search&lt;/li&gt;
&lt;li&gt;Iterative Deepening Search&lt;/li&gt;
&lt;li&gt;Uniform-Cost Search&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Informed/Heuristic Search

&lt;ol&gt;
&lt;li&gt;Best First Search&lt;/li&gt;
&lt;li&gt;A*&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Search Overview&lt;/h2&gt;

&lt;h3&gt;Formalism of Search&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;State space&lt;/li&gt;
&lt;li&gt;Initial state &amp;amp; goal state&lt;/li&gt;
&lt;li&gt;Actions/successor functions/state space transitions &lt;code&gt;S(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Costs &lt;code&gt;C(x, a, y)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Heuristics to guide search&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;h4&gt;Complex situations&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Actions lead to multiple states&lt;/li&gt;
&lt;li&gt;Unsure of a given state&lt;/li&gt;
&lt;li&gt;=&amp;gt; &lt;strong&gt;Probabilistic models&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Searching Template&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;State annotation

&lt;ul&gt;
&lt;li&gt;State + action, parent state, cost, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Frontier&lt;/strong&gt;: states haven&amp;#39;t explored or expanded but want to explore&lt;/li&gt;
&lt;li&gt;Order of frontiers (selection rules) implies the type of search, e.g. &lt;code&gt;BFS&lt;/code&gt;, &lt;code&gt;DFS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;TreeSearch(Frontier, Successors, Goal):
    If Frontier empty:
        return failure

    Curr = select state from Frontier
    If (Goal(Curr)):
        return Curr
    Frontier' = (Frontier - {Curr}) ∪ Successors(Curr)
    return TreeSearch(Frontier', Successors, Goal)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Critical Properties of Search&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Completeness&lt;/li&gt;
&lt;li&gt;Optimality&lt;/li&gt;
&lt;li&gt;Time complexity&lt;/li&gt;
&lt;li&gt;Space complexity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Uninformed Search&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fixed rule for selecting next state&lt;/li&gt;
&lt;li&gt;Do not consider any &lt;strong&gt;domain specific information&lt;/strong&gt; about the particular search problem&lt;/li&gt;
&lt;li&gt;e.g. BFS, Uniform-Cost, DFS, Depth-Limited, Iterative-Deepening&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Path &amp;amp; Cycle Checking&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Path checking

&lt;ul&gt;
&lt;li&gt;Ensure expanded state &lt;code&gt;c&lt;/code&gt; not equal to state reached by any ancestor of &lt;code&gt;c&lt;/code&gt; along this path&lt;/li&gt;
&lt;li&gt;Path checked in isolation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cycle checking/ Multiple path checking

&lt;ul&gt;
&lt;li&gt;Ensure &lt;code&gt;c&lt;/code&gt; not equal to any previously expanded state&lt;/li&gt;
&lt;li&gt;Space complexity of DFS goes &lt;code&gt;exponential&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Non-uniform costs have additional issues&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;BFS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O(b^(d+1))&lt;/code&gt; space: explored nodes + nodes expanded at goal level before reaching goal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(b^(d+1))&lt;/code&gt; time

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 + b + b^2 +...+ b^d + b(b^d-1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimal&lt;/li&gt;
&lt;li&gt;Complete&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;DFS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O(bm)&lt;/code&gt; space (one path at a time)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(b^m)&lt;/code&gt; time, &lt;code&gt;m&lt;/code&gt; = length of longest path in state space&lt;/li&gt;
&lt;li&gt;Complete for finite depth &amp;amp; acyclic graph or cycles pruned&lt;/li&gt;
&lt;li&gt;Not optimal&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Depth Limited Search&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;DLS(Frontier, Successors, Goal):
    While Frontier not empty:
        n = first node from Frontier
        Curr = terminal state of n
        If (Goal(Curr)):
            return n

        If Depth &amp;lt; D: // limit Frontiers to depth D
            Frontier = (Frontier - {n}) ∪ Successors(Curr)
        Else:
            Frontier = Frontier - {n}
            CutOffOccured = TRUE
    return FAIL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Iterative Deepening Search&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Iteratively increase depth limit and perform DLS&lt;/li&gt;
&lt;li&gt;Stop if solution found OR DLS failed without cutting off any nodes&lt;/li&gt;
&lt;li&gt;Not good if many cycles&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(bd)&lt;/code&gt; space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(b^d)&lt;/code&gt; time

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(d+1)b^0 + db + ... + b^d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Complete&lt;/li&gt;
&lt;li&gt;Optimal if costs uniform

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cost bound&lt;/strong&gt; for non-uniform costs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Uniform-Cost Search&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Frontier&lt;/code&gt; ordered by &lt;strong&gt;increasing cost of path&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Nodes rejected or replaced on Frontier guaranteed to have more costly paths&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(b^(C*/ε))&lt;/code&gt; time &amp;amp; space, &lt;code&gt;C*&lt;/code&gt; = cost of optimal solution&lt;/li&gt;
&lt;li&gt;Complete if positive, nonzero transition costs&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimal&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Given: each transition has costs &amp;gt;= ε &amp;gt; 0

Lemma 1: If n2 is expanded immediately after n1, then c(n1) &amp;lt;= c(n2)
Lemma 2: When node n is expanded, every path in the search space with cost &amp;lt; c(n) has already been expanded
Lemma 3: The first time USC expandes a node n terminating at state S, it has found the minimal cost path to S
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Informed/Heuristic Search&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h(n1) &amp;lt; h(n2)&lt;/code&gt; if we guess it&amp;#39;s cheaper to get to goal from n1 than from n2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(n) = 0&lt;/code&gt; for goal nodes n&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Best First Search&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Only use &lt;code&gt;h(n)&lt;/code&gt; to guide the search&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;A*&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f(n) = g(n) + h(n)&lt;/code&gt;, &lt;code&gt;g(n)&lt;/code&gt; = cost of path to n&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adimissible h(n)&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Let &lt;code&gt;h*(n)&lt;/code&gt; be the cost of an optimal path from n to goal node, then &lt;strong&gt;admissible heuristic&lt;/strong&gt; satisfies:&lt;br&gt;
&lt;code&gt;h(n) &amp;lt;= h*(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Never &lt;strong&gt;over-estimates&lt;/strong&gt; the cost to reach goal, won&amp;#39;t miss any promising paths&lt;/li&gt;
&lt;li&gt;Implies &lt;strong&gt;optimality&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monotonic/Consistent h(n)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Local admissibility&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(n1) &amp;lt;= c(n1, a, n2) + h(n2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Consistency -&amp;gt; Adimissibility&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Assume h(n1) &amp;lt;= c(n1, a, n2) + h(n2)
Prove h(n) &amp;lt;= h*(n)

If not path from n to goal, then h*(n) = inf
Else
    Let n-&amp;gt;n1-&amp;gt;...-&amp;gt;n* be an optimal path from n to goal
    (Cost: h*(n); cost of sub-path: h*(ni))

    Base case: n = n*, h(n) = 0 &amp;lt;= h*(n) = 0
    Induction: h(n1) &amp;lt;= h*(n1)
        h(n) &amp;lt;= c(n, a1, n1) + h(n1) &amp;lt;= c(n, a1, n1) + h*(n1) = h*(n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;f(n)&lt;/code&gt; non-decreasing&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;f(n1) = g(n1) + h(n1) &amp;lt;= g(n1) + c(n1, a, n2) + h(n2) = f(n2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;f(n1) &amp;lt;= f(n2)&lt;/code&gt; if n2 expanded after n1&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If n has been expanded, every path with lower f-value has already been expanded&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The first time A* expands a node, it has found the min cost path to that node&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Admissible &amp;amp; monotonic h(n)&lt;/strong&gt; =&amp;gt; Optimal&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Same time &amp;amp; space bounds as UCS

&lt;ul&gt;
&lt;li&gt;# of nodes expanded no larger than UCS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Complete

&lt;ul&gt;
&lt;li&gt;Finite # of paths having &lt;code&gt;f-value &amp;lt; c(SolutionPath)&lt;/code&gt;, since each action has &lt;code&gt;costs &amp;gt;= ε &amp;gt; 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimal&lt;/li&gt;
&lt;li&gt;Cycle checking: keep only the first path to a state, rejecting all subsequent paths&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Admissibility without monotonicity&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Optimal

&lt;ul&gt;
&lt;li&gt;But ordering of nodes not guaranteed optimal when put in queue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cycle checking: keep revisited nodes with cost less than before&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Expand less state space, but still constrained by speed or memory&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IDA*: reduce memory requirements

&lt;ul&gt;
&lt;li&gt;Cutoff: &lt;code&gt;f-value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;curBound&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smallestNotExplored&lt;/code&gt;: smallest &lt;code&gt;f-value&lt;/code&gt; of discarded nodes in a round

&lt;ul&gt;
&lt;li&gt;Expand all nodes with &lt;code&gt;f-value&lt;/code&gt; equal to &lt;code&gt;f-limit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Weighted A*

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f(n) = (1-ε) * g(n) + ε * h(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Anytime A*

&lt;ul&gt;
&lt;li&gt;Find the best path for a given ε&lt;/li&gt;
&lt;li&gt;Reduce ε and replan&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 29 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/ai/2016/10/29/search.html</link>
        <guid isPermaLink="true">/blog/notes/ai/2016/10/29/search.html</guid>
        
        <category>AI</category>
        
        <category>CSC384</category>
        
        <category>search</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>Game Tree Search</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Game Overview

&lt;ol&gt;
&lt;li&gt;Game Properties&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Two-Player Zero-Sum Game

&lt;ol&gt;
&lt;li&gt;Definition&lt;/li&gt;
&lt;li&gt;Intuition&lt;/li&gt;
&lt;li&gt;MiniMax Strategy&lt;/li&gt;
&lt;li&gt;Real-Time/Online search&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Game Overview&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Generalization of Search Problems

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Game tree&lt;/strong&gt;: actions of &amp;gt;= 1 players/agents&lt;/li&gt;
&lt;li&gt;Agents acting to &lt;strong&gt;maximize their profits&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Others&amp;#39; profits might not have positive effect on yours&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Key Features of Game

&lt;ul&gt;
&lt;li&gt;Each player has different goal&lt;/li&gt;
&lt;li&gt;Different paths/states assigned different costs&lt;/li&gt;
&lt;li&gt;Each player tries to alter the world to best benefit itself&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Game Properties&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Two-player&lt;/li&gt;
&lt;li&gt;Discrete: game states or decision can be mapped on discrete values&lt;/li&gt;
&lt;li&gt;Finite: a finite # of states/decisions can be made&lt;/li&gt;
&lt;li&gt;Zero-sum (Fully Competitive): A gains = B loses

&lt;ul&gt;
&lt;li&gt;Strategic/normal form game: one shot e.g. rock-paper-scissors&lt;/li&gt;
&lt;li&gt;Extensive form game: turn-taking, multiple moves&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Deterministic: no chance involved&lt;/li&gt;
&lt;li&gt;Perfect Information: all aspects of the state are fully observable&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Two-Player Zero-Sum Game&lt;/h2&gt;

&lt;h3&gt;Definition&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2 players: &lt;code&gt;A&lt;/code&gt;(Max), &lt;code&gt;B&lt;/code&gt;(Min)&lt;/li&gt;
&lt;li&gt;States &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Initial state &lt;code&gt;I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Terminal positions &lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Successor functions

&lt;ul&gt;
&lt;li&gt;Input: a state&lt;/li&gt;
&lt;li&gt;Return: a set of possible next states&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Utility/Payoff function &lt;code&gt;V: T -&amp;gt; R&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Mapping showing how good each terminal state is for A/how bad for B&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Intuition&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Game ends when terminal &lt;code&gt;t ∊ T&lt;/code&gt; reached&lt;/li&gt;
&lt;li&gt;Game state: state-player pair&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; gets &lt;code&gt;V(t)&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; gets &lt;code&gt;-V(t)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;MiniMax Strategy&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Build full game tree

&lt;ul&gt;
&lt;li&gt;Root: start state&lt;/li&gt;
&lt;li&gt;Edges: possible moves&lt;/li&gt;
&lt;li&gt;Leaves: terminals (utilities U(t) labeled)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Back balues up the tree

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;U(n) = min{ U(c): c is a child of n if n is Min node }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U(n) = max{ U(c): c is a child of n if n is Max node }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O(b^d)&lt;/code&gt; space&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Depth-First Implementation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;To avoid expanding the tree exponentially in size&lt;/li&gt;
&lt;li&gt;Need &lt;strong&gt;finite depth&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;DFMiniMax(n, Player): //return Utility of state n given that Player is MIN or MAX

    If n is TERMINAL:
        Return V(n) //Return terminal states utility (V is specified as part of game)

    //Apply Player s moves to get successor states. 
    ChildList = n.Successors(Player)

    If Player == MIN:
        return minimum of DFMiniMax(c, MAX) over c ∈ ChildList
    Else: //Player is MAX
        return maximum of DFMiniMax(c, MIN) over c ∈ ChildList
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Pruning&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;α-cuts(max node) &amp;amp; β-cuts(min node)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;AlphaBeta(n,Player,alpha,beta): //return Utility of state 

    If n is TERMINAL:
        return V(n) //Return terminal states utility 

    ChildList = n.Successors(Player)

    If Player == MAX:
        v = -infinity
        for c in ChildList:
            v = max(v, AlphaBeta(c,MIN,alpha,beta)) 
            alpha = max(v, alpha)
            If beta &amp;lt;= alpha:
                break 
        return v

    Else: //Player == MIN 
        v = infinity
        for c in ChildList:
            v = min(v, AlphaBeta(c,MAX,alpha,beta)) 
            beta = min(v, beta)
            If beta &amp;lt;= alpha:
                break 
        return v

// Initial call: AlphaBeta(START_NODE, PLAYER, -infinity, infinity)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O(b^d)&lt;/code&gt; space if no pruning, &lt;code&gt;O(b^(d/2))&lt;/code&gt; if optimal pruning

&lt;ul&gt;
&lt;li&gt;Branching factor of 1st layer: B; 2nd: 1; 3rd: B; ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;In practice, must make &lt;strong&gt;heuristic estimates&lt;/strong&gt; of the terminal nodes -&amp;gt; &lt;strong&gt;evaluation function&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Real-Time/Online search&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Run A* until out of memory&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;evaluation function&lt;/strong&gt; to decide which path looks best&lt;/li&gt;
&lt;li&gt;Make the move&lt;/li&gt;
&lt;li&gt;Restart search at the node reached (can be cached)&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 29 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/ai/2016/10/29/game-tree-search.html</link>
        <guid isPermaLink="true">/blog/notes/ai/2016/10/29/game-tree-search.html</guid>
        
        <category>AI</category>
        
        <category>CSC384</category>
        
        <category>search</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>Operating System - Unix &amp; Pthread</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Process-Related Unix System Calls&lt;/li&gt;
&lt;li&gt;Posix Thread&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Process-Related Unix System Calls&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;process&lt;/code&gt; in Unix consistes of an &lt;code&gt;address space&lt;/code&gt; &amp;amp; a &lt;code&gt;thread&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getpid()&lt;/code&gt;, &lt;code&gt;getppid()&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Pid identifies &lt;code&gt;address space&lt;/code&gt; &amp;amp; &lt;code&gt;thread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;, &lt;code&gt;execv()&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Create &lt;code&gt;processes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exit()&lt;/code&gt;, &lt;code&gt;wait()&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Terminate &lt;code&gt;processes&lt;/code&gt; &amp;amp; synchronize with terminating &lt;code&gt;process&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kill()&lt;/code&gt;, &lt;code&gt;sigaction()&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Communicate with another &lt;code&gt;process&lt;/code&gt; via &lt;code&gt;signals&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create &lt;code&gt;childe process&lt;/code&gt; from &lt;code&gt;parent process&lt;/code&gt; with an identical copy of:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Address space&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;int n = 5;
int pid = fork(); 
if (pid == 0) {
    // run child code
    n = n + 1;
} else { // pid value &amp;gt; 0
    // run parent code
    n = n - 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Replaces current &lt;code&gt;process&lt;/code&gt; with a new &lt;code&gt;program&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;Loaded from disk&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Code&lt;/code&gt; &amp;amp; &lt;code&gt;data&lt;/code&gt; copied from disk&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt; initialized with activation frame of &lt;code&gt;main()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Processor registers&lt;/code&gt; reinitialized&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pid&lt;/code&gt; stays the same&lt;/li&gt;
&lt;li&gt;Doesn&amp;#39;t return&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;char *cmd = &quot;/bin/ls&quot;; 
char *arg1 = &quot;-l&quot;; 
char *args[3];
args[1] = arg1; 
args[2] = NULL;
execv(cmd, args);
// code doesn’t execute
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt; + &lt;code&gt;execv()&lt;/code&gt; can run a new program as a new process with the old one kept&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;exit(retval)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Terminate itself:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Address space&lt;/code&gt; destroyed&lt;/li&gt;
&lt;li&gt;Process-specific OS state destroyed (e.g. open files)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retval&lt;/code&gt; saved &amp;amp; return to &lt;code&gt;parent process&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;parent process&lt;/code&gt; to learn about &lt;code&gt;child process&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread state&lt;/code&gt; destroyed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wait for &lt;code&gt;child process&lt;/code&gt; to terminate; synchronize with &lt;code&gt;child processes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Returns &lt;code&gt;retval&lt;/code&gt; returned from &lt;code&gt;exit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4 cases:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; wait starts, &lt;code&gt;C&lt;/code&gt; continue, &lt;code&gt;E&lt;/code&gt; exit starts, &lt;code&gt;D&lt;/code&gt; exit done&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Semaphore required for 1, 2, 3

1.
         down(c)  up(p)
Parent ---&amp;gt; W      C-----&amp;gt;
                  / \
Child  --------&amp;gt; E   D
              up(c) down(p)

2.

Parent --------&amp;gt; WC-----&amp;gt;
                 / \
Child  ------&amp;gt; E  | D           # OS keeps child exit retval until wait() is issued by parent,
            (zombie process)    # or destroyed when parent exits

3.

Parent --------&amp;gt; E
                / \
Child  -----&amp;gt; E    D

4.

Parent ---&amp;gt; E

Child  --------&amp;gt; ED
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Each &lt;code&gt;child process&lt;/code&gt; needs a pair of &lt;code&gt;semaphore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Process send signals to itself or other &lt;code&gt;processes&lt;/code&gt; by calling &lt;code&gt;kill&lt;/code&gt; system call&lt;/li&gt;
&lt;li&gt;Receiver executes &lt;code&gt;signal handler&lt;/code&gt;; if not setup, forced to exit&lt;/li&gt;
&lt;li&gt;Receiver process exits when scheduled to run next

&lt;ul&gt;
&lt;li&gt;Because if receiver is holding the lock, it must be released by itself instead of other threads&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sigaction()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Setup &lt;code&gt;signal handler&lt;/code&gt; function&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Posix Thread&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Allows creating additional threads in a &lt;code&gt;Unix process&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pthread_create(thread, attr, start_routine, arg)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit(status)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Returns &lt;code&gt;status&lt;/code&gt; to a joining thread&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_join(thread_id, status)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Block thread until thread with &lt;code&gt;thread_id&lt;/code&gt; terminates&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_yield()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Synchronization API&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mutex&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_lock(&amp;amp;mut);
pthread_mutex_unlock(&amp;amp;mut)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monitor&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;int x,y;
pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER; 
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

pthread_mutex_lock(&amp;amp;mut); 
while (x &amp;lt;= y) {
    pthread_cond_wait(&amp;amp;cond, &amp;amp;mut); 
}
/* operate on x and y */ 
pthread_mutex_unlock(&amp;amp;mut);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;pthread_mutex_lock(&amp;amp;mut);
/* modify x and y */
if (x &amp;gt; y) 
    pthread_cond_signal(&amp;amp;cond); 
pthread_mutex_unlock(&amp;amp;mut);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Semaphores&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sem_t sem name;
sem_init(&amp;amp;sem_name, 0, 0); // (_, flag, init value)
sem_wait(&amp;amp;sem_name);
sem_post(&amp;amp;sem);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Related Articles&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.rutgers.edu/%7Epxk/416/notes/04-processes.html&quot;&gt;Processes - Process Creation and States.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/os/2016/10/23/operating-system-unix-and-pthread.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/10/23/operating-system-unix-and-pthread.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>unix</category>
        
        <category>pthread</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>Operating System - Threads</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Threads and Processes&lt;/li&gt;
&lt;li&gt;Thread Scheduling&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Threads and Processes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When a &lt;strong&gt;program&lt;/strong&gt; runs, it is called a &lt;code&gt;process&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OS maintains states for each abstraction:

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Thread(CPU) state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Registers, PC, SP, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address Space (memory) state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Program instructions, static &amp;amp; dynamic data, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Device &amp;amp; other state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Open files, network connection state, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Threads&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Abstraction of &lt;strong&gt;virtualizing CPU&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Each &lt;code&gt;thread&lt;/code&gt; thinks it has its own set of &lt;code&gt;CPU registers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;# of &lt;code&gt;threads&lt;/code&gt; arbitrary; # of &lt;code&gt;CPUs&lt;/code&gt; fixed&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enables &lt;strong&gt;concurrency&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Running multiple programs concurrently&lt;/li&gt;
&lt;li&gt;Running multiple tasks concurrently

&lt;ul&gt;
&lt;li&gt;Hiding I/O latency

&lt;ul&gt;
&lt;li&gt;Can use &lt;code&gt;non-blocking file I/O&lt;/code&gt; (&lt;code&gt;event-driven&lt;/code&gt;), but harder to get right because need to build a state machine&lt;/li&gt;
&lt;li&gt;~ &lt;code&gt;interrupts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Run truly in parallel with multiple &lt;code&gt;CPUs&lt;/code&gt; via &lt;code&gt;multiplexing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Threads v.s. Functions&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Threads&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Functions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Independent streams of execution, one thread no need to run to the end before switching&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;LIFO policy, functions runs untill the end&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Thread scheduler multiplexes the threads on CPU&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;One function calls another function&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Each thread has its own stack, calling its own set of functions&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Running on a single stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Runs in parallel with multiprocessors&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Cannot run in parallel with multiprocessors because functions stack together&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Address Space&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Abstraction of &lt;strong&gt;virtualizing memory&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A set of &lt;em&gt;virtual memory regions&lt;/em&gt; accessible to a program

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Text&lt;/code&gt;: program code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;, &lt;code&gt;Heap&lt;/code&gt;: static, dynamic variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;: for function &amp;amp; system calls&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Provides &lt;strong&gt;memory protection&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Address space (order may vary with different H/W &amp;amp; compiler environment)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;        +++++++++++++++ ----
        |    param    |  |
        +++++++++++++++  |
        |   ret val   |  |
        +++++++++++++++  |
        |   ret addr  |  |  activation frame
        +++++++++++++++  |  for current function
  fp -&amp;gt; |   prev fp   |  |
        +++++++++++++++  |
        |  other regs |  |
        +++++++++++++++  |
  sp -&amp;gt; |  local var  |  |      # function call:
        +++++++++++++++ ----    # push %rbp; save old fp
        |      ↓      |         # mov %rbp %rsp; init sp to fp
        |             |         # retq; call *sp
        |      ↑      |
        +++++++++++++++         # return:
        |    data     |         # add $24 %rsp; pop off stack
        +++++++++++++++         # pop %rbp; fp=*sp (or *fp), sp++
        |    text     |         # retq; call *sp
        +++++++++++++++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Processes&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A running program consistes of &amp;gt;= 1 processes

&lt;ul&gt;
&lt;li&gt;Traditionally:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process = addr space + thread&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; communicate using &lt;code&gt;system calls&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Today:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process = addr space + &amp;gt;= 1 threads&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; share &lt;code&gt;addr space&lt;/code&gt; (but not &lt;code&gt;stack&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; communicate with &lt;code&gt;reading/writing memory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Speed up cases analysis:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Vector operation
for (k = 0; k &amp;lt; n; k++)
    a[k] = b[k]*c[k] + d[k]*e[k];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Multiple processes?

&lt;ul&gt;
&lt;li&gt;Communicate with &lt;code&gt;system call&lt;/code&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Multiple threads?

&lt;ul&gt;
&lt;li&gt;Must make it global to share data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On single processor?

&lt;ul&gt;
&lt;li&gt;Threads go one after another&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On multiprocessor?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Web server
Loop:
    1. get network message from client -&amp;gt; I/O
    2. get URL data form disk, cache in memory -&amp;gt; I/O
    3. compose response
    4. send response -&amp;gt; I/O
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Multiple processes?

&lt;ul&gt;
&lt;li&gt;Cannot share the cache (stored in global resource area of that process)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Multiple threads?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On single processor?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On multiprocessor?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Threads v.s. Processes&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Threads&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Processes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Memory needed&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Shared, less&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Not shared, more&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Communication &amp;amp; Synchronization&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Via &lt;strong&gt;shared vars&lt;/strong&gt;, faster&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Via &lt;strong&gt;system calls&lt;/strong&gt;, slower&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Switching&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Save &amp;amp; restore regs, faster&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Change MMU&amp;#39;s regs (e.g. base &amp;amp; limit), slower&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Robustness&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Memory sharing -&amp;gt; bugs&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Communication explicit -&amp;gt; robust&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Program v.s. Process&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Program&lt;/strong&gt;: a set of instructions &amp;amp; data&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Process&lt;/strong&gt;: a program loaded in memory and executing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;OS-Level Process State&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;OS keeps state for each process: &lt;code&gt;process state&lt;/code&gt;, &lt;code&gt;process control block (PCB)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Thread state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Processor regs&lt;/code&gt; for resuming/suspending thread&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Various &lt;code&gt;parameters&lt;/code&gt; e.g. scheduling parameters&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address space state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Location of &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;stack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MMU virtual memory state&lt;/code&gt; i.e. virtual -&amp;gt; physical mapping&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Device related state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Open files, network connections&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Other states&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Terminal state, pending signals, timers, swap, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Thread Scheduling&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread&lt;/code&gt;: an independent stream of instructions

&lt;ul&gt;
&lt;li&gt;Which to choose?&lt;/li&gt;
&lt;li&gt;When to switch?&lt;/li&gt;
&lt;li&gt;How to switch?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread scheduling&lt;/code&gt;: running threads in some order

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread state&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Running&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ready&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Blocked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exited&lt;/code&gt; (not yet destroyed)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scheduling policies&lt;/code&gt; to change states&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread scheduling functions&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thread_yield&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Running -&amp;gt; Ready&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread_sleep&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Running -&amp;gt; Blocked&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread_wakeup&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Blocked -&amp;gt; Ready&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preemptive scheduling&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Scheduler&lt;/code&gt; uses &lt;code&gt;timer interrupt&lt;/code&gt; to control threads&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupt handler&lt;/code&gt; calls yield on behalf of running thread

&lt;ul&gt;
&lt;li&gt;Normally &lt;code&gt;interrupt handler&lt;/code&gt; returns to original call; here, it calls &lt;code&gt;thread_yield()&lt;/code&gt; instead&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Scheduler implementation

&lt;ul&gt;
&lt;li&gt;Thread structures maintained in &lt;code&gt;queues&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ready queue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Generally 1 per CPU&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Wait queue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Separate &lt;code&gt;wait queues&lt;/code&gt; for each type of event e.g. disk, console, timer, network, ...&lt;/li&gt;
&lt;li&gt;Generally shared by CPUs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exited queue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Generally shared by CPUs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scheduling functions&lt;/code&gt; move &lt;code&gt;threads&lt;/code&gt; between &lt;code&gt;queues&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Thread &amp;amp; Context Switch&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;context switch&lt;/code&gt; (&lt;code&gt;process switch&lt;/code&gt;) = &lt;code&gt;thread switch&lt;/code&gt; + &lt;code&gt;address space switch&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Address space switch&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Updating &lt;code&gt;MMU&amp;#39;s&lt;/code&gt; registers&lt;/li&gt;
&lt;li&gt;More expensive than &lt;code&gt;thread switch&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Context switch&lt;/code&gt; v.s. &lt;code&gt;Mode switch&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Unrelated; the former switch threads, the latter switch CPU modes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thread_yield&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;thread_yield() {
    enqueue_ready_queue(current)
    next = choose_next_thread()
    thread_switch(current, next)
}
thread_switch(current, next) {
    save_processor_state(current-&amp;gt;cpu_regs)
    ...
    restore_processor_state(next-&amp;gt;cpu_regs)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thread_init&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create the first (main) thread&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thread_create&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Allocate thread struct, stack memory, init PC, SP&lt;/li&gt;
&lt;li&gt;Add to ready queue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Thread Creation &amp;amp; Termination&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thread_exit&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Does not destroy itself; switch to another thread and it will destroy this thread&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread_destroy&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Actually destroy thread structure &amp;amp; stack of exited threads&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Kernel Threads v.s. User Threads&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Kernel Threads&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;User Threads&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Implementation scope&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Implemented in kernel&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Implemented in user program&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Virtualization&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Virtualize CPU&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Virtualize kernel thread&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Switching cost&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Must run kernel code, expensive&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;~procedure calls, less expensive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Scheduling policy&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Fixed&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Custom definition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Blocking system calls&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Switch to another kernel thread&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;All threads (associated with the same kernel thread) block -&amp;gt; overlap of I/O &amp;amp; computations impossible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Multiprocessors&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Threads use multiple CPUs concurrently&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Cannot use multiple CPUs consurrently&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Kernel level scheduler&lt;/code&gt; doesn&amp;#39;t know about &lt;code&gt;user threads&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;&lt;strong&gt;Quick Questions&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Is the OS code run in a separate process? A separate thread? Does it need a process structure?

&lt;ul&gt;
&lt;li&gt;OS code runs when a process makes a system call or when an interrupt occurs. In either case, the OS generally runs in the thread and address space context of the user process, and hence it does not require its own process or thread state.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is the address space of an OS?

&lt;ul&gt;
&lt;li&gt;The entire physical memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Related Articles&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.quora.com/How-does-thread-switching-differ-from-process-switching&quot;&gt;Thread Switching v.s. Process Switching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/os/2016/10/23/operating-system-threads.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/10/23/operating-system-threads.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>threads</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
  </channel>
</rss>
