<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MyCoon</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 12 Nov 2016 13:40:18 -0500</pubDate>
    <lastBuildDate>Sat, 12 Nov 2016 13:40:18 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Network Flow</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Flow Network Overview&lt;/li&gt;
&lt;li&gt;Maximum-Flow Problem

&lt;ol&gt;
&lt;li&gt;Residual Graph&lt;/li&gt;
&lt;li&gt;Implementation (Ford-Fulkerson Algorithm)&lt;/li&gt;
&lt;li&gt;Analysis&lt;/li&gt;
&lt;li&gt;Max-Flow Min-Cut Theorem&lt;/li&gt;
&lt;li&gt;Choosing Good Augmenting Paths&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Extensions to Max-Flow Problem

&lt;ol&gt;
&lt;li&gt;Circulations with Demands&lt;/li&gt;
&lt;li&gt;Circulations with Demands &amp;amp; Lower Bounds&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Bipartite Matching&lt;/li&gt;
&lt;li&gt;Image Segmentation&lt;/li&gt;
&lt;li&gt;Project Selection&lt;/li&gt;
&lt;li&gt;Baseball Elimination&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h3&gt;&lt;strong&gt;Flow Network Overview&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Capacities&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source nodes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sink nodes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Traffic&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graph representation&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;G = (V,E)
edge ce = capacity where ce &amp;gt;= 0
source node s ∈ V
sink node t ∈ V
internal nodes = all other nodes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Assumptions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No edge enters &lt;code&gt;s&lt;/code&gt; &amp;amp; no edge leaves &lt;code&gt;t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;At least 1 edge incident to each node&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; is int&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Flow conditions &amp;amp; notations&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f(e)&lt;/code&gt; satisfies:

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= f(e) &amp;lt;= ce&lt;/code&gt; for all edges&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum_e_into_v(f(e)) = sum_e_outof_v(f(e))&lt;/code&gt; for all internal nodes&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;v(f)&lt;/code&gt; denotes &lt;strong&gt;amount of flow generated at source&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sum_e_outof_s(f(e))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f_out(v)&lt;/code&gt; = &lt;code&gt;sum_e_outof_v(f(e))&lt;/code&gt;; &lt;code&gt;f_in(v)&lt;/code&gt; = &lt;code&gt;sum_e_into_v(f(e))&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Maximum-Flow Problem&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Given a flow network, find a flow of max possible value.&lt;/p&gt;

&lt;h4&gt;Residual Graph&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A graph indicating additional possible flow. If there is a path from source to sink in residual graph, then it is possible to add flow. &lt;/li&gt;
&lt;li&gt;Every edge of a residual graph has a value &lt;code&gt;residual capacity = original capacity of the edge - current flow&lt;/code&gt;. Residual capacity is basically the current capacity of the edge.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Implementation (Ford-Fulkerson Algorithm)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=-8MwfgB-lyM&quot;&gt;Video&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Initial flow &lt;code&gt;f&lt;/code&gt; = 0&lt;/li&gt;
&lt;li&gt;Find an augmenting path &lt;code&gt;P&lt;/code&gt; from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Augment the path &lt;code&gt;P&lt;/code&gt; with flow &lt;code&gt;f&lt;/code&gt;, return new flow &lt;code&gt;f&amp;#39;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Let &lt;code&gt;b = bottleneck(P,f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For each edge &lt;code&gt;e = (u,v)&lt;/code&gt; of &lt;code&gt;P&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;If &lt;em&gt;forward edge&lt;/em&gt;, &lt;code&gt;f(e) += b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If &lt;em&gt;backward edge&lt;/em&gt;, &lt;code&gt;f(e=(v,u)) -= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;return updated f&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Update &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;f&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Update residual graph &lt;code&gt;Gf&lt;/code&gt; to &lt;code&gt;Gf&amp;#39;&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Node set the same&lt;/li&gt;
&lt;li&gt;For each edge &lt;code&gt;e = (u,v)&lt;/code&gt; of &lt;code&gt;Gf&lt;/code&gt;, &lt;code&gt;f(e) &amp;lt; ce&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;Push &lt;code&gt;e = (u,v)&lt;/code&gt; with capacity &lt;code&gt;ce - f(e)&lt;/code&gt; (&lt;em&gt;forward edges&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Push &lt;code&gt;e&amp;#39; = (v,u)&lt;/code&gt; with capacity &lt;code&gt;f(e)&lt;/code&gt; (&lt;em&gt;backward edges&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Repeat until no path found&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;augment(f,P):
    Let b = bottleneck(P,f) 
    For each edge (u,v) ∈ P:
        If e = (u,v) is a forward edge: 
            increase f(e) in G by b
        Else: # ((u, v) is a backward edge, and let e = (v, u)) 
            decrease f(e) in G by b
    Return f

Max-Flow():
    Initially f(e) = 0 for all e in G
    While there is an s-t path in the residual graph Gf:
        Let P be a simple s-t path in Gf
        f' = augment(f,P)
        Update f to be f'
        Update the residual graph Gf to be Gf'
    Return f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Analysis&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Termination

&lt;ul&gt;
&lt;li&gt;At every intermediate stage of the Ford-Fulkerson Algorithm, the flow values {&lt;code&gt;f(e)&lt;/code&gt;} and the &lt;strong&gt;residual capacities in Gf are integers&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;The flow value strictly increases when we apply an augmentation, since we add &lt;code&gt;bottleneck &amp;gt; 0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Upper bound: &lt;code&gt;f_out(s)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Hence the algorithm runs for at most &lt;code&gt;f_out(s)&lt;/code&gt; iterations.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Runtime

&lt;ul&gt;
&lt;li&gt;Let &lt;code&gt;m = |E|&lt;/code&gt;, &lt;code&gt;n = |V|&lt;/code&gt;, &lt;code&gt;C = f_out(s)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m &amp;gt;= n/2&lt;/code&gt; since all nodes have at least 1 incident edge, so &lt;code&gt;O(m+n) = O(m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BFS/DFS: &lt;code&gt;O(m+n) = O(m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;augment&lt;/code&gt;: &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Build new residual graph: &lt;code&gt;O(m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Overall &lt;code&gt;O(mC)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Max-Flow Min-Cut Theorem&lt;/h4&gt;

&lt;p&gt;In every flow network, the maximum value of an s-t flow is equal to the minimum capacity of an s-t cut.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cut

&lt;ul&gt;
&lt;li&gt;Divide nodes into 2 sets &lt;code&gt;A&lt;/code&gt; &amp;amp; &lt;code&gt;B&lt;/code&gt; s.t. &lt;code&gt;s ∈ A&lt;/code&gt; and &lt;code&gt;t ∈ B&lt;/code&gt;. Any flow going from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; must cross from &lt;code&gt;A&lt;/code&gt; into &lt;code&gt;B&lt;/code&gt; at some point and use up some of the edge capacity from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cut&lt;/strong&gt; puts bound on max flow

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minimum cut&lt;/strong&gt;: the minimum capacity of any division, which equals the max flow&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Facts&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Let &lt;code&gt;f&lt;/code&gt; be any s-t flow, and &lt;code&gt;(A, B)&lt;/code&gt; any s-t cut. Then&lt;br&gt;
&lt;code&gt;v(f) = f_out(A) − f_in(A)&lt;/code&gt; and&lt;br&gt;
&lt;code&gt;v(f) = f_in(B) − f_out(B)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;v(f) = f_out(s) - f_in(s)
     = sum_v_in_A(f_out(v) - f_in(v)) # f_out(v) - f_in(v) = 0 for internal nodes
     = sum_e_outof_A(f(e)) - sum_e_into_A(f(e))
     = f_out(A) - f_in(A)
f_out(A) = f_in(B); f_in(A) = f_out(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let &lt;code&gt;f&lt;/code&gt; be any s-t flow, and &lt;code&gt;(A,B)&lt;/code&gt; any s-t cut. Then&lt;br&gt;
&lt;code&gt;v(f) &amp;lt;= c(A,B)&lt;/code&gt;, where &lt;code&gt;c(A,B) = sum_e_outof_A(ce)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;v(f) = f_out(A) − f_in(A)
     ≤ f_out(A) # f_in(A) &amp;gt;= 0
     = sum_e_outof_A(f(e))
     ≤ sum_e_outof_A(ce)
     = c(A,B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; Any flow is upper-bounded by the capacity of every cut&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let &lt;code&gt;f&lt;/code&gt; be an s-t flow s.t. no s-t path in the residual graph &lt;code&gt;Gf&lt;/code&gt;. Then there is an s-t cut &lt;code&gt;(A*,B*)&lt;/code&gt; in &lt;code&gt;G&lt;/code&gt; where &lt;code&gt;v(f) = c(A*,B*)&lt;/code&gt;.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Let A* be a set of nodes in G where there is a s-v path in Gf
Let B* = V - A*
v(f) = f_out(A*) − f_in(A*)
     = sum_e_outof_A*(f(e)) − sum_e_into_A*_f(e)
     = sum_e_outof_A*(ce) - 0 # f(e) = ce
     = c(A*,B*)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The flow &lt;code&gt;f&lt;/code&gt; returned by Ford-Fulkerson is max flow.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Let f* be max flow, (A*,B*) be min cut
Then there exists a flow f s.t. v(f) = c(A,B) by 3.
And by 2., v(f) = c(A,B) &amp;lt;= c(A*,B*)
Hence A = A*, B = B* because c(A*,B*) should be minimum
And by 2., v(f*) &amp;lt;= c(A*,B*) = v(f)
Hence f = f* because v(f*) should be maximum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Given a max flow, we can compute an s-t min cut in &lt;code&gt;O(m)&lt;/code&gt; time by constructing the residual graph and perform BFS/DFS to find &lt;code&gt;A*&lt;/code&gt; &amp;amp; &lt;code&gt;B*&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If all capacities in the flow network are integers, then there is a max flow &lt;code&gt;f&lt;/code&gt; where every flow value &lt;code&gt;f(e)&lt;/code&gt; is an integer.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Notes&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;With &lt;strong&gt;rational numbers&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;Multiply all by least common multiple of all capacities&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;With &lt;strong&gt;real numbers&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;May not terminate, since the progress we make at each iteration can be small&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Max-flow min-cut theorm&lt;/strong&gt; still holds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Choosing Good Augmenting Paths&lt;/h4&gt;

&lt;h5&gt;Idea 1&lt;/h5&gt;

&lt;p&gt;Find the path with &lt;code&gt;large bottleneck capacity&lt;/code&gt;.&lt;br&gt;
Maintain a &lt;strong&gt;scaling parameter &lt;code&gt;sp&lt;/code&gt;&lt;/strong&gt; and look for paths having bottleneck of &lt;em&gt;at least &lt;code&gt;sp&lt;/code&gt;&lt;/em&gt;.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Implementation&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Scaling Max-Flow():
    Initially f(e) = 0 for all e in G
    Initially set sp = largest power of 2 &amp;lt;= max_e_outof_s(ce) 

    While sp &amp;gt;= 1:
        While there is an s-t path in the graph Gf(sp):
            Let P be a simple s-t path in Gf(sp)
                f' = augment(f,P)
                Update f to be f'
                Update Gf(sp)
        sp /= 2
    Return f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Outer &lt;code&gt;While&lt;/code&gt; loop (scaling phase): at most &lt;code&gt;1 + logC&lt;/code&gt; where &lt;code&gt;C = sum_e_outof_s(ce)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;During the scaling phase, each augmentation increases the flow by at least &lt;code&gt;sp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;v(f) &amp;gt;= max flow - m*sp&lt;/code&gt; where &lt;code&gt;f = flow at the end of scaling phase&lt;/code&gt; and &lt;code&gt;m = |E|&lt;/code&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;f(e) &amp;gt; ce - sp for e = (u,v) which u ∈ A and v ∈ B
f(e) ≥ sp for e = (u,v) which u ∈ B and v ∈ A

v(f) = sum_e_outof_A(f(e)) − sum_e_into_A(f(e))
     ≥ sum_e_outof_A(ce - sp) - sum_e_into_A(sp)
     = c(A,B) - m*sp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;# of augmentations in a scaling phase is at most &lt;code&gt;2m&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;v(f*) &amp;lt;= v(f_prev) + m*sp = v(f_prev) + 2m*sp_prev
Each augmentation increases the flow by &amp;gt;= sp_prev
So at most 2m augmentations
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Augmentation: &lt;code&gt;O(m)&lt;/code&gt; time; &lt;code&gt;1 + logC&lt;/code&gt; scaling phases; &lt;code&gt;2m&lt;/code&gt; augmentations each phase =&amp;gt; &lt;code&gt;O(m^2 logC)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scaling: polynomial in size of input (# of edges &amp;amp; numerical representation of capacities)&lt;br&gt;
Original: polynomial in magnatude of capacities&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Idea 2&lt;/h5&gt;

&lt;p&gt;Choose path with &lt;strong&gt;fewest number of edges&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;Extensions to Max-Flow Problem&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;Circulations with Demands&lt;/h4&gt;

&lt;p&gt;Multiple sources &amp;amp; sinks with fixed supply/demand values.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Demands

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dv &amp;gt; 0&lt;/code&gt;: &lt;code&gt;v&lt;/code&gt; wish to receive &lt;code&gt;dv&lt;/code&gt; more flow than it sends out (&lt;strong&gt;sink&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dv &amp;lt; 0&lt;/code&gt;: &lt;code&gt;v&lt;/code&gt; wish to send out &lt;code&gt;dv&lt;/code&gt; more flow than it receives (&lt;strong&gt;source&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dv = 0&lt;/code&gt;: not source nor sink&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Conditions

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= f(e) &amp;lt;= ce&lt;/code&gt; for all edges&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum_e_into_v(f(e)) = sum_e_outof_v(f(e))&lt;/code&gt; for all internal nodes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All demands satisfied&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Total supply = total demand&lt;br&gt;
&lt;code&gt;sum_v(dv) = sum_v(f_in(v)) - sum_v(f_out(v)) = 0&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sum_v_dv&amp;gt;0(dv) = sum_v_dv&amp;lt;0(-dv)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Conversion to Max-Flow Problem

&lt;ul&gt;
&lt;li&gt;Create super-source &lt;code&gt;s*&lt;/code&gt; connecting each node in &lt;code&gt;S&lt;/code&gt;; create super-sink &lt;code&gt;t*&lt;/code&gt; connecting each node in &lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A feasible circulation is found iff max s*-t* flow has value &lt;code&gt;D&lt;/code&gt;, where &lt;code&gt;D = max capaxity from s*/to t*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Graph G has a feasible circulation with demands &lt;code&gt;{dv}&lt;/code&gt; if and only if for all cuts (A,B):&lt;br&gt;
&lt;code&gt;sum_v_in_B(dv) &amp;lt;= c(A,B)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Circulations with Demands &amp;amp; Lower Bounds&lt;/h4&gt;

&lt;p&gt;Enforce flow to use certain edges - place &lt;strong&gt;lower bounds&lt;/strong&gt; on edges.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Conditions

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;le &amp;lt;= f(e) &amp;lt;= ce&lt;/code&gt; for all edges, where &lt;code&gt;le&lt;/code&gt; is the lower bound&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum_e_into_v(f(e)) = sum_e_outof_v(f(e))&lt;/code&gt; for all internal nodes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All demands satisfied&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Total supply = total demand&lt;br&gt;
&lt;code&gt;sum_v(dv) = sum_v(f_in(v)) - sum_v(f_out(v)) = 0&lt;/code&gt;&lt;br&gt;
&lt;code&gt;sum_v_dv&amp;gt;0(dv) = sum_v_dv&amp;lt;0(-dv)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Conversion to Max-Flow Problem

&lt;ul&gt;
&lt;li&gt;Let capacities of edges be &lt;code&gt;ce - le&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Let demands of nodes be &lt;code&gt;dv - Lv&lt;/code&gt;, where &lt;code&gt;Lv = sum_e_into_v(le) - sum_e_outof_v(le)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;There is a feasible circulation in &lt;code&gt;G&lt;/code&gt; iff there is a feasible circulation in &lt;code&gt;G&amp;#39;&lt;/code&gt;, where &lt;code&gt;G&lt;/code&gt; is the original graph, &lt;code&gt;G&amp;#39;&lt;/code&gt; is the converted one&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Bipartite Matching&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Max-flow problem property: &lt;strong&gt;if all edge capacities are integers, then the optimal flow found by our algorithm is integral.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Idea

&lt;ul&gt;
&lt;li&gt;Connect nodes from 1 set to &lt;code&gt;s&lt;/code&gt; with capacity 1&lt;/li&gt;
&lt;li&gt;Connect nodes from another set to &lt;code&gt;t&lt;/code&gt; with capacity 1&lt;/li&gt;
&lt;li&gt;Find max flow&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Image Segmentation&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Separate the foreground and background of an image.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Goal&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let &lt;code&gt;ai&lt;/code&gt; be likelihood to foreground for pixel &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;bi&lt;/code&gt; be likelihood to background for pixel &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;pij&lt;/code&gt; be separation penalty&lt;/li&gt;
&lt;li&gt;Maximize &lt;code&gt;q(A,B) = sum_i_in_A(ai) + sum_j_in_B(bi) - sum_(i,j)_in_diff_set(pij)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 problems&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The goal is seeking to maximize an objective

&lt;ul&gt;
&lt;li&gt;Maximize&lt;br&gt;
&lt;code&gt;q(A,B) = sum_i_in_A(ai) + sum_j_in_B(bi) - sum_(i,j)_in_diff_set(pij)&lt;/code&gt;&lt;br&gt;
&amp;lt;=&amp;gt; Minimize&lt;br&gt;
&lt;code&gt;q&amp;#39;(A,B) = sum_i_in_A(bi) + sum_j_in_B(ai) + sum_(i,j)_in_diff_set(pij)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;No source &amp;amp; sink

&lt;ul&gt;
&lt;li&gt;Create super-source &lt;code&gt;s*&lt;/code&gt; for foreground &amp;amp; super-sink &lt;code&gt;t*&lt;/code&gt; for background&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Undirected graph

&lt;ul&gt;
&lt;li&gt;Model neighboring pair with 2 directed edges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graph representation&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Edges (s,j), where j ∈ B; capacity = aj
Edges (i,t), where i ∈ A; capacity = bi
Edges (i,j), where i ∈ A and j ∈ B; capacity = p_ij

c(A,B) = q'(A,B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Project Selection&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;A set of projects &lt;code&gt;P&lt;/code&gt; has &lt;em&gt;revenue&lt;/em&gt; &lt;code&gt;pi&lt;/code&gt; being either positive or negative. Certain projects have &lt;em&gt;prerequisites&lt;/em&gt; for other projects. Find a set of projects that maximizes the profits.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Graph representation&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Edges (s,i), where pi &amp;gt; 0; capacity = pi
Edges (i,t), where pi &amp;lt; 0; capacity = -pi
Edges (i,j), where i depends on j; capacity = inf

Max flow C = sum_i_pi&amp;gt;0(pi)
Min cut (A',B'), where if i ∈ A has edge (i,j), j ∈ A
Set of projects: A'-{s}, optimal
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimality analysis&lt;/p&gt;

&lt;p&gt;Prove the min cut in &lt;code&gt;G&amp;#39;&lt;/code&gt; determines the optimum set of projects.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Capacity of cut &lt;code&gt;(A&amp;#39;,B&amp;#39;)&lt;/code&gt; is &lt;code&gt;c(A&amp;#39;,B&amp;#39;) = C − sum_i_in_A(pi)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;(A&amp;#39;, B&amp;#39;)&lt;/code&gt; is a cut with capacity &amp;lt;= C, then set &lt;code&gt;A = A&amp;#39; − {s}&lt;/code&gt; satisfies the precedence constraints&lt;/li&gt;
&lt;li&gt;Hence &lt;code&gt;c(A&amp;#39;,B&amp;#39;) = C - profit(A)&lt;/code&gt; and small cuts imply big profits&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Baseball Elimination&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;A set of teams &lt;code&gt;S&lt;/code&gt;, each has &lt;code&gt;wi&lt;/code&gt; wins. Some games &lt;code&gt;g_xy&lt;/code&gt; left. Check if team &lt;code&gt;z&lt;/code&gt; has been eliminated.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Averaging argument&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Suppose z has indeed been eliminated. 
Then:

- z can finish with at most m wins.
- There is a set of teams T ⊆ S s.t. 
    sum_x_in_T(wx) + sum_x,y_in_T(gxy) &amp;gt; m|T|

Hence one of the teams in T must end with &amp;gt; m wins.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Graph representation&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Let u_xy be some games left between x &amp;amp; y
Let m be w_z + remaining_games_of_z
Let g* be total number of games left

Edges (s,u_xy), capacity = g_xy
Edges (u_xy,vx), capacity = inf
Edges (vx,t), capacity = m - wx

Eliminate x iff max flow in G &amp;lt; g* # else after g* games every team will have wins not exceeding m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Analysis&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If both &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; belong to &lt;code&gt;T&lt;/code&gt;, then &lt;code&gt;u_xy ∈ A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(A, B)&lt;/code&gt; is a min cut: &lt;code&gt;u_xy ∈ A&lt;/code&gt; iff both &lt;code&gt;x, y ∈ T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;T&lt;/code&gt; can be used in the averaging argument   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;c(A,B) = sum_x_in_T(m-wx) + sum_{x,y}_!in_T(g_xy)
       = m|T| - sum_x_in_T(wx) + (g* - sum_x,y_in_T(g_xy))
m|T| - sum_x_in_T(wx) - sum_x,y_in_T(g_xy) &amp;lt; 0 # c(A,B) = g' &amp;lt; g*

sum_x_in_T(wx) + sum_x,y_in_T(g_xy) &amp;gt; m|T|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/&quot;&gt;GeeksForGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 09 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/09/network-flow.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/09/network-flow.html</guid>
        
        <category>network flow</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Data Stucture Notes</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;p&gt;Data stucture notes for coding competitions.&lt;/p&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;BST&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Dictionary&lt;/li&gt;
&lt;li&gt;Insertion, deletion, searching &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lower_bound&lt;/code&gt;, &lt;code&gt;upper_bound&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Find element in range&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1613&quot;&gt;http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1613&lt;/a&gt;
&lt;a href=&quot;http://poj.org/problem?id=2418&quot;&gt;http://poj.org/problem?id=2418&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Monotone Queue&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;3 basic operations

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt; in &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt; in &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max&lt;/code&gt;/&lt;code&gt;min&lt;/code&gt; in &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Insert(k):
    while (queue not empty) and (tail element &amp;gt;= k):
        discard tail
    append k to tail

Min():
    return head of queue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2823&quot;&gt;http://poj.org/problem?id=2823&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Block List&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;Partition indices into &lt;code&gt;O(sqrt(n))&lt;/code&gt; segments, each of length &lt;code&gt;O(sqrt(n))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3 basic operations

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Range operation on &lt;code&gt;[i,j]&lt;/code&gt; in &lt;code&gt;O(sqrt(n))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Insert(x):
    # invariant: each segment has elements &amp;gt;= L and &amp;lt; 3L; OR only one segment &amp;lt; 3L

    locate segment S # O(sqrt(n))
    brute force insertion on S # O(L)
    if size(S) == 3L:
        evenly split into 2 segments

Delete(x):
    locate segment S # O(sqrt(n))
    brute force deletion on S # O(L)
    if size(S) == L and S has adjacent segment:
        combine 2 segments
        evenly split into 2 segments

# range operation
# change &amp;amp; sum as example

## change [i,j] to x
Change(i, j, x):
    if i == l and j == r: # O(1)
        b = true
        y = x
        s = x * (r - l + 1)
    else: # O(L)
        if b == true:
            set every element in [l,r] to y
            b = false
        set every element in [i,j] to x
        calculate s

## query [i,j]
Query(i, j):
    if i == l and j == r: # O(1)
        return s
    else: # O(L)
        if b == ture:
            set every element in [l,r] to y
            b = false
        set every element in [i,j] to x
        calculate s
        return s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=3580&quot;&gt;http://poj.org/problem?id=3580&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Merge-find Set&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;A ground set &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A collection &lt;code&gt;C&lt;/code&gt; of subsets of &lt;code&gt;S&lt;/code&gt; where 2 different elements in &lt;code&gt;C&lt;/code&gt; are disjoint&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3 basic operations

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt;: union 2 subsets&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find&lt;/code&gt;: find the subset a specific elememt is in&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;: test where 2 elements are in the same subset&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Implementation (linear)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;P: P[i] = parent of i in S
F(P): forest difined by P

Find(x):
    while P[x] != x:
        x = P[x]
    return x # root

Union(x):
    P[Find(x)] = Find(y)

Test(x, y):
    return Find(x) == Find(y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Implementation (optimized)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;R: rank of element; init R = {0}

Find(x): # path compression
    if P[x] != x:
        P[x] = Find(P[x])
    return x

Union(x): # union by rank
    x' = Find(x)
    y' = Find(y)
    if R[x'] &amp;lt; R[y']:
        P[x'] = y'
    elif R[x'] &amp;gt; R[y']:
        P[y'] = x'
    else:
        P[x'] = y'
        R[y']++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Extension 1: Maintaining the Difference&lt;/h3&gt;

&lt;p&gt;For each element &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;V[i]&lt;/code&gt; is the underlying unknown integer. Information &lt;code&gt;V[j] - V[i] = k&lt;/code&gt; comes.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Problem

&lt;ol&gt;
&lt;li&gt;Consistent with previously known information?&lt;/li&gt;
&lt;li&gt;If consistent, record the information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V[j] - V[i]&lt;/code&gt; uniquely determined?&lt;/li&gt;
&lt;li&gt;If unique, answer the value&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;D: difference; D[i] = V[i] - V[P[i]]; init D = {0}

Find(x):
    if P[x] != x:
        (P[x],d) = Find(P[x])
        D[x] += d
    return (x, D[x])

Union(i, j, k): # V[i] - V[j] = k
    (x',D[i]) = Find(i)
    (y',D[j]) = Find(j)
    if R[x'] &amp;lt; R[y']:
        P[x'] = y'
        D[x'] = D[j] - D[i] - k
    elif R[x'] &amp;gt; R[y']:
        P[y'] = x'
        D[y'] = D[i] - D[j] - k
    else:
        P[x'] = y'
        D[x'] = D[j] - D[i] - k
        R[y']++r

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Apply the data structure&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Provided &lt;code&gt;V[j] - V[i] = k&lt;/code&gt;: &lt;code&gt;Union(i,j,k)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Answer &lt;code&gt;V[j] - V[i]&lt;/code&gt;: if &lt;code&gt;Test(i,j)&lt;/code&gt; then &lt;code&gt;return D[j] - D[i]&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3038&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=3038&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Extension 2: XOR&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=3234&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=3234&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/competition/2016/11/09/data-structure-notes.html</link>
        <guid isPermaLink="true">/blog/notes/competition/2016/11/09/data-structure-notes.html</guid>
        
        <category>competition</category>
        
        <category>data structure</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Competition</category>
        
      </item>
    
      <item>
        <title>Competition Notes</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;p&gt;Notes for coding competitions.&lt;/p&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Complexity&lt;/h2&gt;

&lt;h3&gt;TLE&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;10^8&lt;/code&gt; int operations/&lt;code&gt;10^7&lt;/code&gt; floating point operations in a for loop run in around &lt;strong&gt;1 sec&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;n = 20: exponential ok&lt;/li&gt;
&lt;li&gt;n = 100: &lt;code&gt;O(n^3)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 1000: &lt;code&gt;O(n^2)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^4: &lt;code&gt;n*polylog(n)&lt;/code&gt; ^ &lt;code&gt;n*sqrt(n)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^5: &lt;code&gt;nlogn&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^6: &lt;code&gt;O(n)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^9: &lt;code&gt;O(logn)&lt;/code&gt; ok&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Online Resource&lt;/h2&gt;

&lt;h3&gt;Data Structure&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://acm.timus.ru/problemset.aspx?space=1&amp;amp;tag=structure&quot;&gt;Timus OJ&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/competition/2016/11/09/competition-notes.html</link>
        <guid isPermaLink="true">/blog/notes/competition/2016/11/09/competition-notes.html</guid>
        
        <category>competition</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Competition</category>
        
      </item>
    
      <item>
        <title>Competition Cheatsheet</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;p&gt;Cheatsheet for coding competitions.&lt;/p&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Complexity Limit&lt;/h2&gt;

&lt;h3&gt;TLE&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;10^8&lt;/code&gt; int operations/&lt;code&gt;10^7&lt;/code&gt; floating point operations in a for loop run in around &lt;strong&gt;1 sec&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;n = 20: exponential ok&lt;/li&gt;
&lt;li&gt;n = 100: &lt;code&gt;O(n^3)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 1000: &lt;code&gt;O(n^2)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^4: &lt;code&gt;n*polylog(n)&lt;/code&gt; ^ &lt;code&gt;n*sqrt(n)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^5: &lt;code&gt;nlogn&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^6: &lt;code&gt;O(n)&lt;/code&gt; ok&lt;/li&gt;
&lt;li&gt;n = 10^9: &lt;code&gt;O(logn)&lt;/code&gt; ok&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;STL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt; in &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;priority_queue&lt;/code&gt; in &lt;code&gt;&amp;lt;queue&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort&lt;/code&gt; in &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;binary_search&lt;/code&gt; in &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next_permutation&lt;/code&gt; in &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lower_bound&lt;/code&gt;, &lt;code&gt;upper_bound&lt;/code&gt; in &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt;, &lt;code&gt;multiset&lt;/code&gt; in &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;multimap&lt;/code&gt; in &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 09 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/competition/2016/11/09/competition-cheatsheet.html</link>
        <guid isPermaLink="true">/blog/notes/competition/2016/11/09/competition-cheatsheet.html</guid>
        
        <category>competition</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Competition</category>
        
      </item>
    
      <item>
        <title>Dynamic Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Shortest Paths in DAGs&lt;/li&gt;
&lt;li&gt;Longest Increasing Subsequences&lt;/li&gt;
&lt;li&gt;Edit Distance&lt;/li&gt;
&lt;li&gt;Knapsack Problem&lt;/li&gt;
&lt;li&gt;Chain Matrix Multiplication&lt;/li&gt;
&lt;li&gt;Shortest Paths

&lt;ol&gt;
&lt;li&gt;Shortest Reliable Paths&lt;/li&gt;
&lt;li&gt;All-Pairs Shortest Paths&lt;/li&gt;
&lt;li&gt;The Traveling Salesman Problem&lt;/li&gt;
&lt;li&gt;Independent Sets in Trees&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;ul&gt;
&lt;li&gt;Comparison to &lt;em&gt;divide-and-conquer&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Divide-and-conquer&lt;/strong&gt;: subproblems &lt;em&gt;substantially smaller&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DP&lt;/strong&gt;: subproblems &lt;em&gt;slightly smaller&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;So &lt;strong&gt;recursion&lt;/strong&gt; works well with &lt;em&gt;DAC&lt;/em&gt; but not &lt;em&gt;DP&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Define a collection of subproblems which follows:

&lt;ul&gt;
&lt;li&gt;There is an &lt;strong&gt;ordering&lt;/strong&gt; on the subproblems, and a &lt;strong&gt;relation&lt;/strong&gt; that shows how to solve a subproblem given the answers to &amp;quot;smaller&amp;quot; subproblems, that is, subproblems that appear earlier in the ordering.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Relation with DAGs

&lt;ul&gt;
&lt;li&gt;Node: subproblem&lt;/li&gt;
&lt;li&gt;Incoming edges: subproblems needed to be pre-solved (precedence constraints)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Common subproblems&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1.  
    O(n)
    [x1, x2, ..., xi], ..., xn
2. 
    O(mn)
    [x1, x2, ..., xi], ..., xn
    [y1, y2, ..., yj], ..., ym
3. 
    O(n^2)
    x1, ..., [xi, ..., xj], ..., xn
4. 
                x1
               /  \
              x2  x3
             .       .
            .         .
           xi   ...   xn

    Subproblem - rooted subtree
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Shortest Paths in DAGs&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DAG&lt;/strong&gt;: directed acyclic graph&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nodes can be &lt;strong&gt;linearized&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    A -&amp;gt; B                  __________
  ➚        ➘               ➚           ➘
S   ↑    ↓   D      S -&amp;gt; C -&amp;gt; A -&amp;gt; B -&amp;gt; D -&amp;gt; E
  ➘        ➚         ➘_______➚      ➘_______➚
    C -&amp;gt; D
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;initialize all dist(·) values to ∞ 
dist(s) = 0

for each v ∈ V\{s}, in linearized order:
    dist(v) = min_(u,v)∈E { dist(u) + l(u,v) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Longest Increasing Subsequences&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Given a sequence of numbers, find a subset taken in order in which the numbers are getting strictly larger.&lt;/p&gt;

&lt;h4&gt;Viewing LIS as DAG&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Node &lt;code&gt;i&lt;/code&gt;: element &lt;code&gt;i&lt;/code&gt; in the sequence&lt;/li&gt;
&lt;li&gt;Directed edge &lt;code&gt;(i,j)&lt;/code&gt;: if element &lt;code&gt;j&lt;/code&gt; &amp;gt; element &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;L(j) = length of LIS ending at j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;L(j) = 1 + max{L(i): (i,j) ∈ E}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for j = 1..n:
    L(j) = 1 + max{L(i): (i,j) ∈ E}
return max_j L(j)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(|E|) = O(n^2)&lt;/code&gt; &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;O(nlogn) Implementation&lt;/h4&gt;

&lt;p&gt;Binary search. Keep indices for reconstruction.  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/&quot;&gt;GeeksForGeeks&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming&quot;&gt;StackOverflow&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;Edit Distance&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;For 2 strings, the &lt;em&gt;cost&lt;/em&gt; of an alignment between them is the # of &lt;em&gt;edits&lt;/em&gt; (insertion, deletion, substitution) needed to transform string 1 to string 2. Find the &lt;em&gt;min&lt;/em&gt; cost.  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://web.stanford.edu/class/cs262/presentations/lecture3.pdf&quot;&gt;Hirscberg&amp;#39;s Algorithm&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Strings &lt;code&gt;x, y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;E(i,j) = edit distance between x[1..i] &amp;amp; y[1..j]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;E(i,j) = min{ 1+E(i−1,j), 1+E(i,j−1), diff(i,j)+E(i−1,j−1) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for i = 0..m: 
    E(i,0) = i
for j = 1..n: 
    E(0,j) = j
for i = 1..m: 
    for j = 1..n:
        E(i,j) = min{ E(i − 1,j) + 1, E(i,j − 1) + 1, E(i − 1,j − 1)+diff(i,j) }
return E(m,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(mn)&lt;/code&gt; &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Space Efficient Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# O(m) space
Space-Efficient-Alignment(X,Y):
    Array B[0...m,0...1]
    Initialize B[i,0]=iδ for each i (just as in column 0 of A) 

    For j = 1,...,n
        B[0,1] = jδ # corresponds to entry A[0,j] 
        For i = 1,...,m
            B[i,1]= min[αxiyj+B[i−1, 0], δ+B[i−1,1], δ+B[i,0]]
        Endfor
        Move column 1 of B to column 0 to make room for next iteration:
            Update B[i, 0]= B[i, 1] for each i 
    Endfor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To backtrack:  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. Let `f(i,j)` denote optimal path from `(0,0)` to `(i,j)`, `g(i,j)` denote optimal path from `(i,j)` to `(m,n)`
2. Find index `q` that minimizes `f(q,k) + g(q,k)`
3. Divide problem into `(0,0)` to `(q,n/2)` &amp;amp; `(q+1,n/2+1)` to `(m,n)`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Backward-Space-Efficient-Alignment(X,Y):
    # start from the opposite corner
    # similar to Space-Efficient-Alignment, but now B[i,1]= min[αxiyj+B[i+1, 0], δ+B[i+1,1], δ+B[i,0]]

Divide-and-Conquer-Alignment(X,Y):
    Let m be the number of symbols in X 
    Let n be the number of symbols in Y 
    If m≤2 or n≤2 then
        Compute optimal alignment using Alignment(X,Y) 

    Call Space-Efficient-Alignment(X,Y[1:n/2])
    Call Backward-Space-Efficient-Alignment(X,Y[n/2+1:n]) 

    Let q be the index minimizing f(q,n/2)+g(q,n/2)
    Add (q,n/2) to global list P 

    Divide-and-Conquer-Alignment(X[1:q],Y[1:n/2]) 
    Divide-and-Conquer-Alignment(X[q+1:m],Y[n/2+1:n]) 
    Return P
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Knapsack Problem&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; items of weight &lt;code&gt;w1, ..., wn&lt;/code&gt; and value &lt;code&gt;v1, ..., vn&lt;/code&gt;, what is the most valuable combination of items that the total weight is at most &lt;code&gt;W&lt;/code&gt; pounds?&lt;/p&gt;

&lt;h4&gt;Allows Repetition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;K(w) = max value achievable with knapsack of capacity w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;K(w) = max_i:wi&amp;lt;=w { K(w−wi)+vi }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;K(0) = 0
for w = 1 to W:
    K(w) = max { K(w−wi)+vi: wi ≤w } 
return K(W)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;h4&gt;Memoization&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;A hash table, initially empty, holds values of K(w) indexed by w
function knapsack(w):
  if w is in hash table: 
      return K(w) 
  K(w) = max { knapsack(w−wi) + vi: wi≤w } 
  insert K(w) into hash table, with key w 
  return K(w)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only store information needed, unlike DP storing all&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;No Repetition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;K(w,j) = max value achievable with knapsack of capacity w and items 1..j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;K(w,j) = max { K(w−wj,j-1) + vj, K(w,j-1) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Initialize all K(0, j) = 0 and all K(w, 0) = 0 
for j = 1 to n:
    for w = 1 to W:
        if wj &amp;gt; w: 
            K(w,j) = K(w,j−1)
        else: 
            K(w,j) = max { K(w,j−1),K(w−wj,j−1) + vj }
return K(W,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Chain Matrix Multiplication&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Four matrices &lt;code&gt;A x B x C x D&lt;/code&gt;, find the way of chaining that uses the least computations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Abstraction&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Binary trees&lt;/strong&gt;: &lt;code&gt;node = product of children&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Ex.
        []
       /  \
      []   D
     /  \
    []   C
   /  \
  A    B    

(((A x B) x C) x D)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Subproblem:&lt;br&gt;
&lt;code&gt;C(i,j) = min cost of multiplying Ai..Aj&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;C(i,j) = min_i&amp;lt;=k&amp;lt;j { C(i,k) + C(k+1,j) + m_i-1 * mk * mj }&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;fori = 1 to n: 
    C(i,i) = 0 
for s=1 to n−1:
    for i=1 to n−s: 
        j = i + s
        C(i,j) = min { C(i,k) + C(k+1,j) + m_i−1 * mk * mj: i ≤ k &amp;lt; j } 
return C(1,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(n^3)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Shortest Paths&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;Shortest Reliable Paths&lt;/h4&gt;

&lt;p&gt;Find the shortest path in a graph from &lt;code&gt;s&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; using at most &lt;code&gt;k&lt;/code&gt; edges.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;dist(v,i) = length of shortest path from s to v using i edges&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;dist(v,i) = min_(u,v)∈E { dist(u,i−1) + l(u,v) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Initial values:&lt;br&gt;
&lt;code&gt;dist(v, 0) = infinity, dist(s, 0) = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;All-Pairs Shortest Paths&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Floyd-Warshall algorithm&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;dist(i,j,k) = length of shortest path from i to j using only nodes {1..k}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;dist(i,j,k) = min { dist(i,k,k−1) + dist(k,j,k−1), dist(i,j,k−1) }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for i = 1 to n: 
    for j = 1 to n:
        dist(i,j,0) = ∞
for all (i,j) ∈ E: 
    dist(i,j,0) = l(i,j)
for k = 1 to n: 
    for i = 1 to n:
        for j = 1 to n:
            dist(i,j,k) = min{ dist(i,k,k−1) + dist(k,j,k−1), dist(i,j,k−1) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;The Traveling Salesman Problem&lt;/h4&gt;

&lt;p&gt;Find a min cost path in a graph that starts and end at 1 and goes through all nodes exactly once.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;C(S,j) = length of shortest path visiting nodes in S exactly once, starting at 1 and ending at j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblems:&lt;br&gt;
&lt;code&gt;C(S,j) = min_i∈S:i!=j { C(S-{j}, i) + dij }&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pseudocode&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;C({1},1) = 0
for s = 2 to n:
    for all subsets S ⊆ {1..n} of size s and containing 1: 
        C(S,1) = ∞
        for all j ∈ S, j != 1: 
            C(S,j) = min { C(S−{j},i) + dij: i∈S,i!=j}
return min_j { C({1..n},j) + dj1 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runtime: &lt;code&gt;O(n^2*2^n)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2^n*n&lt;/code&gt; subproblems, each &lt;code&gt;O(n)&lt;/code&gt; time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Independent Sets in Trees&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Independent sets&lt;/em&gt;: for graph &lt;code&gt;G = (V,E)&lt;/code&gt;, a subset of nodes &lt;code&gt;S ⊂ V&lt;/code&gt; is an independent set if there are no edges between them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Subproblem:&lt;br&gt;
&lt;code&gt;I(u) = size of largest independent set of subtree hanging from u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution to subproblem:&lt;br&gt;
&lt;code&gt;u&lt;/code&gt; is either included in the largest independent set or not&lt;br&gt;
&lt;code&gt;I(u) = max { 1 + sum_grandchildren_w_of_u I(w), sum_children_w_of_u I(w) }&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 02 Nov 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/algorithm/2016/11/02/dynamic-programming.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/02/dynamic-programming.html</guid>
        
        <category>DP</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Parallelism Overview

&lt;ol&gt;
&lt;li&gt;Standard Models of Parallelism&lt;/li&gt;
&lt;li&gt;Speedup&lt;/li&gt;
&lt;li&gt;Dependence&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Threads &amp;amp; Processes

&lt;ol&gt;
&lt;li&gt;Pthreads&lt;/li&gt;
&lt;li&gt;Synchronization&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Data Parallelism

&lt;ol&gt;
&lt;li&gt;Matrix Multiplication (Regular)&lt;/li&gt;
&lt;li&gt;SOR (Regular)&lt;/li&gt;
&lt;li&gt;Molecular Dynamics (Irregular)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Parallelism Overview&lt;/h2&gt;

&lt;h3&gt;Standard Models of Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shared memory (pthreads)&lt;/li&gt;
&lt;li&gt;Shared memory + data parallelism (OpenMP)&lt;/li&gt;
&lt;li&gt;Message passing (MPI)&lt;/li&gt;
&lt;li&gt;Transactional memory (TM)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Speedup&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;speedup on problem = sequential execution time of best known sequential algorithm / execution time on p processors&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Avoids picking easily parallelizable algorithm with poor sequential execution time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linear speedup is best to be achieved

&lt;ul&gt;
&lt;li&gt;Sub-linear speedup: due to overhead of &lt;em&gt;startup&lt;/em&gt;, &lt;em&gt;synchronization&lt;/em&gt;, &lt;em&gt;communication&lt;/em&gt;, ...&lt;/li&gt;
&lt;li&gt;Super-linear speedup

&lt;ul&gt;
&lt;li&gt;Cache/memory effects&lt;/li&gt;
&lt;li&gt;Nondeterminism in search problems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amdahl&amp;#39;s Law&lt;/strong&gt;: if &lt;code&gt;1/s&lt;/code&gt; of program is sequential, speedup will not be better than &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dependence&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;True dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; reads a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value read by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Output dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop carried dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Statements are part of the execution of a loop&lt;/li&gt;
&lt;li&gt;e.g. &lt;code&gt;a[i] = f(a[i-1]) + 1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Prevents loop iteration parallelization&lt;/li&gt;
&lt;li&gt;Level of loop carried dependence: nesting depth of loop that carries dependence&lt;/li&gt;
&lt;li&gt;&amp;lt;-&amp;gt; &lt;strong&gt;Loop independent dependence&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Threads &amp;amp; Processes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Similarities

&lt;ul&gt;
&lt;li&gt;Own logical control flow&lt;/li&gt;
&lt;li&gt;Run concurrently with others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Differences

&lt;ul&gt;
&lt;li&gt;Threads share code &amp;amp; data, processes don&amp;#39;t&lt;/li&gt;
&lt;li&gt;Process control &amp;amp; context switches more expensive than thread control &amp;amp; thread switches&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Pthreads&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;User has to:

&lt;ul&gt;
&lt;li&gt;Decompose computation into parallel parts&lt;/li&gt;
&lt;li&gt;Create/destroy threads&lt;/li&gt;
&lt;li&gt;Add synchronization to ensure dependences covered&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pthread_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_join()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Synchronization&lt;/h3&gt;

&lt;h4&gt;Parallelization Options&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Course-grained locking&lt;/strong&gt;: 1 big lock for critical section

&lt;ul&gt;
&lt;li&gt;Limited parallelism&lt;/li&gt;
&lt;li&gt;Easy to implement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fine-grained locking&lt;/strong&gt;: 1 lock per variable used in critical section

&lt;ul&gt;
&lt;li&gt;Good parallelism: less dependencies&lt;/li&gt;
&lt;li&gt;Hard to implement

&lt;ul&gt;
&lt;li&gt;Deadlock, fault tolerance, priority inversion, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semaphores&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fork-Join&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Barriers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reductions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Data Parallelism&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Processors do the same thing on different data

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regular&lt;/strong&gt;: linear indexing

&lt;ul&gt;
&lt;li&gt;All arrays accessed through linear expressions of loop indices, known at compile time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Irregular&lt;/strong&gt;: non-linear indexing

&lt;ul&gt;
&lt;li&gt;Some arrays accessed through non-linear expressions of loop indices, some only known at runtime&lt;/li&gt;
&lt;li&gt;Difficult for parallelism based on &lt;em&gt;data distribution&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Not difficult for parallelism based on &lt;em&gt;iteration distribution&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;v.s. &lt;strong&gt;Task Parallelism&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Processors do different tasks&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Matrix Multiplication (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    for (j = 0; j &amp;lt; n; j++)
        c[i][j] = 0.0; 
for (i = 0; i &amp;lt; n; i++)
    for (j = 0; j &amp;lt; n; j++)
        for (k = 0; k &amp;lt; n; k++)
            c[i][j] += a[i][k] * b[k][j];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences on i-/j- loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence&lt;/strong&gt; on k-loop&lt;/li&gt;
&lt;li&gt;Data Distribution

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block distribution&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by row&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cyclic distrubution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block cyclic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Combinations&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;SOR (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps/iterations {
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            temp[i][j] = 0.25 *
                (grid[i-1][j] + grid[i+1][j] + grid[i][j-1] + grid[i][j+1]);
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            grid[i][j] = temp[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No dependences between 1st &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;No dependences between 2nd &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd loop nest in the same timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 2nd &amp;amp; 1st loop nest of next timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Molecular Dynamics (Irregular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps { 
    for all molecules i
        for all nearby molecules j
            force[i] += f(loc[i], loc[j]);
    for all molecules i
        loc[i] = g(loc[i], force[i]);
}

for each molecule i
    number of nearby molecules count[i]
    array of indices of nearby molecules index[j] // 0 &amp;lt;= j &amp;lt; count[i]

for some number of timesteps { 
    for (i = 0; i &amp;lt; num_mol; i++)
        for (j = 0; j &amp;lt; count[i]; j++)
            force[i] += f(loc[i], loc[index[j]]);
    for (i = 0; i &amp;lt; num_mol; i++)
        loc[i] = g(loc[i], force[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences in 1st i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;li&gt;May have &lt;strong&gt;load balancing&lt;/strong&gt; problem&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence (reduction)&lt;/strong&gt; on j-loop&lt;/li&gt;
&lt;li&gt;No loop-carried dependences in 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Fork-join between loops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/threads-and-parallel-programming.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/threads-and-parallel-programming.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Memory Optimization</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Data Representation &amp;amp; Alignment&lt;/li&gt;
&lt;li&gt;Cache Performance

&lt;ol&gt;
&lt;li&gt;Cache Organization&lt;/li&gt;
&lt;li&gt;Cache Performance Metrics&lt;/li&gt;
&lt;li&gt;Code Scheduling&lt;/li&gt;
&lt;li&gt;Blocking/Tiling&lt;/li&gt;
&lt;li&gt;The Memory Moutain&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Virtual Memory

&lt;ol&gt;
&lt;li&gt;Virtual Memory Access&lt;/li&gt;
&lt;li&gt;Page Table &amp;amp; TLB&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Prefetching

&lt;ol&gt;
&lt;li&gt;H/W Prefetching&lt;/li&gt;
&lt;li&gt;S/W Prefetching&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Machine-Dependent Optimizations

&lt;ol&gt;
&lt;li&gt;Pointer Code&lt;/li&gt;
&lt;li&gt;Instruction-Level Parallelism&lt;/li&gt;
&lt;li&gt;Parallel Loop Unrolling&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Data Representation &amp;amp; Alignment&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Primitive data type requires K bytes -&amp;gt; address must be multiple of K&lt;/li&gt;
&lt;li&gt;Structures align with the &lt;em&gt;largest alignment requirement of any element&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Cache Performance&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Keep working set small (temporal locality)&lt;/li&gt;
&lt;li&gt;Use small strides (spacial locality)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Cache Organization&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;address: | tag | index | offset |
cache block: | v | tag | data |
S - 2^s sets
E - 2^e blocks/lines per set
B - 2^b bytes per cache block

Cach size = S * E * B bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Cache Performance Metrics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Miss rate&lt;/li&gt;
&lt;li&gt;Hit time

&lt;ul&gt;
&lt;li&gt;isLineInCache? + deliver block to CPU (+virtual memory translation)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Miss penalty&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Code Scheduling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Factors

&lt;ul&gt;
&lt;li&gt;Reordering of loops&lt;/li&gt;
&lt;li&gt;# of read/write operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Blocking/Tiling&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Traverse array in blocks&lt;/li&gt;
&lt;li&gt;Imporves &lt;strong&gt;temporal locality&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;The Memory Moutain&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Measure &lt;strong&gt;read throughput&lt;/strong&gt; as a function of &lt;strong&gt;spatial &amp;amp; temporal locality&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://cfile22.uf.tistory.com/image/112730164AC0AFAB36962C&quot; alt=&quot;Memory Mountain&quot;&gt;&lt;/p&gt;

&lt;h2&gt;Virtual Memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Why virtual memory?

&lt;ul&gt;
&lt;li&gt;Capacity/Portability&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;Sharing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Virtual Memory Access&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Type of cache misses

&lt;ul&gt;
&lt;li&gt;Cold/compulsory miss&lt;/li&gt;
&lt;li&gt;Conflict miss

&lt;ul&gt;
&lt;li&gt;Avoided by &lt;em&gt;set-associative caches&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Capacity miss *

&lt;ul&gt;
&lt;li&gt;Keep working set within on-chip cache capacity&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Write

&lt;ul&gt;
&lt;li&gt;Write-back (on write-hit)&lt;/li&gt;
&lt;li&gt;Write-allocate (on write-miss)&lt;/li&gt;
&lt;li&gt;Write-through&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Page Table &amp;amp; TLB&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MMU keep mapping of VA to PA in &lt;strong&gt;page table&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Page table kept in main memory, can be cached&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Translation lookaside buffer (TLB)&lt;/strong&gt;: cache for page table

&lt;ul&gt;
&lt;li&gt;TLB hit: &lt;code&gt;CPU -&amp;gt; MMU -&amp;gt; TLB -&amp;gt; MMU -&amp;gt; Mem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TLB miss: &lt;code&gt;CPU -&amp;gt; MMU -&amp;gt; TLB -&amp;gt; Mem -&amp;gt; TLB -&amp;gt; MMU -&amp;gt; Mem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TLB reach: &lt;code&gt;(# TLB entries) * (page size)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Working set&lt;/strong&gt; : a set of active virtual pages

&lt;ul&gt;
&lt;li&gt;Page miss: &lt;code&gt;(working set size) &amp;gt; (main mem size)&lt;/code&gt; -&amp;gt; &lt;strong&gt;thrashing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;TLB miss: &lt;code&gt;(# working set pages) &amp;gt; (# TLB entries)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Prefetching&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bring into cache elements expected to be accessed in future&lt;/li&gt;
&lt;li&gt;Effective if:

&lt;ul&gt;
&lt;li&gt;Spare memory bandwidth&lt;/li&gt;
&lt;li&gt;Accurate&lt;/li&gt;
&lt;li&gt;Timely&lt;/li&gt;
&lt;li&gt;Doesn&amp;#39;t displace other in-use data&lt;/li&gt;
&lt;li&gt;Latency hidden by prefetched outweighs their cost&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;H/W Prefetching&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Prefetch adjacent block&lt;/li&gt;
&lt;li&gt;Recognize a &lt;em&gt;stream&lt;/em&gt;: addresses separated by a &lt;em&gt;stride&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Prefetch within a page boundary&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;S/W Prefetching&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Insert special &lt;code&gt;prefetch&lt;/code&gt; instructions into code

&lt;ul&gt;
&lt;li&gt;Patterns that H/W wouldn&amp;#39;t recognize e.g. linked list&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Machine-Dependent Optimizations&lt;/h2&gt;

&lt;h3&gt;Pointer Code&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Not necessarily better than array code; some compilers do better job optimizing array code&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Instruction-Level Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Limiting factor

&lt;ul&gt;
&lt;li&gt;Latency of instructions&lt;/li&gt;
&lt;li&gt;# of functional units available

&lt;ul&gt;
&lt;li&gt;1 load&lt;/li&gt;
&lt;li&gt;1 store&lt;/li&gt;
&lt;li&gt;2 int (1 may be branch)&lt;/li&gt;
&lt;li&gt;1 FP add&lt;/li&gt;
&lt;li&gt;1 FP mul/div&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Parallel Loop Unrolling&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Accumulate in 2 different products, combine at end

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(1 * x2 * ... * xn) * (1 * x1 * ... * x_n-1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Dual product 

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(1 * x1) * (x2 * x3) * ... * (x_n-1 * xn)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Limitations

&lt;ul&gt;
&lt;li&gt;Need lots of registers to hold sums/products&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/memory-optimization.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/memory-optimization.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Memory Allocation</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dynamic Memory Allocation

&lt;ol&gt;
&lt;li&gt;Memory Allocator&lt;/li&gt;
&lt;li&gt;Performance Goals&lt;/li&gt;
&lt;li&gt;Fragmentation&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Garbage Collection&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Memory-Related Bugs&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Dynamic Memory Allocation&lt;/h2&gt;

&lt;h3&gt;Memory Allocator&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Explicit memory allocator&lt;/strong&gt;: &lt;code&gt;malloc&lt;/code&gt; &amp;amp; &lt;code&gt;free&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implicit memory allocator&lt;/strong&gt;: garbage collection&lt;/li&gt;
&lt;li&gt;Provides abstraction of memory as a set of blocks&lt;/li&gt;
&lt;li&gt;Constraints

&lt;ul&gt;
&lt;li&gt;Alignment&lt;/li&gt;
&lt;li&gt;No compaction on allocated blocks&lt;/li&gt;
&lt;li&gt;Only manipulate free memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Goal

&lt;ul&gt;
&lt;li&gt;Good time performance for &lt;code&gt;malloc&lt;/code&gt; &amp;amp; &lt;code&gt;free&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Good space utilization&lt;/li&gt;
&lt;li&gt;Good locality properties

&lt;ul&gt;
&lt;li&gt;Allocation close in time should be close in space&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Performance Goals&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Throughput&lt;/strong&gt;: # of completed requests per unit time&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peak memory utilization&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Aggregate payload &lt;code&gt;Pk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Current heap size &lt;code&gt;Hk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Peak memory utilization &lt;code&gt;Uk = (max_i&amp;lt;k Pi) / Hk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Fragmentation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Internal fragmentation&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Depends on pattern of &lt;em&gt;previous&lt;/em&gt; requests&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;External fragmentation&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Depends on pattern of &lt;em&gt;future&lt;/em&gt; requests&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;| size | a | - header
| payload  |
| padding  |
| size | a | - footer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Keep track of &lt;strong&gt;size&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Overhead: size + allocated bit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Keep track of &lt;strong&gt;free blocks&lt;/strong&gt;

&lt;ol&gt;
&lt;li&gt;Implicit list: length to link all blocks&lt;/li&gt;
&lt;li&gt;Explicit list: pointers to link free blocks&lt;/li&gt;
&lt;li&gt;Segregated free list&lt;/li&gt;
&lt;li&gt;Blocks sorted by size&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Implicit List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Placement policy

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;First fit&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Next fit&lt;/strong&gt;: fragmentation worse&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best fit&lt;/strong&gt;: slower&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Coalescing policy

&lt;ul&gt;
&lt;li&gt;Join adjacent free blocks&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Immediate coalescing&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deferred coalescing&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Until &lt;code&gt;malloc&lt;/code&gt; or external fragmentation reaches threshold&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Explicit Free List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Extra data space for link pointers&lt;/li&gt;
&lt;li&gt;Need boundary tags for coalescing&lt;/li&gt;
&lt;li&gt;Insertion policy

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LIFO&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address-ordered&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Segragated Free List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Each size class  has own collection of blocks

&lt;ul&gt;
&lt;li&gt;Separate size class for small sizes&lt;/li&gt;
&lt;li&gt;Typically size classes for power of 2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Garbage Collection&lt;/h3&gt;

&lt;h4&gt;Mark and Sweep Collecting&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mark&lt;/strong&gt;: scan over blocks, mark all reachable memory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sweep&lt;/strong&gt;: scan over blocks, free blocks not marked&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Memory-Related Bugs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dereferencing bad pointers 

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scanf(&amp;quot;%d&amp;quot;, val)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Reading uninitialized memory &lt;/li&gt;
&lt;li&gt;Overwriting memory

&lt;ul&gt;
&lt;li&gt;Allocating wrong sized object&lt;/li&gt;
&lt;li&gt;Off-by-one error&lt;/li&gt;
&lt;li&gt;Not checking max string size&lt;/li&gt;
&lt;li&gt;Referencing a pointer instead of the object it points to: &lt;code&gt;*size--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pointer arithmetic: &lt;code&gt;p += sizeof(int)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Referencing nonexistent variables 

&lt;ul&gt;
&lt;li&gt;Return pointer to local variable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Freeing blocks multiple times &lt;/li&gt;
&lt;li&gt;Referencing freed blocks&lt;/li&gt;
&lt;li&gt;Failing to free blocks&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/memory-allocation.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/memory-allocation.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Code Optimization Principles &amp; Profiling</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Measurements of Programs &amp;amp; Computers

&lt;ol&gt;
&lt;li&gt;Measurements&lt;/li&gt;
&lt;li&gt;Amdahl&amp;#39;s Law&lt;/li&gt;
&lt;li&gt;Tools for Measuring&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Compiler Optimizations

&lt;ol&gt;
&lt;li&gt;Common Compiler Optimizations&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Basics of Computer Architecture

&lt;ol&gt;
&lt;li&gt;Pipelines&lt;/li&gt;
&lt;li&gt;Branch Prediction&lt;/li&gt;
&lt;li&gt;Out-of-Order Execution&lt;/li&gt;
&lt;li&gt;Superscalar &amp;amp; Simultaneous Multithreading(SMT)/Hyperthreading&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Measurements of Programs &amp;amp; Computers&lt;/h2&gt;

&lt;h3&gt;Measurements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IPS&lt;/strong&gt;: instructions per second&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FLOPS&lt;/strong&gt;: floating point operations per second&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPC&lt;/strong&gt;: instructions per cycle&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPI&lt;/strong&gt;: cycles per instruction&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Amdahl&amp;#39;s Law&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;speedup = OldTime/NewTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NewTime = OldTime x [(1 - f) + f/s]&lt;/code&gt;&lt;br&gt;
&lt;code&gt;speedup = 1 / (1 - f + f/s)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; = fraction of execution time the optimization applies to&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; = improvement factor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Tools for Measuring&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;S/W timers&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;C library: &lt;code&gt;&amp;lt;sys/times.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OS-level timers: &lt;code&gt;/usr/bin/time&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;H/W timers &amp;amp; performance counters&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Built into processor chip: low-level architecture events e.g. cache misses, branch mispredictions, ...&lt;/li&gt;
&lt;li&gt;S/W packages to make them easier to use: &lt;code&gt;perf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Instrumentation&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Self implemented codes&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gprof&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Periodically interrupt program&lt;/li&gt;
&lt;li&gt;Measure &lt;em&gt;time spent&lt;/em&gt; &amp;amp; &lt;em&gt;# of calls made&lt;/em&gt; in each function&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gcov&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Profile of execution within a function e.g. # of times each line of code was executed, which loops/conditional statements are important&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disturbing the system slows down execution&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comparison&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;gprof&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;gcov&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Compile&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;faster (insert counter func for each function)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;slower (insert counter func for each line)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Size&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;smaller&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;bigger&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Runtime&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;slower (frequent interrupts)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;faster&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Compiler Optimizations&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Preserve correctness&lt;/li&gt;
&lt;li&gt;Improve performance

&lt;ul&gt;
&lt;li&gt;Fewer CPI

&lt;ul&gt;
&lt;li&gt;Schedule instructions&lt;/li&gt;
&lt;li&gt;Improve cache/memory behavior&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Fewer instructions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Worth the effort&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;---&amp;gt; Front End ---&amp;gt; Optimizer ---&amp;gt; Code Generator ---&amp;gt;
 HLL            IR             IR                 LLL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Limitations

&lt;ul&gt;
&lt;li&gt;Cannot change program behavior&lt;/li&gt;
&lt;li&gt;Inter-procedural analysis too expensive -&amp;gt; most analysis performed within procedures&lt;/li&gt;
&lt;li&gt;Hard to anticipate run-time inputs -&amp;gt; most analysis based on static information&lt;/li&gt;
&lt;li&gt;Must be conservative&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Programmers should:

&lt;ul&gt;
&lt;li&gt;Select best algorithm&lt;/li&gt;
&lt;li&gt;Write readable &amp;amp; maintainable code&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Eliminate optimization blockers&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Memory aliasing

&lt;ul&gt;
&lt;li&gt;2 different memory references specific single location&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pocedural side-effects&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Common Compiler Optimizations&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Machine independent

&lt;ul&gt;
&lt;li&gt;Constant propagation&lt;/li&gt;
&lt;li&gt;Constant folding&lt;/li&gt;
&lt;li&gt;Common subexpression elimination&lt;/li&gt;
&lt;li&gt;Dead code elimination&lt;/li&gt;
&lt;li&gt;Loop invariant code motion&lt;/li&gt;
&lt;li&gt;Function inlining

&lt;ul&gt;
&lt;li&gt;Space-speed tradeoff&lt;/li&gt;
&lt;li&gt;Overloading issue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Reduction in strength: replace costly operation with simpler one

&lt;ul&gt;
&lt;li&gt;Shifting (machine-dependent)&lt;/li&gt;
&lt;li&gt;Make use of registers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Direct access

&lt;ul&gt;
&lt;li&gt;Avoid bound checking&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Machine dependent

&lt;ul&gt;
&lt;li&gt;Instruction scheduling&lt;/li&gt;
&lt;li&gt;Loop unrolling

&lt;ul&gt;
&lt;li&gt;Enables more aggressive instruction scheduling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel unrolling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Basics of Computer Architecture&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RISC: simpler instructions -&amp;gt; &lt;strong&gt;pipeline&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;64-bit: larger databases, counter not overflowing, better math performance -&amp;gt; code size increases&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Pipelines&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Important factors

&lt;ul&gt;
&lt;li&gt;Branch prediction&lt;/li&gt;
&lt;li&gt;Data dependency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pipeline deeper -&amp;gt; misprediction penalty larger&lt;/li&gt;
&lt;li&gt;Multiple instruction issue: flushing &amp;amp; refetching more instructions&lt;/li&gt;
&lt;li&gt;OOP: More indirect branches to be predicted&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Branch Prediction&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Predict future based on history&lt;/li&gt;
&lt;li&gt;Global predictor: predict based on &lt;em&gt;global&lt;/em&gt; &amp;amp; &lt;em&gt;local&lt;/em&gt; history

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(m, n) prediction&lt;/strong&gt;: m-bit global x n-bit local&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Out-of-Order Execution&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Solve &lt;strong&gt;data dependency&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Mask &lt;strong&gt;cache miss delay&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Superscalar &amp;amp; Simultaneous Multithreading(SMT)/Hyperthreading&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    1               1 2             1 2 6
    2               3 4 5           3 4 5   
    3               6               7 8
    4               7 8             9
    5               9
    6
    7
    8
    9
single-issue     superscalar    out-of-order superscalar

    1   1'          1 2 6           1 2 1'
    2   2'          3 4 5           2'6 6'
    3   3'          7 8             3'3 5
    4   4'          9               4 4'5'
    5   5'          1'2'6'          7 8 7'
    6   6'          3'4'5'          9 8'
    7   7'          7'8'            9'
    8   8'          9'
    9   9'
2 applications      fast        hyperthreading
                context switching
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/optimization/2016/10/30/code-optimization-principles-and-profiling.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/10/30/code-optimization-principles-and-profiling.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Constraint Satisfaction Problems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Constraint Satisfaction Problems (Backtracking Search) Overview

&lt;ol&gt;
&lt;li&gt;CSP v.s Traditional Search Problems&lt;/li&gt;
&lt;li&gt;Feature Vectors&lt;/li&gt;
&lt;li&gt;Constraint Graph&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Solving CSPs

&lt;ol&gt;
&lt;li&gt;Viewing CSP as Search Problem&lt;/li&gt;
&lt;li&gt;Backtracking Search Algorithm&lt;/li&gt;
&lt;li&gt;Constraint Propagation

&lt;ol&gt;
&lt;li&gt;Forward Checking&lt;/li&gt;
&lt;li&gt;Generalizaed Arc Consistency&lt;/li&gt;
&lt;li&gt;Heuristics&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Constraint Satisfaction Problems (Backtracking Search) Overview&lt;/h2&gt;

&lt;h3&gt;CSP v.s Traditional Search Problems&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;CSP does not care about the &lt;em&gt;sequence of moves&lt;/em&gt; to reach goal state&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Feature Vectors&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Represent states as &lt;strong&gt;vectors of feature values&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Formalization

&lt;ul&gt;
&lt;li&gt;A set of &lt;strong&gt;features/variables&lt;/strong&gt; &lt;code&gt;V1, ... Vn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Domain&lt;/strong&gt; for each variable &lt;code&gt;Dom[Vi]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A set of &lt;strong&gt;constraints&lt;/strong&gt; &lt;code&gt;C1, ..., Cm&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Scope&lt;/strong&gt;: a set of variables it operates over&lt;/li&gt;
&lt;li&gt;Unary, binary, higher-order constraints&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;State&lt;/strong&gt;: assignment of value for each variable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partial state&lt;/strong&gt;: assignment of value for some variables&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Goal state&lt;/strong&gt;: a state satisfying all &lt;strong&gt;constraints&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Constraint Graph&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Nodes: &lt;strong&gt;variables&lt;/strong&gt;; arcs: &lt;strong&gt;constraints&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Solving CSPs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Search through the space of partial assignments&lt;/li&gt;
&lt;li&gt;Order of assignments does not matter&lt;/li&gt;
&lt;li&gt;If we falsify a constraint, we immediately reject the current partial assignment&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Viewing CSP as Search Problem&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Initial state&lt;/strong&gt;: empty assignment&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Successor function&lt;/strong&gt;: a value assigned to any unassigned variable s.t. no constraints return false&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Goal test&lt;/strong&gt;: complete assignment&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Backtracking Search Algorithm&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Similar to DFS&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;BT(Level):
    If all variables assigned:
        PRINT Value of each Variable
        RETURN

    V := PickUnassignedVariable()
    Assigned[V] := TRUE
    for d := each member of Domain(V):
        Value[V] := d
        ConstraintsOK = TRUE
        for each constraint C such that
            a) V is a variable of C and
            b) all other variables of C are assigned: 
            If C is not satisfied by the set of current assignments:
                ConstraintsOK = FALSE
                break
        If ConstraintsOk == TRUE:
            BT(Level+1)
    Assigned[V] := FALSE //UNDO as we have tried all of V’s values return
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Constraint Propagation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Look ahead&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Forward Checking&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;When instantiating a variable, check all constrants with &lt;strong&gt;only one ininstantiated variable&lt;/strong&gt; remaining&lt;/li&gt;
&lt;li&gt;Prune values of that variable that violate the constraint&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;FCCheck(C,x):
    // C is a constraint with all its variables already assigned, except for variable x

    for d := each member of CurDom[x]:
        If making x = d together with previous assignments
    to variables in scope C falsifies C:
            remove d from CurDom[x]

    If CurDom[x] = {}:
        return DWO (Domain Wipe Out)
    Else:
        return ok

FC(Level):
    If all variables assigned:
        PRINT Value of each Variable
        RETURN

    V := PickAnUnassignedVariable()
    Assigned[V] := TRUE
    for d := each member of CurDom(V):
        Value[V] := d
        DWOoccured:= False
        for each constraint C over V such that
            a) C has only one unassigned variable X in its scope:
            If (FCCheck(C,X) == DWO):
                DWOoccurred:= True
                break
        If(not DWOoccured)
            FC(Level+1)
        RestoreAllValuesPrunedByFCCheck()
    Assigned[V] := FALSE
    return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Generalizaed Arc Consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C(V1, ..., Vn)&lt;/code&gt; is GAC with regard to &lt;code&gt;Vi&lt;/code&gt; iff for every value of &lt;code&gt;Vi&lt;/code&gt;, there exist values of &lt;code&gt;V1, ..., Vn&lt;/code&gt; that satisfy C&lt;/li&gt;
&lt;li&gt;If for &lt;code&gt;Vi = d&lt;/code&gt; is not consistent wrt the constraint, &lt;code&gt;d&lt;/code&gt; is &lt;strong&gt;arc inconsistent&lt;/strong&gt; and can be removed from domain of &lt;code&gt;Vi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A constraint that is GAC may become non-GAC due to pruning of domain values during search&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;GAC_Enforce():
// GAC-Queue contains all constraints one of whose variables has had its domain reduced

while GACQueue not empty:
    C = GACQueue.extract()
    for V := each member of scope(C):
        for d := CurDom[V]:
            Find an assignment A for all other variables in scope(C) such that C(A ∪ V=d) = True
            if A not found:
                CurDom[V] = CurDom[V] – d 
            if CurDom[V] = ∅:
                empty GACQueue
                return DWO
            else:
                push all constraints C’ s.t. V ∈ scope(C’) and C’ !∈ GACQueue on to GACQueue
return TRUE

GAC(Level):
    If all variables are assigned:
        PRINT Value of each Variable
        RETURN

    V := PickAnUnassignedVariable()
    Assigned[V] := TRUE
    for d := each member of CurDom(V):
        Value[V] := d
        Prune all values of V != d from CurDom[V]
        for each constraint C whose scope contains V:
            Put C on GACQueue
        if(GAC_Enforce() != DWO):
            GAC(Level+1)
        RestoreAllValuesPrunedFromCurDoms()

    Assigned[V] := FALSE
    return;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;May keep track of &lt;strong&gt;supports&lt;/strong&gt; to avoid having to search through all possible assignments and check satisfication&lt;/li&gt;
&lt;li&gt;Check if current support still valie, i.e. all values it assigns still lie in the variables&amp;#39; current domains&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Heuristics&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ordering of variables

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minimum Remaining Values (MRV)&lt;/strong&gt;: returns the variable with the most constrained current domain&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Degree Heuristic (DH)&lt;/strong&gt;: returns variable imposing the most constraints on remaining unassigned variables&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ordering of values

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Least Constraining Value (LCV)&lt;/strong&gt;: the best value is the one ruling out the fewest domain values in other variables that share at least one constraint with var&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/ai/2016/10/30/constraint-satisfaction-problems.html</link>
        <guid isPermaLink="true">/blog/notes/ai/2016/10/30/constraint-satisfaction-problems.html</guid>
        
        <category>AI</category>
        
        <category>CSC384</category>
        
        <category>CSP</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>AI</category>
        
      </item>
    
  </channel>
</rss>
