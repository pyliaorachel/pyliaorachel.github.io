<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MyCoon</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 01 Dec 2016 12:07:23 -0500</pubDate>
    <lastBuildDate>Thu, 01 Dec 2016 12:07:23 -0500</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Coping with NP-Complete Problems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Intelligent Exhaustive Search

&lt;ol&gt;
&lt;li&gt;Backtracking&lt;/li&gt;
&lt;li&gt;Branch-and-Bound&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Approximation Algorithms

&lt;ol&gt;
&lt;li&gt;Vertex Cover&lt;/li&gt;
&lt;li&gt;Clustering&lt;/li&gt;
&lt;li&gt;TSP&lt;/li&gt;
&lt;li&gt;Knapsack&lt;/li&gt;
&lt;li&gt;Approximability Hierarchy
&amp;lt;!--more--&amp;gt;
---
## Intelligent Exhaustive Search&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Backtracking&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Start with some problem P0
Let S = {P0}, the set of active subproblems 
Repeat while S is nonempty:
    choose a subproblem P ∈ S and remove it from S 
    expand it into smaller subproblems P1, P2, ..., Pk 
    For each Pi:
        If test(Pi) succeeds: halt and announce this solution
        If test(Pi) fails: discard Pi
        Otherwise: add Pi to S # uncertainty
Announce that there is no solution
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Branch-and-Bound&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Start with some problem P0
Let S = {P0}, the set of active subproblems bestsofar = ∞
Repeat while S is nonempty:
    choose a subproblem (partial solution) P ∈ S and remove it from S 
    expand it into smaller subproblems P1, P2, ..., Pk
    For each Pi:
        If Pi is a complete solution: update bestsofar
        else if lowerbound(Pi) &amp;lt; bestsofar: add Pi to S
return bestsofar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jot.fm/issues/issue_2003_05/column7/&quot;&gt;TSP example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Approximation Algorithms&lt;/h2&gt;

&lt;p&gt;Minimize &lt;code&gt;αA = max_I(A(I)/OPT(I))&lt;/code&gt;, where &lt;code&gt;αA&lt;/code&gt; is the &lt;strong&gt;approximation ratio&lt;/strong&gt; of algorithm &lt;code&gt;A&lt;/code&gt;.  &lt;/p&gt;

&lt;h3&gt;Vertex Cover&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Input: undirected graph G = (V, E)
Output: a subset of the vertices S ⊆ V that touches every edge
Goal: Minimize |S|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Greedy algorithm (used for &lt;strong&gt;set cover&lt;/strong&gt; problem)&lt;/p&gt;

&lt;p&gt;Repeatedly include the highest degree in the vertex cover.&lt;br&gt;
=&amp;gt; factor &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Matching&lt;/p&gt;

&lt;p&gt;A subset of edges that have no vertices in common.&lt;br&gt;
If &lt;code&gt;S&lt;/code&gt; is the set containing both endpoints of each edge in maximal matching &lt;code&gt;M&lt;/code&gt;, then &lt;code&gt;S&lt;/code&gt; is vertex cover.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Any matching is a &lt;strong&gt;lower bound&lt;/strong&gt; on &lt;code&gt;OPT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Maximal matching with &lt;code&gt;M&lt;/code&gt; edges provides &lt;code&gt;2M&lt;/code&gt; &lt;strong&gt;upper bound&lt;/strong&gt; on &lt;code&gt;OPT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Find a maximal matching M ⊆ E
Return S = {all endpoints of edges in M }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; factor &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Clustering&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Divide some data into groups. Distances between data points are defined:

1. d(x,y) ≥ 0 for all x,y
2. d(x,y) = 0 iff x = y
3. d(x,y) = d(y,x)
4. (Triangle inequality) d(x,y) ≤ d(x,z) + d(z,y)

k-CLUSTER:

Input: points X = {x1, ..., xn} with underlying distance metric d(·,·); integer k 
Output: a partition of points into k clusters C1, ..., Ck
Goal: minimize diameter of the clusters,
        max_j(max_xa,xb∈Cj(d(xa,xb))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Farthest-first traversal&lt;/p&gt;

&lt;p&gt;Pick k of the data points as cluster centers one at a time and always pick the next center to be as far as possible from the centers chosen so far.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Pick any point μ1 ∈ X as the first cluster center 
for i = 2 to k:
    Let μi be the point in X that is farthest from μ1, ..., μi−1 (i.e. maximizes min_j&amp;lt;i(d(·,μj)))
Create k clusters: Ci = {all x ∈ X whose closest center is μi}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; factor &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Argument

1.
Let x ∈ X be the point farthest from μ1, ..., μk
Let r be its distance to closest center
=&amp;gt; every point in X must be within distance r of its cluster center
=&amp;gt; every cluster has diameter &amp;lt;= 2r

2.
{μ1, ..., μk, x} are all at distance &amp;gt;= r
=&amp;gt; any partition into k clusters must put 2 of them in same cluster
=&amp;gt; diameter at least r
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;TSP&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MST for metric TSP&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TSP cost ≥ cost of this path ≥ MST cost&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;From MST, going through each edge twice ends up with a TSP, so &lt;code&gt;length &amp;lt;= 2 * MST cost &amp;lt;= 2 * TSP cost&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further skip any city about to revisit and instead move directly to the next new city.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;General TSP -&amp;gt; Rudrata Path&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;For an instance I(G, C) of the TSP:
    If G has a Rudrata path, then OPT(I(G,C)) = n
    If G has no Rudrata path, then OPT(I(G,C)) ≥ n + C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Given any graph G:
    compute I(G,C) (with C = n * αA)
    run approximation algorithm A for TSP on it 
    if the resulting tour has length ≤ nαA:
        G has a Rudrata path 
    else: 
        G has no Rudrata path
# can find the path by calling procedure polynomial number of times
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If TSP has a polynomial-time approximation algorithm, then there is a polynomial algorithm for Rudrata path problem. So unless P = NP, there cannot exist an efficient approximation algorithm for TSP.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Knapsack&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. Change O(nW) algorithm into O(nV)
2. Scale v'i = ⌊vi * n/εvmax⌋
3. Since rescaled values v'i are all at most n/ε, DP runs in O(n^3/ε)

Discard any item with weight &amp;gt; W
Let v_max = max_i(vi)
Rescale values v'i = ⌊vi * n/εvmax⌋
Run DP with values {v'i} 
Output the resulting choice of items

Let K* be the total value of the original optimal solution.

sum_i∈S(v'i) = sum_i∈S(⌊vi * n/εvmax⌋) &amp;gt;= sum_i∈S(vi * n/εvmax - 1) &amp;gt;= K* * (n/εvmax) - n

Scaling back:

sum_i∈S'(vi) &amp;gt;= sum_i∈S'(v'i * εvmax/n) &amp;gt;= (K* * (n/εvmax) - n)* εvmax/n = K* - εvmax &amp;gt;= K* * (1-ε)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Approximability Hierarchy&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;No finite approximation ratio possible (TSP)&lt;/li&gt;
&lt;li&gt;Approximation ratio possible, but with limits (Vertex Cover, k-Cluster, Metric TSP)&lt;/li&gt;
&lt;li&gt;Approximation ratio possible with no limits (Knapsack)&lt;/li&gt;
&lt;li&gt;Approximation ration about &lt;code&gt;logn&lt;/code&gt; (Set Cover)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cseweb.ucsd.edu/%7Edasgupta/291-geom/kcenter.pdf&quot;&gt;UCSD Notes on Clustering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 28 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/28/coping-with-np-complete-problems.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/28/coping-with-np-complete-problems.html</guid>
        
        <category>np-complete</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Parallelism Overview

&lt;ol&gt;
&lt;li&gt;Standard Models of Parallelism&lt;/li&gt;
&lt;li&gt;Speedup&lt;/li&gt;
&lt;li&gt;Dependence&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Threads &amp;amp; Processes

&lt;ol&gt;
&lt;li&gt;Pthreads&lt;/li&gt;
&lt;li&gt;Synchronization&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Data Parallelism

&lt;ol&gt;
&lt;li&gt;Matrix Multiplication (Regular)&lt;/li&gt;
&lt;li&gt;SOR (Regular)&lt;/li&gt;
&lt;li&gt;Molecular Dynamics (Irregular)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Task Parallelism

&lt;ol&gt;
&lt;li&gt;PIPE (Pipelines)&lt;/li&gt;
&lt;li&gt;TSP (Task Queue)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Parallelism Overview&lt;/h2&gt;

&lt;h3&gt;Standard Models of Parallelism&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shared memory (pthreads)&lt;/li&gt;
&lt;li&gt;Shared memory + data parallelism (OpenMP)&lt;/li&gt;
&lt;li&gt;Message passing (MPI)&lt;/li&gt;
&lt;li&gt;Transactional memory (TM)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Speedup&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;speedup on problem = sequential execution time of best known sequential algorithm / execution time on p processors&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Avoids picking easily parallelizable algorithm with poor sequential execution time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linear speedup is best to be achieved

&lt;ul&gt;
&lt;li&gt;Sub-linear speedup: due to overhead of &lt;em&gt;startup&lt;/em&gt;, &lt;em&gt;synchronization&lt;/em&gt;, &lt;em&gt;communication&lt;/em&gt;, ...&lt;/li&gt;
&lt;li&gt;Super-linear speedup

&lt;ul&gt;
&lt;li&gt;Cache/memory effects&lt;/li&gt;
&lt;li&gt;Nondeterminism in search problems&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amdahl&amp;#39;s Law&lt;/strong&gt;: if &lt;code&gt;1/s&lt;/code&gt; of program is sequential, speedup will not be better than &lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Dependence&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;True dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; reads a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value read by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Output dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S2&lt;/code&gt; writes a value written by &lt;code&gt;S1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop carried dependence&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Statements are part of the execution of a loop&lt;/li&gt;
&lt;li&gt;e.g. &lt;code&gt;a[i] = f(a[i-1]) + 1;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Prevents loop iteration parallelization&lt;/li&gt;
&lt;li&gt;Level of loop carried dependence: nesting depth of loop that carries dependence&lt;/li&gt;
&lt;li&gt;&amp;lt;-&amp;gt; &lt;strong&gt;Loop independent dependence&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Threads &amp;amp; Processes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Similarities

&lt;ul&gt;
&lt;li&gt;Own logical control flow&lt;/li&gt;
&lt;li&gt;Run concurrently with others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Differences

&lt;ul&gt;
&lt;li&gt;Threads share code &amp;amp; data, processes don&amp;#39;t&lt;/li&gt;
&lt;li&gt;Process control &amp;amp; context switches more expensive than thread control &amp;amp; thread switches&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Pthreads&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;User has to:

&lt;ul&gt;
&lt;li&gt;Decompose computation into parallel parts&lt;/li&gt;
&lt;li&gt;Create/destroy threads&lt;/li&gt;
&lt;li&gt;Add synchronization to ensure dependences covered&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pthread_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_join()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Synchronization&lt;/h3&gt;

&lt;h4&gt;Parallelization Options&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Course-grained locking&lt;/strong&gt;: 1 big lock for critical section

&lt;ul&gt;
&lt;li&gt;Limited parallelism&lt;/li&gt;
&lt;li&gt;Easy to implement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fine-grained locking&lt;/strong&gt;: 1 lock per variable used in critical section

&lt;ul&gt;
&lt;li&gt;Good parallelism: less dependencies&lt;/li&gt;
&lt;li&gt;Hard to implement

&lt;ul&gt;
&lt;li&gt;Deadlock, fault tolerance, priority inversion, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semaphores&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fork-Join&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Barriers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reductions&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Data Parallelism&lt;/h2&gt;

&lt;p&gt;Processors do the same thing on different data.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Regular&lt;/strong&gt;: linear indexing

&lt;ul&gt;
&lt;li&gt;All arrays accessed through linear expressions of loop indices, known at compile time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Irregular&lt;/strong&gt;: non-linear indexing

&lt;ul&gt;
&lt;li&gt;Some arrays accessed through non-linear expressions of loop indices, some only known at runtime&lt;/li&gt;
&lt;li&gt;Difficult for parallelism based on &lt;em&gt;data distribution&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Not difficult for parallelism based on &lt;em&gt;iteration distribution&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Matrix Multiplication (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    for (j = 0; j &amp;lt; n; j++)
        c[i][j] = 0.0; 
for (i = 0; i &amp;lt; n; i++)
    for (j = 0; j &amp;lt; n; j++)
        for (k = 0; k &amp;lt; n; k++)
            c[i][j] += a[i][k] * b[k][j];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences on i-/j- loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence&lt;/strong&gt; on k-loop&lt;/li&gt;
&lt;li&gt;Data Distribution

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block distribution&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by row&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block distribution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cyclic distrubution by column&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block cyclic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Combinations&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;SOR (Regular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps/iterations {
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            temp[i][j] = 0.25 *
                (grid[i-1][j] + grid[i+1][j] + grid[i][j-1] + grid[i][j+1]);
    for (i = 1; i &amp;lt; n; i++)
        for (j = 1; j &amp;lt; n; j++)
            grid[i][j] = temp[i][j];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No dependences between 1st &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;No dependences between 2nd &lt;code&gt;(i,j)&lt;/code&gt; loop nest

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd loop nest in the same timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 2nd &amp;amp; 1st loop nest of next timestep

&lt;ul&gt;
&lt;li&gt;Fork-join&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Molecular Dynamics (Irregular)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for some number of timesteps { 
    for all molecules i
        for all nearby molecules j
            force[i] += f(loc[i], loc[j]);
    for all molecules i
        loc[i] = g(loc[i], force[i]);
}

for each molecule i
    number of nearby molecules count[i]
    array of indices of nearby molecules index[j] // 0 &amp;lt;= j &amp;lt; count[i]

for some number of timesteps { 
    for (i = 0; i &amp;lt; num_mol; i++)
        for (j = 0; j &amp;lt; count[i]; j++)
            force[i] += f(loc[i], loc[index[j]]);
    for (i = 0; i &amp;lt; num_mol; i++)
        loc[i] = g(loc[i], force[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;No loop-carried dependences in 1st i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;li&gt;May have &lt;strong&gt;load balancing&lt;/strong&gt; problem&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loop-carried dependence (reduction)&lt;/strong&gt; on j-loop&lt;/li&gt;
&lt;li&gt;No loop-carried dependences in 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Can run in parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;True-dependence&lt;/strong&gt; between 1st &amp;amp; 2nd i-loop

&lt;ul&gt;
&lt;li&gt;Fork-join between loops&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Task Parallelism&lt;/h2&gt;

&lt;p&gt;Processors do different tasks.&lt;/p&gt;

&lt;h3&gt;PIPE (Pipelines)&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Case 1&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i =0 ; i &amp;lt; num_pic, read(in_pic[i]); i++) {    
    int_pic_1[i] = trans1(in_pic[i]); 
    int_pic_2[i] = trans2(int_pic_1[i]); 
    int_pic_3[i] = trans3(int_pic_2[i]); 
    out_pic[i] = trans4(int_pic_3[i]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;// Assign each transformation to a processor
// Processor 1
for (i = 0; i &amp;lt; num_pics, read(in_pic[i]); i++) { 
    int_pic_1[i] = trans1(in_pic[i]); 
    signal(event_1_2[i]);
}
// Processor 2
for (i = 0; i &amp;lt; num_pics; i++) {
    wait(event_1_2[i]);
    int_pic_2[i] = trans1(int_pic_1[i]);
    signal(event_2_3[i]);
}
// Processor 3
...
// Processor 4
for (i = 0; i &amp;lt; num_pics; i++) {
    wait(event_3_4[i]);
    out_pic[i] = trans1(int_pic_3[i]); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;Each stage (transformation) may take different time to finish&lt;/li&gt;
&lt;li&gt;Stages take a variable amount of time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;semaphore_wait/signal&lt;/strong&gt; with &lt;code&gt;pthread&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Case 2&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i =0 ; i &amp;lt; num_pic, read(in_pic[i]); i++) {    
    int_pic_1 = trans1(in_pic); 
    int_pic_2 = trans2(int_pic_1); 
    int_pic_3 = trans3(int_pic_2); 
    out_pic = trans4(int_pic_3);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Anti-dependence between stages -&amp;gt; no parallelism

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Privatization&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buffer&lt;/strong&gt; between stages; block when buffers are full/empty&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;TSP (Task Queue)&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;init_q(); init_best();
while ((p = de_queue()) != NULL) {
    for each expansion by one city { 
        q = add_city(p);
        if (complete(q)) { update_best(q) } 
        else { en_queue(q) }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Balance between &lt;strong&gt;granularity for load balance&lt;/strong&gt; and &lt;strong&gt;overhead for synchronization&lt;/strong&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each process one expansion&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each process do expansion of one partial path&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;en_queue()/de_queue() {
    pthreads_mutex_lock(&amp;amp;queue);
    ...;
    pthreads_mutex_unlock(&amp;amp;queue);
}
update_best() {
    pthreads_mutex_lock(&amp;amp;best);
    ...;
    pthreads_mutex_unlock(&amp;amp;best);
}
de_queue() {
    while ((q is empty) and (not done)) {
        waiting++;
        if (waiting == p) {
            done = true;
            pthreads_cond_broadcast(&amp;amp;empty, &amp;amp;queue);
        }
        else {
            pthreads_cond_wait(&amp;amp;empty, &amp;amp;queue);
            waiting--; 
        }
    }
    if (done) return null; 
    else remove and return head of the queue; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Each process do expansion of multiple partial path&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Busy Waiting&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;initially: flag = 0;
P1: produce data; flag = 1;
P2: while (!flag); consume data;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Used when &lt;strong&gt;few threads competing for core&lt;/strong&gt; or &lt;strong&gt;short critical sections&lt;/strong&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/threads-and-parallel-programming.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/threads-and-parallel-programming.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming III</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Big Picture of Architecture &amp;amp; Memory Access

&lt;ol&gt;
&lt;li&gt;Virtual Memory

&lt;ul&gt;
&lt;li&gt;Memory Access&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Multithreading Basics

&lt;ul&gt;
&lt;li&gt;Parallelism within Processor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Connection between Memory Access, Memory Allocation and Cache Efficiency&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Cache Coherence

&lt;ol&gt;
&lt;li&gt;Cache Coherence Overview&lt;/li&gt;
&lt;li&gt;CC Protocols&lt;/li&gt;
&lt;li&gt;Locality in Parallel Programming&lt;/li&gt;
&lt;li&gt;True &amp;amp; False Sharing&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Big Picture of Architecture &amp;amp; Memory Access&lt;/h2&gt;

&lt;h3&gt;Virtual Memory&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Protection&lt;/strong&gt;: each process has its own private memory space&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sharing&lt;/strong&gt;: processes can share physical memory frames&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hide fragmentation&lt;/strong&gt;: can run if not enough total/contiguous memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Memory Access&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://wdxtub.com/images/14583140218329.jpg&quot; alt=&quot;memory access&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Processor sends VA to MMU&lt;/li&gt;
&lt;li&gt;MMU fetches PTE from PT in memory&lt;/li&gt;
&lt;li&gt;PTE absent, MMU triggers &lt;em&gt;page fault exception&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Handler identifies victim page (if dirty, page it out to disk)&lt;/li&gt;
&lt;li&gt;Handler pages in new page; update PTE&lt;/li&gt;
&lt;li&gt;Handler returns to original process; restart faulting instruction&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Multithreading Basics&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.adobe.com/content/docs/en/aem/6-0/manage/capacity-guide/capacity-guide/_jcr_content/par/image_7.img.png/1346079308000.png&quot; alt=&quot;thread x throughput&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;linear increase -&amp;gt; increase slowdown -&amp;gt; degrade&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Parallelism within Processor&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Example
&lt;code&gt;x = x * (data[i] * data[i+1])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Limitations

&lt;ul&gt;
&lt;li&gt;# of functional units&lt;/li&gt;
&lt;li&gt;Latency of operation causing dependency&lt;/li&gt;
&lt;li&gt;# of registers to hold temporaries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Connection between Memory Access, Memory Allocation and Cache Efficiency&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Dynamic memory allocation

&lt;ul&gt;
&lt;li&gt;Space utilization&lt;/li&gt;
&lt;li&gt;Time complexity on malloc/free&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory-wall&lt;/strong&gt;: growing desparity of CPU &amp;amp; RAM speeds&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;Caching effectiveness important&lt;/li&gt;
&lt;li&gt;Padding not cache-friendly: avoid internal fragmentation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;False sharing&lt;/strong&gt;: occurs when &amp;gt;= 2 processors access different data in &lt;em&gt;same cache line&lt;/em&gt;, and at least one of them writes

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory arenas&lt;/strong&gt;: 1 thread only use memory from a single arena (continuous blocks of memory)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Cache Coherence&lt;/h2&gt;

&lt;h3&gt;Cache Coherence Overview&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Shared memory machines

&lt;ul&gt;
&lt;li&gt;Small # of processors: shared memory with coherent caches (SMP)&lt;/li&gt;
&lt;li&gt;Large # of processors: distributed shared memory with coherent caches (CC-NUMA)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Caches in multiprocessors

&lt;ul&gt;
&lt;li&gt;Same line appears in &amp;gt;= 2 caches, one write, others read&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;CC Protocols&lt;/h3&gt;

&lt;h4&gt;MSI Protocol&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Input/Action
                PrWr/BuRdX
    ⬈-----------------------------------⬊
      PrRd/BuRd     PrRd/-  PrWr/BuRdX
I ------------------&amp;gt; S ------------------&amp;gt; M
  &amp;lt;------------------   &amp;lt;------------------
      BuRdX/-       BuRd/-  BuRd/Flush
    ⬉-----------------------------------⬋
                BuRdX/Flush
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Assumption: bus based architecture

&lt;ul&gt;
&lt;li&gt;Bus is reliable, ordered broadcast bus (snooping bus)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;States of a cache line

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invalid&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shared&lt;/strong&gt;: one of many cached copies&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modified&lt;/strong&gt;: sole valid copy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Processor events

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PrRd&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PrWr&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bus Transactions

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BusRd&lt;/strong&gt;: simply asks for copy&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BusRdX&lt;/strong&gt;: asks for copy to modify&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flush&lt;/strong&gt;: updates memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Actions

&lt;ul&gt;
&lt;li&gt;Update state, perform bus transaction, flush value onto bus&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;Reading &amp;amp; modifying data is 2 bus xactions (BusRd(I-&amp;gt;S) + BusRdX)&lt;/li&gt;
&lt;li&gt;A write to &lt;em&gt;shared&lt;/em&gt;_ will generate invalidation request&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;MESI Protocol&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;One more state

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Exclusive/Exclusive-clean&lt;/strong&gt;: only this cache has copy but not modified&lt;/li&gt;
&lt;li&gt;A write to &lt;em&gt;exclusive&lt;/em&gt;_ will not generate invalidation request&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Typically built on write-back caches&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Locality in Parallel Programming&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Cache-aware access

&lt;ul&gt;
&lt;li&gt;Cache invalidation traffic important&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Awareness of data placement in memory

&lt;ul&gt;
&lt;li&gt;Important for CC-NUMA because long memory latencies for non-local memory access&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Awareness of data assignment to threads when load balancing&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    a[i] = i;
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++)
    b[i] = f(a[i-1], a[i]);

-&amp;gt; better locality
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) 
    a[i] = i;
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++)
    b[i] = f(a[i-1], a[i]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;True &amp;amp; False Sharing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;True sharing&lt;/strong&gt;: 2 threads accessing &lt;strong&gt;same&lt;/strong&gt; locations on one block&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;False sharing&lt;/strong&gt;: 2 threads accessing &lt;strong&gt;distinct&lt;/strong&gt; locations on one block&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Block will ping-pong

&lt;ul&gt;
&lt;li&gt;Ensure they map to separate cache blocks e.g. insert padding&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Example&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# processor = 2, cache line fit 8 elements
#pragma omp parallel for schedule(cyclic) 
for (i = 0; i &amp;lt; n; i++)
    a[i] = b[i];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-iii.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-iii.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Threads &amp; Parallel Programming II</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Locking Parallelization Options&lt;/li&gt;
&lt;li&gt;Basic Parallel Improvements

&lt;ol&gt;
&lt;li&gt;OpenMP &amp;amp; Code Restructuring Optimizations&lt;/li&gt;
&lt;li&gt;Characteristics of Parallel Code&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Locking Parallelization Options&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Course-grained locking: easy to program; limited parallelism&lt;/li&gt;
&lt;li&gt;Fine-grained locking: hard to program; good parallelism

&lt;ul&gt;
&lt;li&gt;Deadlock, fault tolerance, priority inversion, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Transactional memory: easy to program, promise good parallelism

&lt;ul&gt;
&lt;li&gt;Checkpoints execution -&amp;gt; detects conflicts -&amp;gt; commits/aborts and reexecutes&lt;/li&gt;
&lt;li&gt;Machine limits: abort if transaction too long and has to evict L1 cahce&lt;/li&gt;
&lt;li&gt;Overhead&lt;/li&gt;
&lt;li&gt;Bookkeeping&lt;/li&gt;
&lt;li&gt;Failure recovery&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Basic Parallel Improvements&lt;/h2&gt;

&lt;h3&gt;OpenMP &amp;amp; Code Restructuring Optimizations&lt;/h3&gt;

&lt;p&gt;Compiler &amp;amp; library implementation.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;annotated source -&amp;gt; OpenMP compiler -&amp;gt; sequential program
                                        (compiler switch)
                                    -&amp;gt; parallel program
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;OpenMP Directives&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Parallelization directives

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#pragma omp parallel for&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;#pragma omp parallel for schedule &amp;lt;block/cyclic&amp;gt;&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Data environment directives

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shared&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;threadprivate&lt;/code&gt;, &lt;code&gt;reduction&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Code Restructuring Optimizations&lt;/h4&gt;

&lt;p&gt;Eliminate/reduce dependences by restructuring the code.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Private variables&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#pragma omp parallel for private(tmp)
for (i = 0; i &amp;lt; n; i++) { 
    tmp = a[i];
    a[i] = b[i];
    b[i] = tmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Induction variable elimination&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0, index = 0; i &amp;lt; n; i++) { 
    index += i;
    a[i] = b[index];
}

-&amp;gt;
#pragma omp parallel for
for (i = 0, index = 0; i &amp;lt; n; i++) { 
    a[i] = b[i*(i+1)/2];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop splitting&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0, index = 0; i &amp;lt; n; i++) { 
    index += f(i);
    b[i] = g(a[index]);
}

-&amp;gt;
for (i = 0; i &amp;lt; n; i++) { 
    index[i] += f(i);
}
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) { 
    b[i] = g(a[index[i]]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;while (*a) { 
    process(a); 
    a++;
}

-&amp;gt;
for (count = 0, p = a; p != NULL; count++, p++);
#pragma omp parallel for
for (i = 0; i &amp;lt; count; i++) 
    process(a[i]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop reordering&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (k = 0; k &amp;lt; n; k++) 
    for (i = 0; i &amp;lt; n; i++)
        for (j = 0; j &amp;lt; n; j++)
            a[i][j] += b[i][k] + c[k][j];

-&amp;gt;
#pragma omp parallel for 
for (i = 0; i &amp;lt; n; i++)
    for (j = 0; j &amp;lt; n; j++)
        for (k = 0; k &amp;lt; n; k++)
            a[i][j] += b[i][k] + c[k][j];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop Fusion: reduce loop startup &amp;amp; thread overhead&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) 
    a[i] = b[i];
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) 
    c[i] = b[i]^2;

-&amp;gt;
#pragma omp parallel for
for (i = 0; i &amp;lt; n; i++) {
    a[i] = b[i];
    c[i] = b[i]^2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Loop peeling&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0, wrap = n; i &amp;lt; n; i++) { 
    b[i] = a[i] + a[wrap]; 
    wrap = i;
}

-&amp;gt;
b[0] = a[0] + a[n];
#pragma omp parallel for 
for (i = 1; i &amp;lt; n; i++) {
    b[i] = a[i] + a[i-1]; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;for (i = 0; i &amp;lt; n; i++) 
    a[i+m] = a[i] + b[i];

-&amp;gt;
if (m &amp;gt; n) {
    #pragma omp parallel for 
    for (i = 0; i &amp;lt; n; i++)
        a[i+m] = a[i] + b[i]; 
} else {
    ... cannot be parallelized
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Characteristics of Parallel Code&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Granularity&lt;/li&gt;
&lt;li&gt;Load balance&lt;/li&gt;
&lt;li&gt;Locality&lt;/li&gt;
&lt;li&gt;Communication &amp;amp; synchronization&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Granularity&lt;/h4&gt;

&lt;p&gt;Size of program unit executed by a single processor.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fine granularity

&lt;ul&gt;
&lt;li&gt;Ability to use many processors&lt;/li&gt;
&lt;li&gt;Finer-grain load balancing&lt;/li&gt;
&lt;li&gt;Increased overhead&lt;/li&gt;
&lt;li&gt;More critical section accesses &amp;amp; contention&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Load balance&lt;/h4&gt;

&lt;p&gt;Different in execution time between processors between barriers.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Execution time predictable?

&lt;ul&gt;
&lt;li&gt;Regular data parallel: yes&lt;/li&gt;
&lt;li&gt;Irregular data paralle or pipeline: perhaps&lt;/li&gt;
&lt;li&gt;Task queue: no&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static load balancing&lt;/strong&gt;: done once by programmer

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block&lt;/strong&gt;: good locality, poor load balance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cyclic&lt;/strong&gt;: good load balance, poor locality&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block-cyclic&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Fine for regular data parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic load balancing&lt;/strong&gt;: done at runtime; task queue

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Centralized&lt;/strong&gt;: easy to program, good load balance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed&lt;/strong&gt;: less communication/synchronization&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Task stealing&lt;/strong&gt;: extra overhead, difficult to program, better load balance&lt;/li&gt;
&lt;li&gt;Unpredictable execution times&lt;/li&gt;
&lt;li&gt;Regular data parallel in heterogeneous/multitasked environment&lt;/li&gt;
&lt;li&gt;Usually high overhead&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Semi-static load balancing&lt;/strong&gt;: done once at runtime

&lt;ul&gt;
&lt;li&gt;Partition computation using measurements of cost of program parts&lt;/li&gt;
&lt;li&gt;Done once, done every iteration, done every n iterations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-ii.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/threads-and-parallel-programming-ii.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>Locks &amp; Cache Coherence</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Locks &amp;amp; Cache Coherence

&lt;ol&gt;
&lt;li&gt;Atomic Operations&lt;/li&gt;
&lt;li&gt;Ticket Lock&lt;/li&gt;
&lt;li&gt;Array-Based Queueing Locks&lt;/li&gt;
&lt;li&gt;List-Based Queueing Locks (MCS Locks)&lt;/li&gt;
&lt;li&gt;Summary&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Locks &amp;amp; Cache Coherence&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Criteria for evaluating spin locks

&lt;ul&gt;
&lt;li&gt;Scalability &amp;amp; induced network load&lt;/li&gt;
&lt;li&gt;Single-processor latency&lt;/li&gt;
&lt;li&gt;Space requirements&lt;/li&gt;
&lt;li&gt;Fairness&lt;/li&gt;
&lt;li&gt;Implementability with available atomic operations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Atomic Operations&lt;/h3&gt;

&lt;p&gt;H/W support is required to implement synchronization primitives.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Test &amp;amp; set&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Steps

&lt;ol&gt;
&lt;li&gt;Load old value to register&lt;/li&gt;
&lt;li&gt;Set value in memory to 1&lt;/li&gt;
&lt;li&gt;Return old value&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lock implementation (TAS)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;struct lock { 
    int held = 0;
}
void acquire (lock) {
    while (test-and-set(&amp;amp;lock-&amp;gt;held)); 
}
void release (lock) { 
    lock-&amp;gt;held = 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Contentions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 threads contending to acquire lock &amp;amp; modify lock to 1&lt;/li&gt;
&lt;li&gt;Caused by spinning on &lt;em&gt;global&lt;/em&gt; variables&lt;/li&gt;
&lt;li&gt;Poor scalability&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Improved lock implementation (TATAS)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;void test_and_test_and_set (lock) { 
    do {
        while (lock-&amp;gt;held == 1) // only read
            ; // spin 
        }
    } while (test_and_set(lock-&amp;gt;held));
}
void release (lock) {
    lock-&amp;gt;held = 0; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Further improved lock implementation (TAS with backoff)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;while test&amp;amp;set (L) fails { 
    pause (delay);
    delay = delay * 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Swap&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fetch &amp;amp; Op&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compare &amp;amp; swap&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Ticket Lock&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;my_ticket = fetch_and_increment(next_ticket); 
while (my_ticket != now_serving)
    pause(); //back-off
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Improvements

&lt;ul&gt;
&lt;li&gt;Only 1 process try to get lock upon release&lt;/li&gt;
&lt;li&gt;Only 1 process have read miss upon release (not achieved)&lt;/li&gt;
&lt;li&gt;Locked acquired in FIFO (fairness)&lt;/li&gt;
&lt;li&gt;Further improvement: proportional backoff&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;2 counters: &lt;code&gt;next_ticket&lt;/code&gt;, &lt;code&gt;now_serving&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lock acquire: &lt;code&gt;fetch-and-increment&lt;/code&gt; on &lt;code&gt;next_ticket&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lock release: increment on &lt;code&gt;now_serving&lt;/code&gt; -&amp;gt; cuases contention&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Array-Based Queueing Locks&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;Queue &lt;code&gt;slots[N]&lt;/code&gt;, each element lies in different cache line

&lt;ul&gt;
&lt;li&gt;Has-lock (HL)&lt;/li&gt;
&lt;li&gt;Must-wait (MW)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next_slot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Steps

&lt;ol&gt;
&lt;li&gt;Incoming processes enqueued (&lt;code&gt;my_place = fetch-and-inc(next_slot)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Lock-acquire: &lt;code&gt;while(slots[my_place] == MW);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lock-release: &lt;code&gt;slots[(my_place+1)%N] = HL;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;Atomic ops &lt;code&gt;fetch-and-inc&lt;/code&gt; to obtain location to spin on&lt;/li&gt;
&lt;li&gt;Each CPU spins on different location in a distinct cache line&lt;/li&gt;
&lt;li&gt;Each CPU clears the lock for its successor (must-wait -&amp;gt; has-lock)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Space complexity &lt;code&gt;O(N)&lt;/code&gt;(bounded by # of processors)&lt;/li&gt;
&lt;li&gt;Queue is static&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;List-Based Queueing Locks (MCS Locks)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Steps&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Incoming processes enqueued (&lt;code&gt;predecessor = fetch-and-store(L,me)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Lock-acquire: wait for predecessor to signal&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lock-release: remove &lt;code&gt;me&lt;/code&gt; from &lt;code&gt;L&lt;/code&gt; &amp;amp; signal successor&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If no successor, spin on myself using &lt;code&gt;compare-and-swap(L,me,nil)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;L -&amp;gt; me
     new

# compare-and-swap fails
L    me
  ⬊  
     new

# spin on while I-&amp;gt;next = nil
L    me
  ⬊   ↓
     new
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Properties&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lock points at tail of queue&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compare-and-swap&lt;/strong&gt; for detection if it is the only processor in queue &amp;amp; atomic removal of self from queue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pros&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Spins on local flag variables only&lt;/li&gt;
&lt;li&gt;Requires a small constant amount of space per lock (bounded by # of requests)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Summary&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TAS&lt;/strong&gt; with proper backoffs

&lt;ul&gt;
&lt;li&gt;Scale well&lt;/li&gt;
&lt;li&gt;More network load&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ticket lock&lt;/strong&gt; with proper backoffs 

&lt;ul&gt;
&lt;li&gt;Scale well&lt;/li&gt;
&lt;li&gt;More network load&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Array-based locks&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Scales best&lt;/li&gt;
&lt;li&gt;Least interconnect contention&lt;/li&gt;
&lt;li&gt;High space requirement for large numbers of CPUs&lt;/li&gt;
&lt;li&gt;Fair&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MCS&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Scales best&lt;/li&gt;
&lt;li&gt;Least interconnect contention&lt;/li&gt;
&lt;li&gt;Low space requirement&lt;/li&gt;
&lt;li&gt;Fair&lt;/li&gt;
&lt;li&gt;Benefits from &lt;strong&gt;compare-and-swap&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/optimization/2016/11/27/locks-and-cache-coherence.html</link>
        <guid isPermaLink="true">/blog/notes/optimization/2016/11/27/locks-and-cache-coherence.html</guid>
        
        <category>Optimization</category>
        
        <category>ECE454</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Optimization</category>
        
      </item>
    
      <item>
        <title>NP-Complete Problems</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Search Problems

&lt;ol&gt;
&lt;li&gt;Satisfiability Problem (SAT)&lt;/li&gt;
&lt;li&gt;Traveling Salesman Problem (TSP)&lt;/li&gt;
&lt;li&gt;Integer Linear Programming (ILP)

&lt;ul&gt;
&lt;li&gt;Zero-One Equations (ZOE)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Three-Dimensional Matching (3D Matching)&lt;/li&gt;
&lt;li&gt;Independent Set&lt;/li&gt;
&lt;li&gt;Clique&lt;/li&gt;
&lt;li&gt;Knapsack Problem&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;NP-Complete Problems&lt;/li&gt;
&lt;li&gt;Reductions

&lt;ol&gt;
&lt;li&gt;Generalization/Special Case&lt;/li&gt;
&lt;li&gt;Rudrata Path -&amp;gt; Rudrata Cycle&lt;/li&gt;
&lt;li&gt;3SAT -&amp;gt; Independent Set&lt;/li&gt;
&lt;li&gt;SAT -&amp;gt; 3SAT&lt;/li&gt;
&lt;li&gt;Independent Set -&amp;gt; Vertex Cover&lt;/li&gt;
&lt;li&gt;Independent Set -&amp;gt; Clique&lt;/li&gt;
&lt;li&gt;3SAT -&amp;gt; 3D Matching&lt;/li&gt;
&lt;li&gt;3D Matching -&amp;gt; ZOE&lt;/li&gt;
&lt;li&gt;ZOE -&amp;gt; Subset Sum&lt;/li&gt;
&lt;li&gt;ZOE -&amp;gt; Rudrata Cycle&lt;/li&gt;
&lt;li&gt;Rudrata Cycle -&amp;gt; TSP&lt;/li&gt;
&lt;li&gt;Any Problem in NP -&amp;gt; SAT&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Search Problems&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Components

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Instance I&lt;/strong&gt;: input data specifying the problem&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solution S&lt;/strong&gt;: object meeting particular specification&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Algorithm C&lt;/strong&gt; s.t. &lt;code&gt;C(I,S) = true&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;S&lt;/code&gt; is a solution to &lt;code&gt;I&lt;/code&gt;; &lt;em&gt;quick checking&lt;/em&gt; &amp;lt;=&amp;gt; &lt;code&gt;C&lt;/code&gt; runs in polynomial-time in &lt;code&gt;|I|&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Can be reduced to/from &lt;strong&gt;optimization problems&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Satisfiability Problem (SAT)&lt;/h4&gt;

&lt;p&gt;Boolean formula in conjunctive normal form (CNF), find a set of assignments s.t. every clause contains a literal that is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;Traveling Salesman Problem (TSP)&lt;/h4&gt;

&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; vertices and all connected with a cost &lt;code&gt;c&lt;/code&gt;, find a permutation of vertices s.t. the total cost is at most the budget &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Search problem is polynomial-time checkable:

&lt;ul&gt;
&lt;li&gt;Each vertex is visited exactly once&lt;/li&gt;
&lt;li&gt;Total cost &amp;lt;= &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CANNOT check optimality

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Binary search&lt;/strong&gt; to find optimum cost&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Integer Linear Programming (ILP)&lt;/h4&gt;

&lt;p&gt;Given a set of linear inequalities &lt;code&gt;Ax ≤ b&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;m × n&lt;/code&gt; matrix and &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;m-vector&lt;/code&gt;; an objective function specified by an &lt;code&gt;n-vector&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;; and finally, a goal &lt;code&gt;g&lt;/code&gt;. Find a nonnegative integer &lt;code&gt;n-vector&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;Ax ≤ b&lt;/code&gt; and &lt;code&gt;cx ≥ g&lt;/code&gt;.&lt;/p&gt;

&lt;h5&gt;Zero-One Equations (ZOE)&lt;/h5&gt;

&lt;p&gt;Find a vector &lt;code&gt;x&lt;/code&gt; of 0&amp;#39;s and 1&amp;#39;s satisfying &lt;code&gt;Ax = 1&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;m × n&lt;/code&gt; matrix with 0−1 entries and &lt;code&gt;1&lt;/code&gt; is the &lt;code&gt;m-vector&lt;/code&gt; of all 1&amp;#39;s.&lt;/p&gt;

&lt;h4&gt;Three-Dimensional Matching (3D Matching)&lt;/h4&gt;

&lt;p&gt;Find a matching (&lt;code&gt;n&lt;/code&gt; disjoint edges) between 3 sets of &lt;code&gt;n&lt;/code&gt; nodes.&lt;/p&gt;

&lt;h4&gt;Independent Set&lt;/h4&gt;

&lt;p&gt;Given a graph and an integer &lt;code&gt;g&lt;/code&gt;, find &lt;code&gt;g&lt;/code&gt; vertices that are independent, i.e. no edges between them.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dual: &lt;strong&gt;vertex cover&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Special case of &lt;strong&gt;set cover&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Clique&lt;/h4&gt;

&lt;p&gt;Given a graph and a goal &lt;code&gt;g&lt;/code&gt;, find a set of &lt;code&gt;g&lt;/code&gt; vertices such that the induced subgraph is complete.&lt;/p&gt;

&lt;h4&gt;Knapsack Problem&lt;/h4&gt;

&lt;p&gt;Given integer weights &lt;code&gt;w1,...,wn&lt;/code&gt; and integer values &lt;code&gt;v1, ..., vn&lt;/code&gt; for &lt;code&gt;n&lt;/code&gt; items. Find a set of items with total weight &amp;lt;= &lt;code&gt;W&lt;/code&gt; and total value &amp;gt;= &lt;code&gt;g&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Unary knapsack&lt;/strong&gt;: encode integers in unary&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Subset sum&lt;/strong&gt;: item&amp;#39;s value equals its weight

&lt;ul&gt;
&lt;li&gt;Find a subset of items that adds up to exactly &lt;code&gt;W&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;NP-Complete Problems&lt;/h2&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: center&quot;&gt;Hard problems (NP-complete)&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Easy problems (in P)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;3SAT&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;2SAT, HORN SAT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;TRAVELING SALESMAN PROBLEM&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;MINIMUM SPANNING TREE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;LONGEST PATH&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;SHORTEST PATH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;3D MATCHING&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;BIPARTITE MATCHING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;KNAPSACK&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;UNARY KNAPSACK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;INDEPENDENT SET&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;INDEPENDENT SET on trees&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;INTEGER LINEAR PROGRAMMING&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;LINEAR PROGRAMMING&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;RUDRATA PATH&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;EULER PATH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: center&quot;&gt;BALANCED CUT&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;MINIMUM CUT&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;NP-complete problems can be reduced to/from any of the others.&lt;/p&gt;

&lt;h4&gt;P, NP, NP-Complete&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NP&lt;/strong&gt;: class of search problems s.t. any proposed solution can be quickly checked for correctness&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;: class of search problems that can be solved in polynomial time, and correctly reports no solution if so&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;: search problem where all other search problems reduce to it&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|--------NP-------|
|P|...|NP-complete|
      |-------NP Hard-------|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Reductions&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# f, h are polynomial transformation algorithms

    |----------------Algorithm for A-----------------|
I ---&amp;gt; f --f(I)--&amp;gt; Algorithm for B --S of f(I)--&amp;gt; h --&amp;gt; h(S) of I
                                   -------------------&amp;gt; No solution to I
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Reduction from A to B:
    A --&amp;gt; B
If we know A is hard, then B is hard as well. All problems in NP reduce to B via A.

If A --&amp;gt; B and B --&amp;gt; C, then A --&amp;gt; C
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;                                All NP
                                   |
                                  SAT
                                   |
                                  3SAT
                                  ⬋  ⬊
                    Independent Set  3D Matching
                        ⬋  ⬊            |
            Vertex Cover    Clique     ZOE
                                     ⬋  |  ⬊
                            Subset Sum ILP Rudrata Cycle
                                                |
                                               TSP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Generalization/Special Case&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Circuit SAT&lt;/strong&gt; is a generalization of &lt;strong&gt;SAT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SAT&lt;/strong&gt; is a generalization of &lt;strong&gt;3SAT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set cover&lt;/strong&gt; is a generalization of &lt;strong&gt;vertex cover&lt;/strong&gt; and &lt;strong&gt;3D matching&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ILP&lt;/strong&gt; is a generatlization of &lt;strong&gt;ZOE&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Rudrata Path -&amp;gt; Rudrata Cycle&lt;/h4&gt;

&lt;p&gt;Given a graph, is there a path starting at s and ending at t that goes through each vertex exactly once?&lt;br&gt;
-&amp;gt; Is there a cycle that passes through each vertex exactly once?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reduce &lt;code&gt;G&lt;/code&gt; in rudrata path to &lt;code&gt;G&amp;#39;&lt;/code&gt; in rudrata cycle:

&lt;ul&gt;
&lt;li&gt;Add vertex &lt;code&gt;x&lt;/code&gt; and edges &lt;code&gt;(s,x)&lt;/code&gt;, &lt;code&gt;(x,t)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3SAT -&amp;gt; Independent Set&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt; Graph &lt;code&gt;G&lt;/code&gt; has a triangle for each clause (or an edge if clause of two literals), with vertices labeled by the clause&amp;#39;s literals&lt;/li&gt;
&lt;li&gt;Add edges between any two vertices that represent opposite literals&lt;/li&gt;
&lt;li&gt;Goal &lt;code&gt;g&lt;/code&gt; is the number of clauses&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;SAT -&amp;gt; 3SAT&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt; Any clause with &amp;gt; 3 literals in instance &lt;code&gt;I&lt;/code&gt; of SAT, transform:&lt;br&gt;
&lt;code&gt;(a1 ∨ a2 ∨ ... ∨ ak)  -&amp;gt; (a1 ∨ a2 ∨ y1)(~y1 ∨ a3 ∨ y2)...(~yk−3 ∨ ak−1 ∨ ak)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Further restriction: no variable appears in &lt;code&gt;k&lt;/code&gt; &amp;gt; 3 clauses

&lt;ul&gt;
&lt;li&gt;Replace variable &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x1, x2, ..., xk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add clauses &lt;code&gt;(~x1 ∨ x2)(~x2 ∨ x3)...(~xk ∨ x1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Independent Set -&amp;gt; Vertex Cover&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Independent set &lt;code&gt;S&lt;/code&gt;, vertex cover &lt;code&gt;V - S&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Independent Set -&amp;gt; Clique&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Map instance &lt;code&gt;(G, g)&lt;/code&gt; of independent set to complement graph &lt;code&gt;(~G, g)&lt;/code&gt; of clique&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;3SAT -&amp;gt; 3D Matching&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cs.cmu.edu/%7Eckingsf/bioinfo-lectures/3dm.pdf&quot;&gt;CMU Notes&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;3D Matching -&amp;gt; ZOE&lt;/h4&gt;

&lt;p&gt;Given an &lt;code&gt;m × n&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; with 0−1 entries, and we must find a 0−1
vector &lt;code&gt;x = (x1, ..., xn)&lt;/code&gt; such that the &lt;code&gt;m&lt;/code&gt; equations &lt;code&gt;Ax = 1&lt;/code&gt; are satisfied.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let columns of &lt;code&gt;A&lt;/code&gt; be triples in 3D matching&lt;/li&gt;
&lt;li&gt;Let rows of &lt;code&gt;A&lt;/code&gt; be all matching items&lt;/li&gt;
&lt;li&gt;Aij is 1 if the triple inclues the item&lt;/li&gt;
&lt;li&gt;Choose a set of triples &lt;code&gt;X&lt;/code&gt; to be 1 s.t. the resulting column is all 1 (i.e. all items chosen once)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;ZOE -&amp;gt; Subset Sum&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Let columns of &lt;code&gt;A&lt;/code&gt; be representations of (n+1)-ary integers&lt;/li&gt;
&lt;li&gt;Choose a set of integers s.t. sum is 11...1 (won&amp;#39;t be affected by &lt;em&gt;carry&lt;/em&gt; because base &lt;code&gt;n+1&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;ZOE -&amp;gt; ILP&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;Ax ≤ b&lt;/code&gt;, rewrite each equation as 2 inequalities&lt;/li&gt;
&lt;li&gt;Add for each variable &lt;code&gt;xi&lt;/code&gt; inequalities &lt;code&gt;xi ≤ 1&lt;/code&gt; and &lt;code&gt;−xi ≤ 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;ZOE -&amp;gt; Rudrata Cycle&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ZOE -&amp;gt; Rudrata cycle with paired edges&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each variable &lt;code&gt;xi&lt;/code&gt; =&amp;gt; two parallel edges (xi = 1 and 0)&lt;/li&gt;
&lt;li&gt;Each equation &lt;code&gt;xj1 + ... + xjk = 1&lt;/code&gt;involving &lt;code&gt;k&lt;/code&gt; variables =&amp;gt; &lt;code&gt;k&lt;/code&gt; parallel edges&lt;/li&gt;
&lt;li&gt;Every equation and every variable xi appearing in it, add to &lt;code&gt;C&lt;/code&gt; the pair &lt;code&gt;(e,e&amp;#39;)&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt; = the edge &lt;code&gt;xi&lt;/code&gt; in that equation, &lt;code&gt;e&amp;#39;&lt;/code&gt; = the edge xi = 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Rudrata cycle with paired edges -&amp;gt; Rudrata cycle&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Replace every pair &lt;code&gt;(e,e&amp;#39;)&lt;/code&gt; as &lt;code&gt;({a,b},{c,t})&lt;/code&gt;with:
&lt;img src=&quot;http://i40.tinypic.com/1pfazb.png&quot; alt=&quot;gadget&quot;&gt;&lt;/li&gt;
&lt;li&gt;Every other pair involving &lt;code&gt;{a,b}&lt;/code&gt;, set it to be &lt;code&gt;{a,f}&lt;/code&gt; and repeat the replacement&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Rudrata Cycle -&amp;gt; TSP&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt; = set of cities&lt;/li&gt;
&lt;li&gt;Distance between &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;{u,v}&lt;/code&gt; is an edge; otherwise &lt;code&gt;1 + α&lt;/code&gt; for some &lt;code&gt;α &amp;gt; 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Budget = &lt;code&gt;|V|&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;α = 1&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;TSP satisfies triangle inequality &lt;code&gt;dij + djk ≥ dik&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can be approximated&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;α&lt;/code&gt; is large

&lt;ul&gt;
&lt;li&gt;Solution either has cost &lt;code&gt;n&lt;/code&gt; or less, or has cost at least &lt;code&gt;n + α&lt;/code&gt; (&lt;strong&gt;gap property&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Any Problem in NP -&amp;gt; SAT&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Circuit SAT&lt;/p&gt;

&lt;p&gt;Given a circuit, find a truth assignment for the unknown inputs s.t. the output gate evaluates to T, or report that no such assignment exists.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;- AND/OR gates: indegree 2
- NOT gates: indegree 1
- Known input gates: no incoming edges, labeled F/T
- Unknown input gates: no incoming edges, labeled '?'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;SAT -&amp;gt; Circuit SAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clause: OR of literals&lt;/li&gt;
&lt;li&gt;Joining clauses: AND of clauses&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Circuit SAT -&amp;gt; SAT&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;T: g
F: ~g
OR: (g v ~h1)(g v ~h2)(~g v h1 v h2)
AND: (~g v h1)(~g v h2)(g v ~h1 v ~h2)
NOT: (g v h)(~g v ~h)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Any Problem in NP -&amp;gt; Circuit SAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Problem in NP is a search problem &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solution checking is polynomial-time&lt;/li&gt;
&lt;li&gt;Polynomial algorithm can be rendered as a circuit&lt;/li&gt;
&lt;li&gt;Given instance &lt;code&gt;I&lt;/code&gt; and solution &lt;code&gt;S&lt;/code&gt; of problem &lt;code&gt;A&lt;/code&gt;, construct a polynomial-time circuit with known inputs the bits of &lt;code&gt;I&lt;/code&gt;, unknown inputs the bits of &lt;code&gt;S&lt;/code&gt; s.t. output is T&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.fas.harvard.edu/%7Elibcs124/CS/lec7.pdf&quot;&gt;Harvard Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard&quot;&gt;What are the differences between NP, NP-complete, and NP-hard?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mlnotes.com/2013/04/29/npc.html&quot;&gt;mlnotes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://staff.ustc.edu.cn/%7Ecsli/graduate/algorithms/book6/chap36.htm&quot;&gt;USTC Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/26/np-complete-problems.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/26/np-complete-problems.html</guid>
        
        <category>np-complete</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Linear Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Linear Programming &amp;amp; Reduction Overview&lt;/li&gt;
&lt;li&gt;Duality&lt;/li&gt;
&lt;li&gt;Simplex Algorithm&lt;/li&gt;
&lt;li&gt;Circuit Evaluation&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Linear Programming &amp;amp; Reduction Overview&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;LP &amp;amp; Reductions ---&amp;gt; Flows &amp;amp; matching
                ---&amp;gt; Duality            ---&amp;gt; Games
                ---&amp;gt; Simplex
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Linear Programming&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Objective function

&lt;ul&gt;
&lt;li&gt;Line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maximization&lt;/strong&gt; or &lt;strong&gt;minimization&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Constraints

&lt;ul&gt;
&lt;li&gt;Feasible region&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Equations&lt;/strong&gt; or &lt;strong&gt;inequalities&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Optimum achieved at a &lt;strong&gt;vertex of feasible region&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Simplex method&lt;/strong&gt;: &lt;em&gt;hill-climbing&lt;/em&gt; on vertices

&lt;ul&gt;
&lt;li&gt;Local = global optimality for linear functions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Reduction&lt;/h4&gt;

&lt;p&gt;If any subroutine for task Q can also be used to solve P, we say &lt;strong&gt;P reduces to Q&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;x ---&amp;gt; Preprocess --y-&amp;gt; Algorithm for Q --Q(y)--&amp;gt; Postprocess ---&amp;gt; P(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Variants of Linear Programming&lt;/h4&gt;

&lt;p&gt;Reduction of variants into &lt;em&gt;standard form&lt;/em&gt;:  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maximization to minimization:

&lt;ul&gt;
&lt;li&gt;Coefficients * (-1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Inequality to equation:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sum_i_to_n(ai*xi) &amp;lt;= b&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;sum_i_to_n(ai*xi) + s &amp;lt;= b &amp;amp;&amp;amp; s &amp;gt;= 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; = slack variable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Equation to inequality:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ax = b&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;ax &amp;lt;= b &amp;amp;&amp;amp; ax &amp;gt;= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Unsigned variables to signed:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; &amp;lt;=&amp;gt; &lt;code&gt;x+ - x-&lt;/code&gt; where &lt;code&gt;x+, x- &amp;gt;= 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;min cTx s.t. Ax = b and x ≥ 0&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Matrix-Vector Notation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Objective function:
    c^Tx
    c = [c1, c2, ...], x = [x1, x2, ...]
Constraints:
    Ax &amp;lt;= b
    A = [[c11, c12, ...], [c21, c22, ...], ...], b = [b1, b2, ...]
x &amp;gt;= 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Duality&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Primal LP:
max cTx 
Ax ≤ b 
x ≥ 0

# Dual LP:
min yTb 
yTA ≥ cT 
y ≥ 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Primal LP:
max c1x1 +···+cnxn 
ai1x1+···+ainxn ≤ bi for i ∈ I (inequalities)
ai1x1+···+ainxn = bi for i ∈ E (equalities)
xj ≥ 0 for j ∈ N

# Dual LP:
min b1y1 +···+bmym 
a1jy1+···+amjym ≥ cj for j ∈ N 
a1jy1+···+amjym = cj for j !∈ N 
yi ≥ 0 for i ∈ I # equalities can have unrestricted variables (signed)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Duality Theorm&lt;/h4&gt;

&lt;p&gt;If a linear program has a bounded optimum, then so does its dual, and the two optimum values coincide.&lt;/p&gt;

&lt;h4&gt;Duality in Shortest-Path Problem&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://math.stackexchange.com/questions/861079/shortest-path-problem-dual-formulation-and-proof-of-total-unimodularity&quot;&gt;StackExchange&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Shortest_path_problem#Linear_programming_formulation&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;max xs - xt
|xu - xv| &amp;lt;= w_uv for all edges {u,v}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Simplex Algorithm&lt;/h2&gt;

&lt;h4&gt;Visualization&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;let v be any vertex of the feasible region
while there is a neighbor v' of v with better objective value:
    set v = v'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;x1, ..., xn variables -&amp;gt; n-tuple in n-dimensional space
A linear equation     -&amp;gt; hyperplane in R^n
A linear inequality   -&amp;gt; half-space in R^n
Linear program        -&amp;gt; convex polyhedron in R^n; intersection of all half-spaces
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Vertex: 
    Pick a subset of the inequalities. A vertex is a unique point that satisfies them with equality, and this point happens to be feasible.

Each vertex is specified by a set of n inequalities. (n linear equations to uniquely identify a point)

Neighbor:
    Two vertices are neighbors if they have n-1 defining inequalities in common.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Algorithm&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;max cTx 
Ax ≤ b 
x ≥ 0

1. Set origin to be current vertex.
2. Check whether the current vertex is optimal, i.e. coordinates of local cost vector (c) all &amp;lt;= 0.
3. If so, halt. Else, determine where to move next by increasing some xi for which ci &amp;gt; 0 until we hit some other constraint.
4. Transform the next vertex into origin and repeat.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;Transformation into Origin&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;For inequality ai*x ≤ bi, to turn into yi ≥ 0:
    yi = bi - ai*x

Cost function:
    max cu + (c')^T y, cu = value of objective function at u, c' = transformed cost vector
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Issues&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;How to find the starting vertex?&lt;/p&gt;

&lt;p&gt;General LPs won&amp;#39;t always have inequalities with positive right-hand sides.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. Rewrite LP into standard form:
    min cTx s.t. Ax = b and x ≥ 0
2. Make sure right-hand sides of equations are nonnegative:
    if bi &amp;lt; 0, multiply both sides of the ith equation by -1
3. Create new LP:
    - Create m new artificial variables z1, ..., zm &amp;gt;= 0
    - Add zi to left-hand side of the ith equation
    - Objective function: minimize z1+...+zm
4. Starting vertex for new LP:
    zi = bi for all i, other variables 0
5. Run simplex on new LP

If zi+...+zm = 0:
    Optimum vertex of new LP = starting feasible vertex of original LP
Else:
    Original LP not feasible
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Degeneracy?&lt;/p&gt;

&lt;p&gt;An LP is &lt;strong&gt;degenerate&lt;/strong&gt; if in a basic feasible solution, one of the basic variables takes on a zero value.&lt;/p&gt;

&lt;p&gt;In geometry, this means there is an intersection of more than &lt;code&gt;n&lt;/code&gt; faces of the polyhedron.  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Problem:

&lt;ul&gt;
&lt;li&gt;May return &lt;strong&gt;suboptimal&lt;/strong&gt; degenerate vertex, because all neighbors are identical and no better objective&lt;/li&gt;
&lt;li&gt;May &lt;strong&gt;loop forever&lt;/strong&gt;, bacause if modify simplex, continue to hop from vertex to vertex without improvement&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perturbation&lt;/strong&gt;: change each &lt;code&gt;bi&lt;/code&gt; by a tiny random amount to &lt;code&gt;bi += εi&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unboundedness?&lt;/p&gt;

&lt;p&gt;Objective function can be arbitrarily large/small.  &lt;/p&gt;

&lt;p&gt;Simplex will discover it: when exploring the neighborhood of a vertex, taking out an inequality and adding another leads to underdetermined system of equations that has infinite solutions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Running Time&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Generic LP:
    max cTx s.t. Ax ≤ 0 and x ≥ 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;A vertex is where &lt;code&gt;n&lt;/code&gt; inequality constraints are satisfied with equality&lt;/li&gt;
&lt;li&gt;Each of its neighbors shares &lt;code&gt;n-1&lt;/code&gt; inequalities =&amp;gt; &lt;code&gt;n * m&lt;/code&gt; neighbors&lt;/li&gt;
&lt;li&gt;Finding cost &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Checking whether is a true vertex - solving &lt;code&gt;n&lt;/code&gt; equations in &lt;code&gt;n&lt;/code&gt; unknowns:

&lt;ul&gt;
&lt;li&gt;Gaussian elimination &lt;code&gt;O(n^3)&lt;/code&gt; =&amp;gt; total &lt;code&gt;O(nb^4)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;move to origin&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;O((m+n)n)&lt;/code&gt; overhead to rewrite&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max cu + (c&amp;#39;)^T y&lt;/code&gt;, pick any &lt;code&gt;c&amp;#39;i &amp;gt; 0&lt;/code&gt; to move to&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(mn)&lt;/code&gt; in total&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C(m+n,n)&lt;/code&gt; vertices =&amp;gt; upper bound on # of iterations&lt;/li&gt;
&lt;li&gt;So &lt;strong&gt;simplex is exponential&lt;/strong&gt;; but in practice not exponential&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Gaussian Elimination&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Gauss(E,X):
    # Input: A system E = {e1,...,en} of equations in n unknowns X = {x1,...,xn}:
    e1: a11x1 + a12x2 +···+ a1nxn = b1; ···; en: an1x1 + an2x2 +···+ annxn = bn 
    # Output: A solution of the system, if one exists

    if all coefficients ai1 are zero:
        halt with message &quot;either infeasible or not linearly independent&quot;
    if n = 1: return b1/a11

    choose the coefficient ap1 of largest magnitude, and swap equations e1, ep 
    for i = 2 to n:
        ei = ei  − (ai1/a11) * e1
    (x2, . . . , xn) = Gauss(E − {e1}, X − {x1}) 
    x1 = (b1 − sum_j&amp;gt;1(a1j * xj))/a11

    return (x1,...,xn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Circuit Evaluation&lt;/h2&gt;

&lt;p&gt;The most general problem solvable in polynomial time.  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|true| xg = 1
|false| xg = 0
|OR|  &amp;lt;- h   xg &amp;gt;= xh, xg &amp;gt;= xh'
      &amp;lt;- h'  xg &amp;lt;= xh + xh'
|AND| &amp;lt;- h   xg &amp;lt;= xh, xg &amp;lt;= xh'
      &amp;lt;- h'  xg &amp;gt;= xh + xh' - 1
|NOT| &amp;lt;- h   xg = 1 - xh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.utdallas.edu/%7Escniu/OPRE-6201/documents/LP4-Simplex.html&quot;&gt;The Simplex Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.yale.edu/homes/aspnes/pinewiki/LinearProgramming.html&quot;&gt;Yale LP Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pitt.edu/%7Ekaveh/Lin-programming-notes.pdf&quot;&gt;Pitt LP Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://courses.csail.mit.edu/6.854/06/scribe/s15.pdf&quot;&gt;MIT LP Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://home.ubalt.edu/ntsbarsh/opre640a/partIII.htm#rsppr&quot;&gt;UBalt Flow Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://neos-guide.org/content/diet-problem&quot;&gt;The Diet Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 24 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/algorithm/2016/11/24/linear-programming.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/11/24/linear-programming.html</guid>
        
        <category>linear programming</category>
        
        <category>algorithm</category>
        
        <category>CSC373</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Serverside Swift</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Basics

&lt;ol&gt;
&lt;li&gt;Terminologies&lt;/li&gt;
&lt;li&gt;Commands&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Docker Images

&lt;ol&gt;
&lt;li&gt;Image Types&lt;/li&gt;
&lt;li&gt;Create Images&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Docker Compose

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run Application&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Create Swift Package&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;swift package init&lt;/code&gt;&lt;br&gt;
&lt;code&gt;swift build&lt;/code&gt;&lt;br&gt;
&lt;code&gt;swift package generate-xcodeproj&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Package.swift&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;name: name of package
targets: binary files
dependencies: [
  .Package(url: &quot;url&quot;, majorVersion: version, minor: version)
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Swift Basics&lt;/h2&gt;

&lt;h5&gt;Strongly-Typed&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;var myVar = &amp;quot;string&amp;quot;&lt;/code&gt; or &lt;code&gt;var myVar: String&lt;/code&gt;&lt;br&gt;
&lt;code&gt;var myInt = Int(myVar)&lt;/code&gt; or &lt;code&gt;var myInt = (myVar as NSString).integerValue&lt;/code&gt;  &lt;/p&gt;

&lt;h5&gt;Constants &amp;amp; Variables&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;let const = value&lt;/code&gt; vs &lt;code&gt;var const = value&lt;/code&gt;&lt;/p&gt;

&lt;h5&gt;Class&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;myName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// unnamed parameter&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myStaticFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// named parameter&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;myStaticFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Building Swift Applicstions&lt;/h2&gt;

&lt;h4&gt;Targets&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Library&lt;/li&gt;
&lt;li&gt;Executable (terminal-like icon)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Settings&lt;/h4&gt;

&lt;p&gt;Target &amp;gt; Edit Scheme &amp;gt; Run &amp;gt; Options &amp;gt; Use custom working directory: [project-directory]&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/swift/2016/11/24/serverside-swift.html</link>
        <guid isPermaLink="true">/blog/notes/swift/2016/11/24/serverside-swift.html</guid>
        
        <category>swift</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Swift</category>
        
      </item>
    
      <item>
        <title>Operating System - Paging</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Paging Overview

&lt;ol&gt;
&lt;li&gt;Introduction to Virtual Memory&lt;/li&gt;
&lt;li&gt;Paging MMU&lt;/li&gt;
&lt;li&gt;Page Tables&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Translation Lookaside Buffer (TLB)

&lt;ol&gt;
&lt;li&gt;TLB Basics&lt;/li&gt;
&lt;li&gt;Memory Protection&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Demand Paging

&lt;ol&gt;
&lt;li&gt;Demand Paging Overview&lt;/li&gt;
&lt;li&gt;Virtual Memory Hierarchy&lt;/li&gt;
&lt;li&gt;Managing Virtual Address Space&lt;/li&gt;
&lt;li&gt;Managing Physical Memory&lt;/li&gt;
&lt;li&gt;Managing Swap Area&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Processes &amp;amp; Virtual Memory

&lt;ol&gt;
&lt;li&gt;Interaction of Processes with VM System&lt;/li&gt;
&lt;li&gt;Page Sharing &amp;amp; Memory-Mapped Files&lt;/li&gt;
&lt;li&gt;Kernal Address Space&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Page Replacement Algorithms

&lt;ol&gt;
&lt;li&gt;Page Replacement Algorithms Overview&lt;/li&gt;
&lt;li&gt;Paging Issues&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Paging Overview&lt;/h2&gt;

&lt;h3&gt;Introduction to Virtual Memory&lt;/h3&gt;

&lt;h4&gt;Problems with Contiguous Memory&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Growing program requires copying entire program&lt;/li&gt;
&lt;li&gt;Wasted memory due to &lt;strong&gt;internal &amp;amp; external fragmentation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Running program requires loading entire program&lt;/li&gt;
&lt;li&gt;Max program size limited by memory size&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Paging MMU&lt;/h3&gt;

&lt;h4&gt;Pages &amp;amp; Frames&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Page&lt;/strong&gt;: contiguous, fixed size chunks in virtual address space&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Frame&lt;/strong&gt;: physical memory mapped from a page&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Virtual &amp;amp; Physical Addresses&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# 32-bit machine, virtual address space 2^32 B
# page size 2^12, # of pages 2^20
|...20 bits...|.12 bits.|
    page num     offset

# e.g. physical address space 2^30 B
# frame size 2^12, # of frames 2^18
|...18 bits...|.12 bits.|
    page num     offset

               VA               PA
          -----------&amp;gt;     -----------&amp;gt;
Processor              MMU              Bus
          &amp;lt;----------------------------
                       data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Benefits of Paging&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Growing program requires allocating a page at a time&lt;/li&gt;
&lt;li&gt;No external fragmentation (page granularity); internal fragmentation 1/2 page per region&lt;/li&gt;
&lt;li&gt;Pages can be loaded in memory as program runs&lt;/li&gt;
&lt;li&gt;Max program size limited by disk size&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Page Tables&lt;/h3&gt;

&lt;p&gt;Mapping information maintained by MMU.&lt;/p&gt;

&lt;h4&gt;Page Table Entries (PTE)&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|...18 bits...|.7 bits.|C|D|R|W|V|
   frame num    unused
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Storing Page Table&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Stored in memory

&lt;ul&gt;
&lt;li&gt;Each memory access requires 2 memory accesses: PTE &amp;amp; PA&lt;/li&gt;
&lt;li&gt;Solution: Cache PTE in TLB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Page table register (PTR)&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;For MMU to store the location of start of page table&lt;/li&gt;
&lt;li&gt;OS associates a seperate page table for each process&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address space switch&lt;/strong&gt; switches PTR&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Page Table Size&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#pages * PTE size (typically word size)
= (va_size / page_size) * PTE size
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Smaller page size: lower internal fragmentation&lt;/li&gt;
&lt;li&gt;Larger page size: fewer PTE &amp;amp; memory overhead&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Multi-Level Page Table&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|.10 bits.|.10 bits.|.12 bits.|
    PT1       PT2      offset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Slower than &lt;em&gt;single-level page table&lt;/em&gt; because more memory accesses&lt;/li&gt;
&lt;li&gt;Saves space&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Inverted Page Table&lt;/h4&gt;

&lt;p&gt;Maps &lt;strong&gt;frame num -&amp;gt; (thread id, page num)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|....|...52 bits...|.12 bits.|
 TID    page num     offset
  |         |
  -----------
       |
   hash func ----&amp;gt; index into page table
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Exhaustive search is slow

&lt;ul&gt;
&lt;li&gt;Use hash table indexed by page number&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hashing function needs to be good&lt;/li&gt;
&lt;li&gt;Poor cache locality

&lt;ul&gt;
&lt;li&gt;Adjacent pages hashed to scattered locations&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sharing memory is complecated&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Translation Lookaside Buffer (TLB)&lt;/h2&gt;

&lt;h3&gt;TLB Basics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;H/W cache of PTE

&lt;ul&gt;
&lt;li&gt;Small # of entries&lt;/li&gt;
&lt;li&gt;Exploits locality (program uses small # of pages at a time)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|virtual page number (VPN)|...18 bits...|.7 bits.|C|D|R|W|V|
                             frame num    unused
|   key: page number      |             data: PTE          |

V: valid, W: writable, R: referenced (H/W), D: dirty (H/W), C: cacheable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;V: is the entry valid or not?&lt;br&gt;
W: is the page writable?&lt;br&gt;
C: is the page cacheable? when not cacheable, processor should bypass the cache when accessing the page, e.g., to access memory-mapped device registers&lt;br&gt;
D: has a writable page been written to (is it dirty with respect to the data on disk)?&lt;br&gt;
R: has a page been referenced?&lt;br&gt;
unused: unused by hardware, can be used by OS  &lt;/p&gt;

&lt;p&gt;H/W may or may not need execution bit, but instead use &lt;em&gt;read&lt;/em&gt; as &lt;em&gt;execute&lt;/em&gt;  &lt;/p&gt;

&lt;h4&gt;TLB Operations&lt;/h4&gt;

&lt;h5&gt;TLB Lookup&lt;/h5&gt;

&lt;p&gt;Fully associative TLB example  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.cems.uwe.ac.uk/%7Ebr-gaster/courses/2015-2016/CNOS/lectures/reveal.js-jade/decks/cnos_lecture9/resources/tlb-lookup.png&quot; alt=&quot;TLB lookup&quot;&gt;&lt;/p&gt;

&lt;h5&gt;TLB cache miss handling&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;TLB lookup fails -&amp;gt; page table lookup -&amp;gt; TLB cache replaced (&lt;strong&gt;TLB replacement policy&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Handled by H/W or OS

&lt;ul&gt;
&lt;li&gt;H/W managed TLB

&lt;ul&gt;
&lt;li&gt;H/W defines page table format &amp;amp; replacement policy&lt;/li&gt;
&lt;li&gt;PTR to locate page table in physical memory&lt;/li&gt;
&lt;li&gt;Fast miss handling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;S/W managed TLB

&lt;ul&gt;
&lt;li&gt;H/W generates trap called &lt;strong&gt;TLB miss fault&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Read fault&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write fault&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OS handles TLB miss similar to exception handling&lt;/li&gt;
&lt;li&gt;OS figures out correct PTE, add in TLB (CPU has instructions to modify TLB)&lt;/li&gt;
&lt;li&gt;Page tables become entirely a OS data structure (no PTR in H/W, H/W doesn&amp;#39;t know about page table)&lt;/li&gt;
&lt;li&gt;TLB replacement policy managed in S/W&lt;/li&gt;
&lt;li&gt;Slower by more flexible miss handling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;TLB cache invalidate&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Adds cost to context switching

&lt;ul&gt;
&lt;li&gt;Changing PTR + invalidating TLB + TLB misses afterwards&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Invalidate options

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Clear TLB&lt;/strong&gt;: clearing valid bit of all entries&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tagged TLB&lt;/strong&gt;: H/W maintains &lt;strong&gt;id tag&lt;/strong&gt; on each entry

&lt;ul&gt;
&lt;li&gt;Compare current thread id (stored in register) to the tag&lt;/li&gt;
&lt;li&gt;No invalidation; enables space multiplexing of entries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Memory Protection&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Generate &lt;strong&gt;protection fault&lt;/strong&gt; if memory access inconsistent with protection bits

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Read-only fault&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No-execute fault&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Demand Paging&lt;/h2&gt;

&lt;h3&gt;Demand Paging Overview&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Motivation: program size/# of running programs limited by physical memory

&lt;ul&gt;
&lt;li&gt;Make memory a cache for data on disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Basic Mechanism

&lt;ul&gt;
&lt;li&gt;PTE unset for invalid page&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cache miss&lt;/strong&gt; when program accesses invalid page&lt;/li&gt;
&lt;li&gt;Generates &lt;strong&gt;page fault&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OS &lt;strong&gt;page fault handler&lt;/strong&gt; performs miss handling: allocate frame, update PTE, set valid bit, restart instruction&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Benefits

&lt;ul&gt;
&lt;li&gt;Allows programs run to exceed available memory (limited by VA space (processor architecture) or disk)&lt;/li&gt;
&lt;li&gt;Faster startup programs (no need to load entire program)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Virtual Memory Hierarchy&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://images.slideplayer.com/27/9050102/slides/slide_8.jpg&quot; alt=&quot;VM hierarchy&quot;&gt;&lt;/p&gt;

&lt;h4&gt;Swap Handler&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Chooses a page to evict using page replacement algorithm&lt;/li&gt;
&lt;li&gt;If page modified, write to a free location on &lt;strong&gt;swap&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Find pages that map to the evicted frame

&lt;ul&gt;
&lt;li&gt;Need frame-to-page mapping (coremap)&lt;/li&gt;
&lt;li&gt;Change all PTEs to invalid&lt;/li&gt;
&lt;li&gt;Keep track of the evicted frame location in swap&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Return newly freed frame to page fault handler&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Other Notes&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;If &lt;em&gt;TLB miss handling&lt;/em&gt; is performed by H/W, no &lt;em&gt;TLB miss fault&lt;/em&gt; generated; if by S/W, H/W doesn&amp;#39;t access PT&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Page fault handler&lt;/strong&gt;: 

&lt;ul&gt;
&lt;li&gt;checks &lt;strong&gt;segmentation fault&lt;/strong&gt;, &lt;strong&gt;protection fault&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;allocates frame, PTE&lt;/li&gt;
&lt;li&gt;loads data from disk into frame&lt;/li&gt;
&lt;li&gt;maps page to frame by updating PTE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Page contents may:

&lt;ul&gt;
&lt;li&gt;be all 0&lt;/li&gt;
&lt;li&gt;in &lt;strong&gt;swap&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;in &lt;strong&gt;executable&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OS accesses PT when:

&lt;ul&gt;
&lt;li&gt;on TLB-miss fault (for h/w managed TLB), it reads the page table&lt;/li&gt;
&lt;li&gt;on page fault, it allocates frame and updates page table&lt;/li&gt;
&lt;li&gt;whenever address space of current process is modified, (frame is allocated/deallocated, context switch), it updates page table&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Managing Virtual Address Space&lt;/h3&gt;

&lt;h4&gt;Address Space&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Broken into &lt;strong&gt;regions&lt;/strong&gt; or &lt;strong&gt;segments&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OS must track the regions within an address space &amp;amp; PT holding translations&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id = as_create()&lt;/code&gt; create empty address space, allocate new PT with no pages mapped to frames&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_destroy(id)&lt;/code&gt; destroy as, free PT&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_define_region(id,...)&lt;/code&gt; add new region&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_modify_region(id,...)&lt;/code&gt; change size (e.g. heap, stack)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_find_region(id,va)&lt;/code&gt; find valid region or give seg fault&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_load_page(id,...)&lt;/code&gt; load page from file into memory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new_id = as_copy(id)&lt;/code&gt; create copy of as &amp;amp; PT (actually copy data to other frames)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as_switch(id)&lt;/code&gt; mappings in TLB must be removed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Managing Physical Memory&lt;/h3&gt;

&lt;h4&gt;Coremap&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Array of structures, one per frame&lt;/li&gt;
&lt;li&gt;Tracks:

&lt;ul&gt;
&lt;li&gt;whether frame allocated&lt;/li&gt;
&lt;li&gt;address spaces &amp;amp; pages map to this frame (list of (pid, page_id))&lt;/li&gt;
&lt;li&gt;kernel or user&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;frame = allocate_frame(n)&lt;/code&gt; alloc n free contiguous frames (user needs 1 frame; kernel needs more)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;free_frame(frame)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map(id,page_nr,frame)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unamp(id,page_nr)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;evict(frame)&lt;/code&gt; for swap handler to unmap pages associated with frame&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Managing Swap Area&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Dirty pages need to be placed in swap&lt;/li&gt;
&lt;li&gt;Bitmap or linked list of &lt;strong&gt;swap frames&lt;/strong&gt; on disk; keep location in invalid PTE&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If loading shared frame from swap and needs to write to it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;allocate a frame and keep the swap frame&lt;/li&gt;
&lt;li&gt;next time allocate another frame and free the swap frame&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# PTE
|frame number|unused|R|D|C|W|1| virtual page in memory
|000.......................0|0| invalid PTE
|index in swap area.........|0| virtual page in swap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Processes &amp;amp; Virtual Memory&lt;/h2&gt;

&lt;h3&gt;Interaction of Processes with VM System&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;OS implements VM system using 3 abstractions: address space, physical memory, &amp;amp; swap management&lt;/li&gt;
&lt;li&gt;Rest of OS invokes the VM systems when &lt;strong&gt;address space of current process changes&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Process creation &lt;code&gt;fork&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Create new PT &amp;amp; copy content from parent&amp;#39;s regions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Process execution &lt;code&gt;execv&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Destroy old address space structure &amp;amp; create new one&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Process termination &lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Context switch

&lt;ul&gt;
&lt;li&gt;H/W managed TLB: change PTR, flush TLB&lt;/li&gt;
&lt;li&gt;S/W managed TLB: flush TLB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Memory allocation/deallocation &lt;code&gt;sbrk, stack&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Heap: system call (&lt;code&gt;sbrk&lt;/code&gt;) to grow; allows OS to &lt;strong&gt;detect errors&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Stack: when faulting address &lt;em&gt;clost&lt;/em&gt; to stack, extend stack region running standard page fault handler&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Page Sharing &amp;amp; Memory-Mapped Files&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Benefits

&lt;ul&gt;
&lt;li&gt;Fast communication between processes&lt;/li&gt;
&lt;li&gt;Good isolation (only share when needed)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Applications

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sharing text regions&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;e.g. dynamically loaded libraries&lt;/li&gt;
&lt;li&gt;Must update all pages when frame evicted&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copy-on-write pages&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Child shares pages with parent until pages modified&lt;/li&gt;
&lt;li&gt;PTE marks &lt;strong&gt;COW &amp;amp; read-only&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;On protection fault: allocate new frame, copy, remap, make writable, update TLB, resume&lt;/li&gt;
&lt;li&gt;Must update all pages when frame evicted&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory-mapped files&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Threads r/w files using load/store instead of system calls&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mmap(addr,length,prot_flags,fd,offset)&lt;/code&gt; maps a file at given offset contiguously within address space

&lt;ul&gt;
&lt;li&gt;Storing &lt;code&gt;offset&lt;/code&gt; to provide flexibility since different processes may have different addresses of shared memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;File data loaded on page fault&lt;/li&gt;
&lt;li&gt;Instead of swap area, use file itself as backing store&lt;/li&gt;
&lt;li&gt;More efficient than r/w system calls because system calls need buffer in kernel to transfer data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shared memory

&lt;ul&gt;
&lt;li&gt;Threads r/w to mapped memory region&lt;/li&gt;
&lt;li&gt;PTE can have different protections for different threads&lt;/li&gt;
&lt;li&gt;Memory can be mapped at same or different VA in each process&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Kernal Address Space&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;OS typically lies in &lt;em&gt;low physical memory&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Options

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Paging turned off&lt;/strong&gt; in kernel mode, OS access physical memory directly

&lt;ul&gt;
&lt;li&gt;OS needs to simulate paging, i.e. do address translation in software, to copy in or out user parameters on a system call, deal with dirty bit, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OS uses &lt;strong&gt;separate address space&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;Clean isolation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;System call requires switching MMU -&amp;gt; TLB flush&lt;/li&gt;
&lt;li&gt;Copy in/out of system call parameters requires traversing PT in S/W&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OS maps to &lt;strong&gt;address space of each thread&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Typically mapped to high addresses&lt;/li&gt;
&lt;li&gt;Pros

&lt;ul&gt;
&lt;li&gt;No system call&lt;/li&gt;
&lt;li&gt;Copy in/out of system call parameters can reuse paging H/W&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Cons

&lt;ul&gt;
&lt;li&gt;Address space of processes reduces&lt;/li&gt;
&lt;li&gt;PT needs to be setup to access OS code

&lt;ul&gt;
&lt;li&gt;H/W may allow OS to bypass PT&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Page Replacement Algorithms&lt;/h2&gt;

&lt;h3&gt;Page Replacement Algorithms Overview&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;When will paging work?

&lt;ul&gt;
&lt;li&gt;If occurs rarely&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spatial locality&lt;/strong&gt; &amp;amp; &lt;strong&gt;temporal locality&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithms&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Optimal algorithm&lt;/strong&gt;: page that will not be needed for longest time

&lt;ul&gt;
&lt;li&gt;Need to know the future&lt;/li&gt;
&lt;li&gt;Can be used to compare performance

&lt;ul&gt;
&lt;li&gt;Generate a log of VM accesses (&lt;strong&gt;reference string&lt;/strong&gt;); use log to simulate various replacement policies&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIFO&lt;/strong&gt;: oldest page

&lt;ul&gt;
&lt;li&gt;Oldest page may be needed soon&lt;/li&gt;
&lt;li&gt;Faults may increase if given more memory (&lt;a href=&quot;http://stackoverflow.com/questions/4800285/cant-understand-beladys-anomaly&quot;&gt;Belady&amp;#39;s Anomaly&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Clock&lt;/strong&gt;: FIFO giving second chance to referenced pages&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Referenced bit&lt;/strong&gt;: set by processor when page read/written; cleared by OS/software&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dirty bit&lt;/strong&gt;: set by processor when page written; cleared by OS/software&lt;/li&gt;
&lt;li&gt;OS synchronizes R/D bits in TLB with PTE (H/W: write-through or write-back; S/W: needs to implement synchronization)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OS simulates the bits if H/W doesn&amp;#39;t maintain&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When TLB read fault: 

&lt;ul&gt;
&lt;li&gt;Set referenced bit; make page read-only&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;When TLB read-only protection fault/write fault: 

&lt;ul&gt;
&lt;li&gt;Set referenced &amp;amp; dirty bits; make page writeable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Choose page starting from clock hand:
    if referenced bit set:
        unset, goto next
    else:
        if page dirty:
            schedule page write, goto next
        else:
            select for replacement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;LRU&lt;/strong&gt;: page used least recently&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Updating LRU on each memory access is expensive&lt;/li&gt;
&lt;li&gt;If MMU maintains a counter incremented at each clock cycle:

&lt;ul&gt;
&lt;li&gt;When page accessed: 

&lt;ul&gt;
&lt;li&gt;Writes counter value to PTE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On page fault: 

&lt;ul&gt;
&lt;li&gt;S/W looks through PT, identifies entry with oldest timestamp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If MMU doesn&amp;#39;t provide such counter, OS maintains it in S/W (&lt;strong&gt;LRU aprroximation&lt;/strong&gt;):

&lt;ul&gt;
&lt;li&gt;Periodically (timer interrupt) increment counter; granularity depends on timer interrupt&lt;/li&gt;
&lt;li&gt;If referenced bit set:

&lt;ul&gt;
&lt;li&gt;Write counter value&lt;/li&gt;
&lt;li&gt;Clear referenced bit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On page fault:

&lt;ul&gt;
&lt;li&gt;S/W looks through PT &amp;amp; identify the oldest timestamp&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Working set clock&lt;/strong&gt;: keep working set in memory&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Working set&lt;/strong&gt;: set of pages a program needs currently

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Working set interval &lt;code&gt;T&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;WS(T) = {pages accessed in interval (now, now-T)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Max WS&lt;/strong&gt;: how much memory a program needs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithm&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Choose page starting from clock hand:
    if referenced bit set:
        update time-of-last-use to current virtual time
        unset, goto next
    else:
        if (current time - time-of-last-use) &amp;lt; T:
            continue
        else:
            if page dirty:
                schedule page write, goto next
            else:
                select for replacement
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Page fault frequency&lt;/strong&gt;: estimate of working set needs of a program&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Measurements&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;For each thread:
    On fault:
        f = f + 1
    Every second, update faults/sec (fe) via aging:
        fe = (1-a) * fe + a * f, f = 0
        # 0 &amp;lt; a &amp;lt; 1, weighting factor; a -&amp;gt; 1 means history ignored
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Allocate frames s.t. &lt;strong&gt;PFF is equal for programs&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Global replacement&lt;/strong&gt;: victim process has lowest PFF&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Local replacement&lt;/strong&gt;: use algorithms above (clock, LRU, etc.) to evict a page within the victim process&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comparison&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Algorithm&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Comment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Optimal&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Not implementable; useful as benchmark&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;FIFO&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Might throw out important pages&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Clock&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Realistic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;LRU&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Excellent; difficult to implement efficiently&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;WSC&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Efficient working set algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;PFF&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Fairness in working set allocation&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Paging Issues&lt;/h3&gt;

&lt;h4&gt;Paging &amp;amp; I/O Interaction&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Problem: a frame waiting for I/O may be selected for eviction&lt;/li&gt;
&lt;li&gt;Solution: each frame has &lt;strong&gt;do not evict&lt;/strong&gt; flag called &lt;strong&gt;pinned page&lt;/strong&gt;; un-pin after I/O completes&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Paging Performance&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Paging works best if many free frames&lt;/li&gt;
&lt;li&gt;If pages full of dirty pages, 2 disk operations (swap in/out) needed on each page fault&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Paging daemon&lt;/strong&gt;: swap out in advance

&lt;ul&gt;
&lt;li&gt;OS maintains a pool of free frames using &lt;strong&gt;paging thread/daemon&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Daemon runs replacement algorithm periodically or when pool reaches &lt;strong&gt;low watermark&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;Writes out dirty pages&lt;/li&gt;
&lt;li&gt;Frees enough pages until pool reaches &lt;strong&gt;high watermark&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Frames can be &lt;strong&gt;rescued&lt;/strong&gt; if page referenced before realocation, because previous content still holds&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Prefetching&lt;/strong&gt;: swap in in advance

&lt;ul&gt;
&lt;li&gt;Predict future page usage at current faults&lt;/li&gt;
&lt;li&gt;Works well when pages read sequentially&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Thrashing&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Livelock&lt;/strong&gt;: OS spends time paging data from disk, programs not making progress&lt;/li&gt;
&lt;li&gt;Causes

&lt;ol&gt;
&lt;li&gt;Pages replacement algorithm not working&lt;/li&gt;
&lt;li&gt;Not enough memory to hold working set of all running programs&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Solutions

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Swapping&lt;/strong&gt;: suspend some programs for a while&lt;/li&gt;
&lt;li&gt;Buy more memory&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Resources&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-is-the-differences-between-a-page-table-and-an-inverted-page-table&quot;&gt;What are the differences between a page table and an inverted page table?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://f.osdev.org/viewtopic.php?f=1&amp;amp;t=15321&quot;&gt;Can I turn off paging in kernel mode?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/notes/os/2016/11/22/operating-system-paging.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/11/22/operating-system-paging.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>paging</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>ReactJS Data Visualization Libraries in a Hack Night</title>
        <description>&lt;p&gt;At the hackathon last night, we were given a bunch of advertising data to work with so that data can be more understandable. I experimented with several React data visualization libraries, out of which I couldn&amp;#39;t really find a perfect one. I will share the experience working with the libraries, and what pros and cons I found.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;All versions of implementation and final demo can be found &lt;a href=&quot;https://github.com/pyliaorachel/hack-with-ix/tree/master&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Basically, below is just some subjective observations in a hack night, so there may be many mistakes in the description. I do appreciate any corrections!&lt;/p&gt;

&lt;h3&gt;react-chartjs&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/reactjs/react-chartjs&quot;&gt;react-chartjs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/pyliaorachel/hack-with-ix/blob/demo/ui/src/assets/react-chartjs.png?raw=true&quot; alt=&quot;react-chartjs&quot;&gt;&lt;/p&gt;

&lt;p&gt;The main problem is in its documentation, which seems to be fancy but are actually including too many information which is loosely distributed throughout the entire doc.&lt;/p&gt;

&lt;p&gt;Especially the &lt;code&gt;options&lt;/code&gt;, which determines the settings, style, scale, and all other important stuffs, are really messy and not working as expected. I searched through many examples but simply cannot get rid of the gray color in my chart. Discarded it because nobody wants such a chart with not-very-appealing look.&lt;/p&gt;

&lt;p&gt;But I really like that I can work out a formatted x-axis display value. This should be a basic functionality, but surprisingly not many libraries get this well.&lt;/p&gt;

&lt;h5&gt;Data Parsing&lt;/h5&gt;

&lt;p&gt;Use &lt;code&gt;labels&lt;/code&gt; as x-axis or categories, &lt;code&gt;data&lt;/code&gt; in &lt;code&gt;datasets&lt;/code&gt; as y-axis or values.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chartData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;datasets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// other options&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}],&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Red'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Blue'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Purple'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Yellow'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;Pros&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;labels&lt;/code&gt; to represent x-axis, which is great that I can customize&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Cons&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Not providing a clear react version documentation but uses &lt;a href=&quot;http://www.chartjs.org/docs/&quot;&gt;chartjs&lt;/a&gt;&amp;#39;s instead, which I don&amp;#39;t really like because of the extensive information&lt;/li&gt;
&lt;li&gt;Demonstration page not clear with how the data look like&lt;/li&gt;
&lt;li&gt;Don&amp;#39;t know why, but some of the &lt;code&gt;options&lt;/code&gt; are not working, and I can&amp;#39;t do the styling because of this&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;react-d3&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/esbullington/react-d3&quot;&gt;react-d3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/pyliaorachel/hack-with-ix/blob/demo/ui/src/assets/react-d3.png?raw=true&quot; alt=&quot;react-d3&quot;&gt;&lt;/p&gt;

&lt;p&gt;The main problem is in data parsing.&lt;/p&gt;

&lt;p&gt;You need to go through the whole data and explicitly parse out the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in a &lt;code&gt;values&lt;/code&gt; array, which is most commonly done by simply setting the &lt;code&gt;field&lt;/code&gt; key in other libraries. This can be helpful if you want even more flexibility, but this is seldom the case.&lt;/p&gt;

&lt;p&gt;And again, where can I easily find the styling instructions? Miserable.&lt;/p&gt;

&lt;h5&gt;Data Parsing&lt;/h5&gt;

&lt;p&gt;Parse points as &lt;code&gt;x-y&lt;/code&gt; pairs in a &lt;code&gt;values&lt;/code&gt; array for coordinate charts.&lt;br&gt;
Parse categories as &lt;code&gt;label&lt;/code&gt; and values as &lt;code&gt;value&lt;/code&gt; for category charts.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lineData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;series1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;strokeWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;strokeDashArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;5,5&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;series2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;82&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;76&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;82&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pieData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Margarita'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;20.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'John'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;55.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Tim'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;25.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;Pros&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Nice demonstration page, simple and clear&lt;/li&gt;
&lt;li&gt;Parse the x/y coordinates ourselves, which can be more flexible (but also a con)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Cons&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;The styling instructions are somehow hidden deep in the documentation&lt;/li&gt;
&lt;li&gt;Need to parse the x/y coordinates ourselves, which is more tedious (but also a pro)&lt;/li&gt;
&lt;li&gt;Customize displayed x-/y-axis is not flexible enough (only found time on x-axis to be formattable, but the instructions are not clear)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;react-d3-basic&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/react-d3/react-d3-basic&quot;&gt;react-d3-basic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/pyliaorachel/hack-with-ix/blob/demo/ui/src/assets/react-d3-basic.png?raw=true&quot; alt=&quot;react-d3-basic&quot;&gt;&lt;/p&gt;

&lt;p&gt;To be honest, I choose this as the final working version simply because I KNOW HOW TO STYLE IT. The documentation is the nice ever.&lt;/p&gt;

&lt;p&gt;The main problem is still in data parsing and non-customizable x-axis display value.&lt;/p&gt;

&lt;p&gt;Although the doc is nice, but the data are not especially shown, so I have to look for the &lt;code&gt;.csv&lt;/code&gt; files on github and found some missing. Not a big problem though, but a problem to hackers in hackathons.&lt;/p&gt;

&lt;p&gt;For the x-axis display values, it provides an &lt;code&gt;x&lt;/code&gt; function for you to map. But they are not actually intended for you to map displayed values but only actual values. So if you want the function to return a string representation of a date, it fails because only number values are allowed.&lt;/p&gt;

&lt;p&gt;And the bar-type charts yelled to me miserable errors for a missing &lt;code&gt;bandwidth&lt;/code&gt; function deep in the &lt;code&gt;chartjs&lt;/code&gt; package, probably because I used the bar charts to build some streaming charts. So be careful when implementing them.&lt;/p&gt;

&lt;h5&gt;Data Parsing&lt;/h5&gt;

&lt;p&gt;Use &lt;code&gt;field&lt;/code&gt; for the y-axis filter. Argument in &lt;code&gt;x&lt;/code&gt; function is the data object itself, so be sure the datum is parsed in a way that have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; values.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;// sample data
[
  {
    total: 1,
    incineration: 1,
    garbageBury: 1,
    month: 1,
  },
  {
    total: 2,
    incineration: 2,
    garbageBury: 2,
    month: 2,
  },
  ...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chartSeries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;chartSeries&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'total'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Total'&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'incineration'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Incineration'&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'garbageBury'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Garbage Bury'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;area&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parseDate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;month&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;Pros&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Nice documentation, simple and clear&lt;/li&gt;
&lt;li&gt;Easy to style&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Cons&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Need more examples on how to parse the data for different charts&lt;/li&gt;
&lt;li&gt;Customized x-/y-axis is not flexible enough&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 21 Nov 2016 00:00:00 -0500</pubDate>
        <link>/blog/tech/reactjs/2016/11/21/reactjs-data-visualization-libraries-in-a-hack-night.html</link>
        <guid isPermaLink="true">/blog/tech/reactjs/2016/11/21/reactjs-data-visualization-libraries-in-a-hack-night.html</guid>
        
        <category>react</category>
        
        <category>react-chartjs</category>
        
        <category>react-d3</category>
        
        <category>react-d3-basic</category>
        
        <category>data visualization</category>
        
        
        <category>Blog</category>
        
        <category>Tech</category>
        
        <category>ReactJS</category>
        
      </item>
    
  </channel>
</rss>
