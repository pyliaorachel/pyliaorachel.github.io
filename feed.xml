<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MyCoon</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 23 Oct 2016 20:56:29 -0400</pubDate>
    <lastBuildDate>Sun, 23 Oct 2016 20:56:29 -0400</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Operating System - Threads</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Threads and Processes&lt;/li&gt;
&lt;li&gt;Thread Scheduling&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Threads and Processes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When a &lt;strong&gt;program&lt;/strong&gt; runs, it is called a &lt;code&gt;process&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;OS maintains states for each abstraction:

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Thread(CPU) state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Registers, PC, SP, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address Space (memory) state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Program instructions, static &amp;amp; dynamic data, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Device &amp;amp; other state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Open files, network connection state, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Threads&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Abstraction of &lt;strong&gt;virtualizing CPU&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Each &lt;code&gt;thread&lt;/code&gt; thinks it has its own set of &lt;code&gt;CPU registers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;# of &lt;code&gt;threads&lt;/code&gt; arbitrary; # of &lt;code&gt;CPUs&lt;/code&gt; fixed&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enables &lt;strong&gt;concurrency&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Running multiple programs concurrently&lt;/li&gt;
&lt;li&gt;Running multiple tasks concurrently

&lt;ul&gt;
&lt;li&gt;Hiding I/O latency

&lt;ul&gt;
&lt;li&gt;Can use &lt;code&gt;non-blocking file I/O&lt;/code&gt; (&lt;code&gt;event-driven&lt;/code&gt;), but harder to get right because need to build a state machine&lt;/li&gt;
&lt;li&gt;~ &lt;code&gt;interrupts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Run truly in parallel with multiple &lt;code&gt;CPUs&lt;/code&gt; via &lt;code&gt;multiplexing&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Threads v.s. Functions&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Threads&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Functions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Independent streams of execution, one thread no need to run to the end before switching&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;LIFO policy, functions runs untill the end&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Thread scheduler multiplexes the threads on CPU&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;One function calls another function&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Each thread has its own stack, calling its own set of functions&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Running on a single stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Runs in parallel with multiprocessors&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Cannot run in parallel with multiprocessors because functions stack together&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Address Space&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Abstraction of &lt;strong&gt;virtualizing memory&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;A set of &lt;em&gt;virtual memory regions&lt;/em&gt; accessible to a program

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Text&lt;/code&gt;: program code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;, &lt;code&gt;Heap&lt;/code&gt;: static, dynamic variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;: for function &amp;amp; system calls&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Provides &lt;strong&gt;memory protection&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Address space (order may vary with different H/W &amp;amp; compiler environment)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;        +++++++++++++++ ----
        |    param    |  |
        +++++++++++++++  |
        |   ret val   |  |
        +++++++++++++++  |
        |   ret addr  |  |  activation frame
        +++++++++++++++  |  for current function
  fp -&amp;gt; |   prev fp   |  |
        +++++++++++++++  |
        |  other regs |  |
        +++++++++++++++  |
  sp -&amp;gt; |  local var  |  |      # function call:
        +++++++++++++++ ----    # push %rbp; save old fp
        |      ↓      |         # mov %rbp %rsp; init sp to fp
        |             |         # retq; call *sp
        |      ↑      |
        +++++++++++++++         # return:
        |    data     |         # add $24 %rsp; pop off stack
        +++++++++++++++         # pop %rbp; fp=*sp (or *fp), sp++
        |    text     |         # retq; call *sp
        +++++++++++++++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Processes&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A running program consistes of &amp;gt;= 1 processes

&lt;ul&gt;
&lt;li&gt;Traditionally:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process = addr space + thread&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; communicate using &lt;code&gt;system calls&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Today:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;process = addr space + &amp;gt;= 1 threads&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; share &lt;code&gt;addr space&lt;/code&gt; (but not &lt;code&gt;stack&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; communicate with &lt;code&gt;reading/writing memory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Speed up cases analysis:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Vector operation
for (k = 0; k &amp;lt; n; k++)
    a[k] = b[k]*c[k] + d[k]*e[k];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Multiple processes?

&lt;ul&gt;
&lt;li&gt;Communicate with &lt;code&gt;system call&lt;/code&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Multiple threads?

&lt;ul&gt;
&lt;li&gt;Must make it global to share data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On single processor?

&lt;ul&gt;
&lt;li&gt;Threads go one after another&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On multiprocessor?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Web server
Loop:
    1. get network message from client -&amp;gt; I/O
    2. get URL data form disk, cache in memory -&amp;gt; I/O
    3. compose response
    4. send response -&amp;gt; I/O
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Multiple processes?

&lt;ul&gt;
&lt;li&gt;Cannot share the cache (stored in global resource area of that process)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Multiple threads?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On single processor?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On multiprocessor?

&lt;ul&gt;
&lt;li&gt;O&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Threads v.s. Processes&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Threads&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Processes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Memory needed&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Shared, less&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Not shared, more&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Communication &amp;amp; Synchronization&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Via &lt;strong&gt;shared vars&lt;/strong&gt;, faster&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Via &lt;strong&gt;system calls&lt;/strong&gt;, slower&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Switching&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Save &amp;amp; restore regs, faster&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Change MMU&amp;#39;s regs (e.g. base &amp;amp; limit), slower&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Robustness&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Memory sharing -&amp;gt; bugs&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Communication explicit -&amp;gt; robust&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Program v.s. Process&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Program&lt;/strong&gt;: a set of instructions &amp;amp; data&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Process&lt;/strong&gt;: a program loaded in memory and executing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;OS-Level Process State&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;OS keeps state for each process: &lt;code&gt;process state&lt;/code&gt;, &lt;code&gt;process control block (PCB)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Thread state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Processor regs&lt;/code&gt; for resuming/suspending thread&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Various &lt;code&gt;parameters&lt;/code&gt; e.g. scheduling parameters&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Address space state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Location of &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;stack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MMU virtual memory state&lt;/code&gt; i.e. virtual -&amp;gt; physical mapping&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Device related state&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Open files, network connections&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Other states&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Terminal state, pending signals, timers, swap, ...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;Thread Scheduling&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread&lt;/code&gt;: an independent stream of instructions

&lt;ul&gt;
&lt;li&gt;Which to choose?&lt;/li&gt;
&lt;li&gt;When to switch?&lt;/li&gt;
&lt;li&gt;How to switch?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread scheduling&lt;/code&gt;: running threads in some order

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread state&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Running&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ready&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Blocked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exited&lt;/code&gt; (not yet destroyed)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scheduling policies&lt;/code&gt; to change states&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread scheduling functions&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thread_yield&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Running -&amp;gt; Ready&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread_sleep&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Running -&amp;gt; Blocked&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread_wakeup&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Blocked -&amp;gt; Ready&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preemptive scheduling&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Scheduler&lt;/code&gt; uses &lt;code&gt;timer interrupt&lt;/code&gt; to control threads&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupt handler&lt;/code&gt; calls yield on behalf of running thread

&lt;ul&gt;
&lt;li&gt;Normally &lt;code&gt;interrupt handler&lt;/code&gt; returns to original call; here, it calls &lt;code&gt;thread_yield()&lt;/code&gt; instead&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Scheduler implementation

&lt;ul&gt;
&lt;li&gt;Thread structures maintained in &lt;code&gt;queues&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ready queue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Generally 1 per CPU&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Wait queue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Separate &lt;code&gt;wait queues&lt;/code&gt; for each type of event e.g. disk, console, timer, network, ...&lt;/li&gt;
&lt;li&gt;Generally shared by CPUs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exited queue&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Generally shared by CPUs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scheduling functions&lt;/code&gt; move &lt;code&gt;threads&lt;/code&gt; between &lt;code&gt;queues&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Thread &amp;amp; Context Switch&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;context switch&lt;/code&gt; (&lt;code&gt;process switch&lt;/code&gt;) = &lt;code&gt;thread switch&lt;/code&gt; + &lt;code&gt;address space switch&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Address space switch&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Updating &lt;code&gt;MMU&amp;#39;s&lt;/code&gt; registers&lt;/li&gt;
&lt;li&gt;More expensive than &lt;code&gt;thread switch&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Context switch&lt;/code&gt; v.s. &lt;code&gt;Mode switch&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Unrelated; the former switch threads, the latter switch CPU modes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thread_yield&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;thread_yield() {
    enqueue_ready_queue(current)
    next = choose_next_thread()
    thread_switch(current, next)
}
thread_switch(current, next) {
    save_processor_state(current-&amp;gt;cpu_regs)
    ...
    restore_processor_state(next-&amp;gt;cpu_regs)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thread_init&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create the first (main) thread&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;thread_create&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Allocate thread struct, stack memory, init PC, SP&lt;/li&gt;
&lt;li&gt;Add to ready queue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Thread Creation &amp;amp; Termination&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;thread_exit&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Does not destroy itself; switch to another thread and it will destroy this thread&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread_destroy&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Actually destroy thread structure &amp;amp; stack of exited threads&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Kernel Threads v.s. User Threads&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Kernel Threads&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;User Threads&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Implementation scope&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Implemented in kernel&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Implemented in user program&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Virtualization&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Virtualize CPU&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Virtualize kernel thread&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Switching cost&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Must run kernel code, expensive&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;~procedure calls, less expensive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Scheduling policy&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Fixed&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Custom definition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Blocking system calls&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Switch to another kernel thread&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;All threads (associated with the same kernel thread) block -&amp;gt; overlap of I/O &amp;amp; computations impossible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Multiprocessors&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Threads use multiple CPUs concurrently&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Cannot use multiple CPUs consurrently&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Kernel level scheduler&lt;/code&gt; doesn&amp;#39;t know about &lt;code&gt;user threads&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;&lt;strong&gt;Quick Questions&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Is the OS code run in a separate process? A separate thread? Does it need a process structure?

&lt;ul&gt;
&lt;li&gt;OS code runs when a process makes a system call or when an interrupt occurs. In either case, the OS generally runs in the thread and address space context of the user process, and hence it does not require its own process or thread state.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is the address space of an OS?

&lt;ul&gt;
&lt;li&gt;The entire physical memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/os/2016/10/23/operating-system-threads.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/10/23/operating-system-threads.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>threads</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>Operating System - Concurrent Programming</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Concurrent Programming&lt;/li&gt;
&lt;li&gt;Mutual Exclusion&lt;/li&gt;
&lt;li&gt;Synchronization&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Concurrent Programming&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; cooperate to perform a common task by sharing data (global vars &amp;amp; heap data)&lt;/li&gt;
&lt;li&gt;Problems

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Race conditions&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread interleaving&lt;/code&gt; cause incorrect results&lt;/li&gt;
&lt;li&gt;Access to shared variable must be exclusive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Ordering between threads must be enforced&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Mutual Exclusion&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Atomic operation&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Operation appears &lt;em&gt;indivisible&lt;/em&gt;; rest of the system either doesn&amp;#39;t observe any of the effects, or all of them&lt;/li&gt;
&lt;li&gt;Other threads may still run, but they should not observe any intermediate states of the operation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mutual exclusion&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Only one thread can read/update shared variables at a time&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Critical section&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;The code region where &lt;code&gt;mutual exclusion&lt;/code&gt; is enforced&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Mutex Lock&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Critical sections&lt;/code&gt; accessed in between &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;unlock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mutex = lock_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock_destroy(mutex)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock(mutex)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;If lock free: acquire lock&lt;/li&gt;
&lt;li&gt;Else: wait/sleep until lock free&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unlock(mutex)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Release lock&lt;/li&gt;
&lt;li&gt;Wake up one of the waiting threads&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mutual exclusion&lt;/code&gt; conditions

&lt;ul&gt;
&lt;li&gt;NO 2 threads in &lt;code&gt;critical section&lt;/code&gt; at the same time&lt;/li&gt;
&lt;li&gt;NO assumption on speed of thread execution&lt;/li&gt;
&lt;li&gt;Thread running outside &lt;code&gt;critical section&lt;/code&gt; CANNOT block another thread&lt;/li&gt;
&lt;li&gt;NO thread must wait forever to enter its &lt;code&gt;critical section&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Mutex Implementation&lt;/strong&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Variable tracking&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;lock(l) {
    while (l == TRUE)
        ;
    l = TRUE;
}
unlock(l) {
    l = FALSE;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; is also a shared variable, so &lt;code&gt;lock&lt;/code&gt; &amp;amp; &lt;code&gt;unlock&lt;/code&gt; should be &lt;code&gt;atomic&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make &lt;code&gt;lock&lt;/code&gt; atomic&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;lock(l) {
    disable_interupts;
    while (l == TRUE)
        ;
    l = TRUE;
}
unlock(l) {
    l = FALSE;
    enable_interupts;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Works only on &lt;em&gt;single core&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;h4&gt;Multiprocessor H/W provides &lt;code&gt;atomic instructions&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Test-and-set&lt;/code&gt; lock, &lt;code&gt;compare-and-swap&lt;/code&gt; lock&lt;/li&gt;
&lt;li&gt;Operate on a memory word, perform 2 operations &lt;strong&gt;indivisibly&lt;/strong&gt; by CPU requesting the lock controller to lock out the memory location&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;      int tset(int *lock) { // atomic in H/W
          int old = *lock;
          *lock = 1;  ___&amp;gt; atomic
          return old; _|
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Spin locks&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uses &lt;code&gt;tset&lt;/code&gt; in a loop&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;// *l init to 0
lock(int *l) {
    while (tset(1))
        ;
}
unlock(int *l) {
    *l = FALSE;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Efficient only if &lt;code&gt;critical sections&lt;/code&gt; are short&lt;/li&gt;
&lt;li&gt;But &lt;code&gt;CPU&lt;/code&gt; performs no useful working waiting in the loop -&amp;gt; &lt;strong&gt;waste CPU&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Yielding locks&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;// *l init to 0
lock(int *l) {
    while (tset(1))
        thread_yield();
}
unlock(int *l) {
    *l = FALSE;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;But scheduler determines when it returns back -&amp;gt; &lt;strong&gt;delay lock acquire&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Blocking locks&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unlike 3., 4. polling for locks, now &lt;code&gt;unlock&lt;/code&gt; will wakeup threads sleeping in &lt;code&gt;lock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;// *l init to 0
lock(int *l) {
    while (tset(1))
        thread_sleep();
}
unlock(int *l) {
    *l = FALSE;
    thread_wakeup();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Access shared &lt;code&gt;ready queue&lt;/code&gt;, i.e. we need locking while implementing blocking&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Locking solutions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Multiprocessor&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;                blocking lock    # manipulate queues
                      ↓
                  spin lock      # loop on atomic instruction
                      ↓
              atomic instruction # single instruction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Uniprocessor&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;                blocking lock
                      ↓
              interrupt disabling
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Which lock to use?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Lock&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;When to use?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Atomic instruction&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Most efficient, use when available&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Interrupt disabling, spin locks&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Critical sections short &amp;amp; will not block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Blocking locks&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Critical sections long &amp;amp; may block (&lt;strong&gt;for synchronization&lt;/strong&gt;); overhead for context switch&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;How many locks to create?

&lt;ul&gt;
&lt;li&gt;1 per individual data structure&lt;/li&gt;
&lt;li&gt;More locks -&amp;gt; more parallelism BUT more bugs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Deadlocks, Starvation, Livelock&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Deadlock&lt;/code&gt;: a set of threads each waiting for a resource held by another thread

&lt;ul&gt;
&lt;li&gt;Conditions

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mutual exclusion&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hold &amp;amp; wait&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No premption&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Circular wait&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Prevention

&lt;ul&gt;
&lt;li&gt;Release previously acquired locks? (hold &amp;amp; wait)

&lt;ul&gt;
&lt;li&gt;But modifications to data might have already happened&lt;/li&gt;
&lt;li&gt;Or &lt;code&gt;livelock&lt;/code&gt; when keep trying to acquire locks&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Number each resources, need to acquire lower numbered resources before higher ones? (circular wait)

&lt;ul&gt;
&lt;li&gt;Difficult to number a whole bunch, and some of them are from third-party&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Starvation&lt;/code&gt;: a set of threads waiting for resources constantly used by others&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Livelock&lt;/code&gt;: a set of threads continue to num but make no progress

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;interrupt livelock&lt;/code&gt;: interrupts queueing up and suspend the running threads
=&amp;gt; Can turn to &lt;code&gt;polling&lt;/code&gt;, with intervals not too long&lt;/li&gt;
&lt;li&gt;Need to ensure a thread runs for a while before switching&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;Synchronization&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Threads&lt;/code&gt; wait on some conditions before proceeding&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Motivation: Producer-Consumer Problem&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Single producer &amp;amp; consumer&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;char buf[8];
int in;
int out;

void send(char msg) {
    while ((in-out+n) % n == n-1)
        ; // full
    buf[in] = msg;
    in = (in+1) % n;
}

char receive() {
    while (in == out)
        ; // empty
    msg = buf[out];
    out = (out+1) % n;
    return msg;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Multiple producers &amp;amp; consumers&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# deadlock

void send(char msg) {
    lock(l);
    while ((in-out+n) % n == n-1)
        ; // full
    buf[in] = msg;
    in = (in+1) % n;
    unlock(l);
}

char receive() {
    lock(l);
    while (in == out)
        ; // empty
    msg = buf[out];
    out = (out+1) % n;
    return msg;
    unlock(l);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# release locks before spinning - too tight

void send(char msg) {
    lock(l);
    while ((in-out+n) % n == n-1) {
        unlock(l);
        lock(l);
    }
    buf[in] = msg;
    in = (in+1) % n;
    unlock(l);
}

char receive() {
    lock(l);
    while (in == out) {
        unlock(l);
        lock(l);
    }
    msg = buf[out];
    out = (out+1) % n;
    return msg;
    unlock(l);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# sleep after unlocking

void send(char msg) {
    lock(l);
    while ((in-out+n) % n == n-1) {
        unlock(l);          ____&amp;gt; atomic! Or else lost wakeup
        thread_sleep(full); __|
        lock(l);
    }
    buf[in] = msg;
    if (in == out)
        thread_wakeup(empty);
    in = (in+1) % n;
    unlock(l);
}

char receive() {
    lock(l);
    while (in == out) {
        unlock(l);
        thread_sleep(empty);
        lock(l);
    }
    msg = buf[out];
    if ((in-out+n) % n == n-1)
        thread_wakeup(full);
    out = (out+1) % n;
    unlock(l);
    return msg;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Challenges&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Can&amp;#39;t spin or sleep while holding lock

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Deadlock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Can&amp;#39;t release lock and then sleep

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Lost wakeup&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Need to &lt;strong&gt;unlock &amp;amp; sleep atomically&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Monitors&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Condition variable&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Used within &lt;code&gt;monitor methods&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cv = cv_create()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv_destroy(cv)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv_wait(cv, lock)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Lock released &lt;code&gt;atomically&lt;/code&gt; while waiting&lt;/li&gt;
&lt;li&gt;Lock reacquired after wait returns&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv_signal(cv, lock)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Wakeup one thread waiting on the condition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lost signal&lt;/code&gt;: signal occurs before a wait&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv_broadcast(cv, lock)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Wakeup all threads waiting on the condition&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Basis&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;F() {
    int disabled = disaple_interrupt;
    do_work();
    enable_interrupt(disabled);
}
do_work(){
    int disabled = disaple_interrupt; // already disabled!
    ...
    enable_interrupt(disabled); // stay disabled
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Producer-consumer&lt;/code&gt; with &lt;code&gt;monitors&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;buf[n], in, out;
lock l = 0;
cv full;
cv empty;

void send(char msg) {
    lock(l);
    while ((in-out+n) % n == n-1) {
        // put thread into wait queue for 'full' condition
        wait(full, l); // unlock + sleep + lock
    }
    buf[in] = msg;
    if (in == out)
        signal(empty, l);
    in = (in+1) % n;
    unlock(l);
}

char receive() {
    lock(l);
    while (in == out) {
        wait(empty, l);
    }
    msg = buf[out];
    if ((in-out+n) % n == n-1)
        signal(full, l);
    out = (out+1) % n;
    unlock(l);
    return msg;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Variable initialization&lt;/code&gt; with &lt;code&gt;monitors&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Method1() {
    lock(l);
    V = malloc(...);
    signal(cv, l); // condition = V is null
    ...
    unlock(l);
}
Method2() {
    lock(l);
    if (V == NULL)
        wait(cv, l); // condition = V is null
    assert(V);
    unlock(l);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Lock&lt;/code&gt; is for avoiding &lt;code&gt;lost wakeup&lt;/code&gt; because &lt;code&gt;signal&lt;/code&gt; CANNOT come before &lt;code&gt;wait&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Semaphores&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Tracks number of available resources using &lt;code&gt;down&lt;/code&gt; &amp;amp; &lt;code&gt;up&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# spinning (example with race condition on s)

down() {
    while (s &amp;lt;= 0)
        ;
    s--;
}
up() {
    s++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# blocked

down() {
    disable_interrupts;
    while (s &amp;lt;= 0)
        thread_sleep(s);
    s--;
    enable_interrupts;
}
up() {
    disable_interrupts;
    s++;
    thread_wakeup(s);
    enable_interrupts;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;s&lt;/code&gt; init to &lt;code&gt;1&lt;/code&gt;, then behaves like &lt;code&gt;lock&lt;/code&gt; &amp;amp; &lt;code&gt;unlock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Difference with &lt;code&gt;lock&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Different&lt;/strong&gt; threads call &lt;code&gt;down&lt;/code&gt; &amp;amp; &lt;code&gt;up&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up&lt;/code&gt; can happen &lt;strong&gt;before&lt;/strong&gt; &lt;code&gt;down&lt;/code&gt; to bank resource&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Producer-consumer&lt;/code&gt; with &lt;code&gt;semaphores&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;buf[n], in, out;
lock l;
sem full = 0;
sem empty = n;

void send(char msg) {
    down(empty);
    lock(l);
    buf[in] = msg;
    in = (in+1) % n;
    unlock(l);
    up(full);
}

char receive() {
    down(full);
    lock(l); // this lock for buf, not for avoiding lost signal
    msg = buf[out];
    out = (out+1) % n;
    unlock(l);
    up(empty);
    return msg;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;&lt;strong&gt;Quick Questions&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;What is the difference between mutual exclusion and synchronization?

&lt;ul&gt;
&lt;li&gt;Mutex: used to ensure that only one thread accesses a critical section at a time, ensuring that operations are run atomically.&lt;/li&gt;
&lt;li&gt;Synchronization: used to ensure threads wait on some condition.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why are locks, by themselves, not sufficient for solving synchronization problems?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Lock&lt;/code&gt; &amp;amp; &lt;code&gt;unlock&lt;/code&gt; are used together and in that order. Synchronization problems require a more general primitive: conditional &lt;code&gt;sleep&lt;/code&gt; and &lt;code&gt;wakeup&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What are the differences between a monitor and a semaphore?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Monitor&lt;/code&gt; requires locks to avoid lost signal. &lt;code&gt;Down/Up&lt;/code&gt; &amp;amp; &lt;code&gt;wait/signal&lt;/code&gt; are also different.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What are the differences between &lt;code&gt;wait()&lt;/code&gt; and &lt;code&gt;down()&lt;/code&gt;?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Wait&lt;/code&gt; is stateless, it always waits. &lt;code&gt;Wait&lt;/code&gt; also releases a lock, waits, and then reacquires a lock. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Down&lt;/code&gt; has state embedded with a notion of available resources, and will only wait if resources are not available. &lt;code&gt;Down&lt;/code&gt; doesn’t have any notion of an associated lock.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What are the differences between &lt;code&gt;signal()&lt;/code&gt; and &lt;code&gt;up()&lt;/code&gt;?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Signal&lt;/code&gt; can be lost if no one is waiting, hence the need to use locks with condition variables, so that there is no race with &lt;code&gt;wait&lt;/code&gt;. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Up&lt;/code&gt; will always increase the resource available, so a future down can acquire the resource. &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why might you prefer one over the other?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;: resource counting problem&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Monitor&lt;/code&gt;: other problems, ensures mutual exclusion&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 23 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/os/2016/10/23/operating-system-concurrent-programming.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/10/23/operating-system-concurrent-programming.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        <category>mutex</category>
        
        <category>synchronization</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>Operating System - Basics</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Basics of OS&lt;/li&gt;
&lt;li&gt;OS Design&lt;/li&gt;
&lt;li&gt;Hardware&lt;/li&gt;
&lt;li&gt;OS-Related Hardware&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Basics of OS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Layer of &lt;code&gt;software&lt;/code&gt; between &lt;code&gt;hardware &amp;amp; applications&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Application dedicated to a single task; OS serves all applications&lt;/li&gt;
&lt;li&gt;Also called &lt;code&gt;systems software&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;What OS does&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Manage H/W resources

&lt;ul&gt;
&lt;li&gt;Allows programs to interact with H/W

&lt;ul&gt;
&lt;li&gt;CPU, memory, disk, graphics card, co-processors, ...&lt;/li&gt;
&lt;li&gt;Simpler interface to devices

&lt;ul&gt;
&lt;li&gt;e.g. access disk as files&lt;/li&gt;
&lt;li&gt;&lt;em&gt;If NOT, apps have to be written to specific H/W devices directly -&amp;gt; deal with all the specific H/W stuffs -&amp;gt; not compatible to another manufacturer&amp;#39;s device&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Allows running many programs at the same time

&lt;ul&gt;
&lt;li&gt;Programs share CPU, memory&lt;/li&gt;
&lt;li&gt;Isolates apps from each other

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;If NOT, then memory corruption a problem&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Isolates itself from apps

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;If NOT, then OS has to compromise for apps; apps may corrupt OS and no isolations provided to them&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;OS Design&lt;/h2&gt;

&lt;h3&gt;Key Ideas&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How does OS allow running many programs?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Virtualization&lt;/code&gt; - programs share resources securely&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;How does OS allow programs to interact with H/W?

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Abstraction&lt;/code&gt; for H/W&lt;/li&gt;
&lt;li&gt;Implemented via &lt;code&gt;System calls&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Virtualization&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Programs think:

&lt;ul&gt;
&lt;li&gt;They are running on their own machine (but only one physical machine!)&lt;/li&gt;
&lt;li&gt;They have full access to CPU, memory, disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Benefits

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Resource isolation&lt;/code&gt; (an ideal virtual machine)

&lt;ul&gt;
&lt;li&gt;Program cannot accidentally overwrite others&amp;#39; memory or files&lt;/li&gt;
&lt;li&gt;Ideally, if a program uses too much memory, only its performance degrades&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Improves &lt;strong&gt;portablity&lt;/strong&gt; of programs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;An ideal virtual machine ~ physical machine, i.e. programs won&amp;#39;t affect each other&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Processor -&amp;gt; Threads&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory -&amp;gt; Virtual Memory&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Contiguous &amp;amp; private memory&lt;/li&gt;
&lt;li&gt;Illusion of access to large amount of memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disk -&amp;gt; Files&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network -&amp;gt; Sockets&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Hides details of network protocols &amp;amp; layers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Abstraction&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Eases programming, improves &lt;strong&gt;portability&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Concurrency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread abstraction&lt;/code&gt; allows program to concurrently perform several tasks

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Race condition?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;System Calls&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Program request H/W access via &lt;code&gt;system calls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OS API&lt;/code&gt;: a set of system calls&lt;/li&gt;
&lt;li&gt;Requires control transfer from &lt;code&gt;user space&lt;/code&gt; to &lt;code&gt;kernel space&lt;/code&gt; via &lt;code&gt;interrupts&lt;/code&gt; or &lt;code&gt;traps&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;e.g.

&lt;ul&gt;
&lt;li&gt;Create/destroy process (&lt;em&gt;process-related system calls&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Allocate/deallocate memory from system (&lt;em&gt;memory-related system calls&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Read/write a file&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ex.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    Program | Library
    -----------------
        OS Kernel                           # program read() 
    -----------------                       # -&amp;gt; library generates trap 
           H/W                              # -&amp;gt; trap invokes kernel 
                                            # -&amp;gt; kernel accesses disk 
    Program (read) -&amp;gt; library               # -&amp;gt; kernel returns results to program
    ------------------(trap)--^----                 
        OS Kernel        |    |
    ---------------------v-(result)
                H/W             
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;OS Interface&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;OS interface&lt;/code&gt; to H/W = set of &lt;strong&gt;system calls&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VM interface&lt;/code&gt; to H/W = subset of physical machine interface + OS interface&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;    * Application Layer

    * OS Interface 
(system calls: thread_create(), read(), write(), thread_join(), ...)

    (when program needs access to devices)
------------virtual machine interface--------
    * OS Kernel                             |
(thread scheduler, memory mgmt,             |
device mgmt, file sys, network comm,        |
protection, process mgmt, security, ...)    |   (when program runs most instructions)
                                            |
-----------physical machine interface---------virtual/physical machine interface-------
                                                    (user mode interface)
    * H/W Layer
(network, CPU, memory, printer, video card, monitor, disk, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;Hardware&lt;/h2&gt;

&lt;h3&gt;&lt;strong&gt;Processor (CPU)&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU executes a set of instructions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fetch&lt;/code&gt; - &lt;code&gt;Decode&lt;/code&gt; - &lt;code&gt;Execute&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;PC = &amp;lt;start address&amp;gt;;
while (halt flag not set) {
    IR = memory[PC];
    PC++;
    execute(IR);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Anatomy of a CPU:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Program Counter (PC)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Instruction Register (IR)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;General Registers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack Pointer (SP)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Status Register (SR)&lt;/code&gt; or &lt;code&gt;Processor Status Word&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Memory&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Memory (DRAM) provides storage for &lt;code&gt;code&lt;/code&gt; &amp;amp; &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Abstraction

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Write(addr, val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val = Read(addr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Anatomy of memory

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Data sections&lt;/code&gt;: global vars&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;: local vars, parameters, return values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Heap&lt;/code&gt;: dynamic vars&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;I/O Devices&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Runs &lt;strong&gt;concurrently&lt;/strong&gt; with &lt;code&gt;CPU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Connected to &lt;strong&gt;device-specific controllers&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buses&lt;/code&gt; connect &lt;code&gt;CPU&lt;/code&gt; to &lt;code&gt;memory&lt;/code&gt; &amp;amp; &lt;code&gt;controllers&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Each &lt;code&gt;controller&lt;/code&gt; owns a range of &lt;code&gt;bus addresses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; sends messgage to address using:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Special I/O instructions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory-mapped I/O&lt;/code&gt;: 

&lt;ul&gt;
&lt;li&gt;Memory locations mapped to device registers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Communication model

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Send(addr, val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;val = Receive(addr)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; polling the addr for val &amp;amp; read the data with another address&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Similar to memory abstraction?

&lt;ul&gt;
&lt;li&gt;But data may &lt;em&gt;never arrive&lt;/em&gt;, &lt;em&gt;get corrupted&lt;/em&gt;, or &lt;em&gt;arrive out-of-order&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Polling&lt;/code&gt; frequency?

&lt;ul&gt;
&lt;li&gt;Too high -&amp;gt; waste CPU&lt;/li&gt;
&lt;li&gt;Too low -&amp;gt; data loss or delay&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Interrupts&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Polling&lt;/code&gt; not efficient -&amp;gt; let devices send &lt;code&gt;interrupts&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; has &lt;code&gt;interrupt request flag&lt;/code&gt; to be set by devices&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Requires support from H/W &amp;amp; S/W&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Processor execution with &lt;code&gt;interrupts&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. (H/W) When interrupt flag set:
    H/W saves PC
    Set PC to predetermined address
    The address contains 'interrupt handler'
2. (S/W) When H/W executes next instruction:
    Save CPU registers
    Run interrupt handler
    Restore CPU registers
3. (S/W) Handler runs 'return from interrupt' instruction:
    Set PC to original next instruction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;PC = &amp;lt;start address&amp;gt;;
while (halt flag not set) {
    IR = memory[PC];
    PC++;
    execute(IR);
    if (InterruptRequest) {
        H/W save PC, SP, SR in stack; // not all states, only those necessary to be returned from handler
        PC = memory[0]; // where interrupt handler resides
    }
}
Interrupt_handler(){
    save_processor_state(); // gets to choose essential states to save
    handle_interrupt();
    restore_processor_state();
    return;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;OS-Related Hardware&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OS is S/W, when other apps are running, it is not. How does OS manage resources?

&lt;ul&gt;
&lt;li&gt;Requires H/W support to implement virtualization &amp;amp; abstraction &lt;strong&gt;efficiently&lt;/strong&gt; &amp;amp; &lt;strong&gt;securely&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Efficient&lt;/strong&gt; because no need to provide interpreter for every single instruction that provides H/W &lt;code&gt;abstraction&lt;/code&gt; &amp;amp; &lt;code&gt;virtualization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Secure&lt;/strong&gt; because &lt;code&gt;CPU modes&lt;/code&gt;, &lt;code&gt;MMU&lt;/code&gt;, &amp;amp; &lt;code&gt;traps&lt;/code&gt; ensure no corruption between programs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;CPU Modes&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;2 CPU Modes:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Kernel mode&lt;/code&gt; - OS

&lt;ul&gt;
&lt;li&gt;Every instruction can be executed&lt;br&gt;
e.g. access disk &amp;amp; timer, controll interrupts, setting CPU mode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User mode&lt;/code&gt; - Programs

&lt;ul&gt;
&lt;li&gt;A subset of instructions can be executed&lt;br&gt;
e.g. &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Current mode kept in &lt;code&gt;status register&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Devices mapped to kernel memory&lt;/li&gt;
&lt;li&gt;OS is priviledged &amp;amp; trusted program; correct system operation depend on correct OS design &amp;amp; implementation instead of user programs&lt;/li&gt;
&lt;li&gt;Enables &lt;code&gt;memory isolation&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Memories &amp;amp; registers can only be changed in &lt;code&gt;privileged mode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Memory Management&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Memory Management Unit (MMU)&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;Programs use &lt;code&gt;virtual memory addresses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; sends &lt;code&gt;virtual addresses&lt;/code&gt; to &lt;code&gt;MMU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MMU&lt;/code&gt; translates them to &lt;code&gt;physical addresses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MMU&lt;/code&gt; accesses &lt;code&gt;physical addresses&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Anatomy of a simple MMU

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Base register&lt;/code&gt;
&lt;code&gt;Phys addr = Virt addr + Base reg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Limit register&lt;/code&gt;
&lt;code&gt;Virt addr &amp;lt; Limit reg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Enables &lt;code&gt;memory virtualization&lt;/code&gt; &amp;amp; &lt;code&gt;memory isolation&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Memory virtualization&lt;/code&gt;: Each program has access to a large amount of contiguous, private memory, starting at address 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory isolation&lt;/code&gt;: Ensures OS &amp;amp; other programs are located in different physical memory, and they cannot step on each other&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;strong&gt;Trap&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For programs to switch to &lt;code&gt;kernel mode&lt;/code&gt; and run &lt;code&gt;OS code&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Programs cannot call &lt;code&gt;OS code&lt;/code&gt; directly because &lt;code&gt;MMU&lt;/code&gt; isolates &lt;code&gt;OS code&lt;/code&gt; &amp;amp; program not in &lt;code&gt;kernel mode&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Provides a secure way to enter the kernel&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Similar to handling &lt;code&gt;interrupts&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# (H/W) On trap:
    Switch to kernel mode
    Run OS handler code at well-defined location
# (S/W) OS handler code:
    Save processor state
    Runs kernel functions to access H/W
    Restore processor state
    Return to user code, switch to user mode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; &lt;strong&gt;atomic&lt;/strong&gt; to avoid &lt;code&gt;user code&lt;/code&gt; running in &lt;code&gt;kernal mode&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unix system calls&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Process related&lt;br&gt;
e.g. fork, exec, wait, exit, kill, signal&lt;/li&gt;
&lt;li&gt;File related&lt;br&gt;
e.g. open, read, write, close, link, unlink, chdir&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Invoking system call&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;read(file, buff, n) { // library code
    ...
    lw v0, SYS_read // load syscall number into v0 reg

    syscall // trap
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Traps&lt;/code&gt;, &lt;code&gt;interrupts&lt;/code&gt;, &lt;code&gt;exceptions&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Interrupt&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Trap&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Exception&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Cause&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;H/W external to CPU&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Explicit intruction&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Instruction failure&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Effect&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Program unaware of interrupt handling (async)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Similar to program invoked function, function returns data (sync)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Abnormal control flow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Timeliness&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Needs to respond quickly&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Program suspended, OS can take time&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;OS can take time&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h2&gt;&lt;strong&gt;Quick Questions&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;How does OS manage H/W?

&lt;ul&gt;
&lt;li&gt;Abstraction &amp;amp; virtualization&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OS is software, when other applications are running, it is not running, so how can it do its work?

&lt;ul&gt;
&lt;li&gt;H/W support e.g. CPU modes, MMU, traps&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why can’t applications corrupt other applications or the OS?

&lt;ul&gt;
&lt;li&gt;MMU helps&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why can’t applications directly access h/w?

&lt;ul&gt;
&lt;li&gt;I/O devices are mapped to kernel memory, so no access allowed by MMU; or, I/O intructions are priviledged&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why is the OS not a normal program?

&lt;ul&gt;
&lt;li&gt;Entered from different locations (system calls and interrupts) in response to external events&lt;/li&gt;
&lt;li&gt;It does not have a single thread of control, it can be invoked simultaneously by two different events (e.g. system call &amp;amp; interrupt)&lt;/li&gt;
&lt;li&gt;It is not supposed to terminate&lt;/li&gt;
&lt;li&gt;Can execute any instruction in the machine&lt;/li&gt;
&lt;li&gt;Has access to the entire memory on the machine&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What if a program tries to cheat?

&lt;ol&gt;
&lt;li&gt;What happens if it issues a privileged instruction directly? 

&lt;ul&gt;
&lt;li&gt;Attempting execution of privileged instruction in user mode causes trap, so kernel gets control. Normally, kernel will kill program.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What if a running thread doesn’t make a system call to the OS and hence hogs the CPU?

&lt;ul&gt;
&lt;li&gt;OS must register a future timer interrupt before it hands control of the CPU over to a thread; when the timer interrupt goes off, the OS gets control&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What stops the running program from disabling an interrupt?

&lt;ul&gt;
&lt;li&gt;It is a priviledges instruction&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What stops a program from modifying the OS so that the OS runs user code?

&lt;ul&gt;
&lt;li&gt;Program cannot even see OS code due to memory virtualization&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What stops a program from changing the MMU registers?

&lt;ul&gt;
&lt;li&gt;It is a priviledges instruction&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;How does the OS solve these problems:

&lt;ol&gt;
&lt;li&gt;Time sharing the CPU among programs?

&lt;ul&gt;
&lt;li&gt;Timer interrupts&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Space sharing memory among programs?

&lt;ul&gt;
&lt;li&gt;MMU&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Protection of programs from each other?

&lt;ul&gt;
&lt;li&gt;1. &amp;amp; 2.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Protection of hardware/devices?

&lt;ul&gt;
&lt;li&gt;I/O devices are mapped to kernel memory, so no access allowed by MMU; or, I/O intructions are priviledged&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Protection of the OS itself?

&lt;ul&gt;
&lt;li&gt;MMU isolates OS code&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Does library code (executing in user mode) provide isolation and abstraction?

&lt;ul&gt;
&lt;li&gt;Provides abstraction but not isolation. Programs can jump to any instruction in library code, overwrite library code/data, thus bypassing any isolation that library code may try to provide.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Does a virtual machine monitor (VMM) such as VMware provide isolation and abstraction?

&lt;ul&gt;
&lt;li&gt;A VMM is a system program, similar to an OS, that allows multiple OSs to run simultaneously on a single physical machine&lt;/li&gt;
&lt;li&gt;It provides isolation, but the same abstraction as a physical machine (each OS thinks it is running on physical hardware), thus providing no additional abstraction than the physical machine.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why can’t user code execute some arbitrary code of its choosing in kernel mode?

&lt;ul&gt;
&lt;li&gt;User code wants to execute some code in kernel mode, so what can it do?

&lt;ol&gt;
&lt;li&gt;Write instructions into kernel image - can’t do that due to memory protection.&lt;/li&gt;
&lt;li&gt;Transfer control to arbitrary places in kernel image to skip checks - can’t do this due to memory protection, and control can only be transferred via TRAP to well known kernel entry locations.&lt;/li&gt;
&lt;li&gt;Execute privileged instructions - can’t do this in user mode.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is the minimum number of privileged instructions that h/w must implement so that the OS can work correctly?

&lt;ul&gt;
&lt;li&gt;With memory mapped IO, you can hide all device accesses with memory protection. So programming the MMU (i.e., modify MMU registers) should be privileged. &lt;/li&gt;
&lt;li&gt;Also, returning from a trap (e.g., iret instruction) should ensure that we cannot switch from user to kernel mode and run arbitrary kernel code. For example, on x86, a return from trap is guaranteed to execute code with the same or lower privilege level.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 21 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/os/2016/10/21/operating-system-basics.html</link>
        <guid isPermaLink="true">/blog/notes/os/2016/10/21/operating-system-basics.html</guid>
        
        <category>OS</category>
        
        <category>ECE344</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>OS</category>
        
      </item>
    
      <item>
        <title>Divide and Conquer</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Multiplication&lt;/li&gt;
&lt;li&gt;Convex Hull&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h1&gt;Divide &amp;amp; Conquer&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Breaking problems into subproblems&lt;/li&gt;
&lt;li&gt;Recursively solving these subproblems&lt;/li&gt;
&lt;li&gt;Combining the answers&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;a subproblems of size n/b, combining the answers in O(n^d) time.

The k-th level of tree has a^k subproblems, each of size n/(b^k).
=&amp;gt; a^k * O(n/(b^k)^d) = O(n^d) * (a/(b^d))^k

=&amp;gt; T(n) = aT(⌈n/b⌉) + O(nd)
        = O(n^d)          if a/(b^d) &amp;lt; 1
        = O((n^d)logn)    if a/(b^d) = 1
        = O(n^(log_b(a))) if a/(b^d) &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Multiplication&lt;/h2&gt;

&lt;p&gt;Multiply 2 n-bit integers &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is a power of 2.&lt;/p&gt;

&lt;h4&gt;Steps&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Split &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; into halves.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x = 2^(n/2)xl + xr&lt;/code&gt;&lt;br&gt;
&lt;code&gt;y = 2^(n/2)yl + yr&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Multiplication becomes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xy = (2^(n/2)xl + xr) * (2^(n/2)yl + yr) = (2^n)xlyl + 2^(n/2)(xlyr + xryl) + xryr&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Consider:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;xlyr + xryl = (xl + xr)(yl + yr) - xlyl - xryr&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Multiplication becomes 3 multiplication subproblems.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Running Time&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;At depth k, there are &lt;code&gt;3^k&lt;/code&gt; subproblems, each of size &lt;code&gt;n/(2^k)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3^k * O(n/(2^k)) = (3/2)^k * O(n)&lt;/code&gt; at depth k&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T(n) = 3T(n/2) + O(n) = O(n^1.59)&lt;/code&gt; in total&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Pseudocode&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Multiply(x, y):
    # Input: Positive integers x and y, in binary 
    # Output: Their product

    n = max(size of x, size of y) 
    if n = 1: 
        return xy

    xL, xR = leftmost⌈n/2⌉, rightmost⌊n/2⌋ bits of x yL, yR = leftmost⌈n/2⌉, rightmost⌊n/2⌋ bits of y

    P1 = Multiply(xL, yL)
    P2 = Multiply(xR, yR)
    P3 = Multiply(xL + xR, yL + yR)
    return P1 × 2^n + (P3 − P1 −P2) × 2^(n/2) + P2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Convex Hull&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Graham&amp;#39;s scan: &lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;em&gt;Divide and Conquer Convex Hull&lt;/em&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Generalization of &lt;strong&gt;MergeSort&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Pseudocode&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Presort points by x coordinate =&amp;gt; O(nlogn)
# Assume linked list of hull vertices

MergeHull(HA, HB):
    Compute upper &amp;amp; lower tangents for HA &amp;amp; HB
    Discard all points lying between 2 tangents
    return MergedH

Hull(S):
    If |S| &amp;lt;= 3:
        Compute convex hull by brute force # =&amp;gt; O(1)
        return H
    Else:
        Partition S into A (lowest x) &amp;amp; B (highest x) # =&amp;gt; O(n)
        HA = Hull(A)
        HB = Hull(B)
        H = MergeHull(HA, HB) # =&amp;gt; O(n)
        return H
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt;  &lt;code&gt;
    T(n) = 1           if n &amp;lt;= 3
           n + 2T(n/2) otherwise
&lt;/code&gt;
=&amp;gt; &lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Computing Tangents&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Walking procedure

LowerTangent(HA, HB):
    Init a = rightmost point of HA
    Init b = leftmost point of HB

    # Orientation test of a, b, and neighboring vertices 
    While ab not a lower tangent for HA &amp;amp; HB:
        While ab not a lower tangent for HA:
            a = a - 1 # move clockwise
        While ab not a lower tangent for HB:
            b = b + 1 # move counterclockwise
    Return ab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; &lt;code&gt;O(|HA| + |HB|) &amp;lt;= O(|A| + |B|) = O(n)&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;Quickhull&lt;/em&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Generalization of &lt;strong&gt;QuickSort&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(nlogn)&lt;/code&gt; ~ &lt;code&gt;O(n^2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;No obvious way to convert it into randomized algorithm with &lt;code&gt;O(nlogn)&lt;/code&gt; expected running time; but still performs well&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Idea&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Discard points not on the hull as quickly as possible&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Steps&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Find max &amp;amp; min x, y coordinates&lt;/li&gt;
&lt;li&gt;Draw a bounding rectangle -&amp;gt; those lying within discarded =&amp;gt; &lt;code&gt;O(n)&lt;/code&gt; by now&lt;/li&gt;
&lt;li&gt;Classify remaining points into 4 corners -&amp;gt; if no remaining, then done&lt;/li&gt;
&lt;li&gt;For each corner, find a point &lt;code&gt;c&lt;/code&gt; that lies on the hull. May choose &lt;code&gt;c&lt;/code&gt; by the most perpendicular distance.&lt;/li&gt;
&lt;li&gt;Discard those in the triangle, and split remaining points into 2 subsets (classify them by 2 orientation tests).&lt;/li&gt;
&lt;li&gt;Add the 2 corners in buckets, and recurse.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Running Time&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Depends on how evenly the points are split&lt;br&gt;
=&amp;gt;  &lt;code&gt;
T(n) = 1             if n = 1
       T(n1) + T(n2) where n1 + n2 &amp;lt;= n
&lt;/code&gt;&lt;br&gt;
=&amp;gt; &lt;code&gt;O(nlogn)&lt;/code&gt; if evenly distributed (&lt;code&gt;n1 ~= n2&lt;/code&gt;; &lt;code&gt;max(n1, n2) &amp;lt;= a * n&lt;/code&gt; for some constant &lt;code&gt;a &amp;lt; 1&lt;/code&gt;)&lt;br&gt;
=&amp;gt; &lt;code&gt;O(n^2)&lt;/code&gt; otherwise&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;em&gt;Gift Wrapping and Jarvis&amp;#39;s March&lt;/em&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Variation of &lt;strong&gt;SelectionSort&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O(n^2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Steps&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Find any point on convex hull, e.g. lowest point&lt;/li&gt;
&lt;li&gt;Say start with &lt;code&gt;p(0) = (Inf, 0)&lt;/code&gt;, &lt;code&gt;p(1) = lowest point&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Assume &lt;code&gt;p(k)&lt;/code&gt; &amp;amp; &lt;code&gt;p(k-1)&lt;/code&gt; were the last 2 points added, find the next one &lt;code&gt;q&lt;/code&gt; s.t. &lt;code&gt;angle[p(k-1), p(k), q]&lt;/code&gt; is maximized =&amp;gt; &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Repeat &lt;code&gt;h&lt;/code&gt; times, return back to starting point&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Running Time&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;O(nh)&lt;/code&gt;, where n is the input size, h is the output size&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If h = o(logn), then faster than Graham&amp;#39;s!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;em&gt;Chan&amp;#39;s Algorithm&lt;/em&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Combination of &lt;strong&gt;Graham&amp;#39;s scan&lt;/strong&gt; &amp;amp; &lt;strong&gt;Jarvis&amp;#39;s march&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Aims to be &lt;code&gt;O(nlogh)&lt;/code&gt; (lower bound)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Steps&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Partition points into groups of equal size &lt;code&gt;m&lt;/code&gt; points, total &lt;code&gt;r&lt;/code&gt; groups&lt;/li&gt;
&lt;li&gt;For each group, compute its hull using &lt;strong&gt;Graham&amp;#39;s scan&lt;/strong&gt; =&amp;gt; total &lt;code&gt;O(rmlogm)&lt;/code&gt; = &lt;code&gt;O(nlogm)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;strong&gt;Jarvis&amp;#39;s march&lt;/strong&gt; on the groups. Computing tangent between a point &amp;amp; a convex &lt;code&gt;m&lt;/code&gt; takes &lt;code&gt;O(logm)&lt;/code&gt; time (binary search)&lt;br&gt;
=&amp;gt; total &lt;code&gt;O(rlogm)&lt;/code&gt; for &lt;code&gt;r&lt;/code&gt; groups&lt;br&gt;
=&amp;gt; &lt;code&gt;h&lt;/code&gt; steps of Jarvis&amp;#39;s march, total &lt;code&gt;O(hrlogm)&lt;/code&gt; time&lt;/li&gt;
&lt;li&gt;Combining, we get &lt;code&gt;O((n + hn/m) logm)&lt;/code&gt; time&lt;/li&gt;
&lt;li&gt;If set &lt;code&gt;m = h&lt;/code&gt;, running time &lt;code&gt;O(nlogh)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Tricks&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;How do we know what &lt;code&gt;m&lt;/code&gt; is if we don&amp;#39;t know &lt;code&gt;h&lt;/code&gt; in advance?

&lt;ul&gt;
&lt;li&gt;Guess the value: try &lt;code&gt;m = 1, 2, ...&lt;/code&gt;, until &lt;code&gt;m &amp;gt;= h&lt;/code&gt; =&amp;gt; too long!&lt;/li&gt;
&lt;li&gt;Binary search =&amp;gt; but if &lt;code&gt;m = n/2&lt;/code&gt;, stuck to &lt;code&gt;O(nlogn)&lt;/code&gt; time&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Doubling search&lt;/strong&gt;:
Start with small &lt;code&gt;m&lt;/code&gt; and increase it rapidly (say, squaring it) =&amp;gt; &lt;code&gt;O(nlogh)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Pseudocode&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;PartialHull(P, m):

    Let r = ceil(n/m)
    Partition P into disjoint subsets P(1),P(2),... P(r), each of size at most m

    For i = 1 to r do:
        Compute Hull(P(i)) using Graham's scan
        Store the vertices in an ordered array

    Let p0 = (-Inf, 0)
    Let p1 be the bottommost point of P

    For k = 1 to m do: # =&amp;gt; O(hrlogm) where we assume h = m
        For i = 1 to r do: # =&amp;gt; O(rlogm)
            Compute point q in P(i) that maximizes the angle[p(k-1), p(k), q] # =&amp;gt; O(logm)
        Let p(k+1) be the point q in q(1),q(2),...q(r) that maximizes the angle[p(k-1), p(k), q]
        If p(k+1) = p(1):
            Return {p(1), p(2), ... p(k)}

    Return &quot;m was too small, try again.&quot;

Hull(P):

    For t = 1.. do: # stop when 2^2^t &amp;gt;= h, or t = ceil(lglgh)
        Let m = min(2^(2^t), n)
        Let L = PartialHull(P, m)
        If L != &quot;try again&quot;:
            Return L

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Running Time&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;The t-th iteration takes O(nlog2^2^t) = O(n*2^t) time
Sum(t = 1..lglgh) n*2^t =
    n * Sum(t = 1..lglgh) 2^t &amp;lt;= 
    n * 2^(1+lglgh) = 
    2nlgh = 
    O(nlogh)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.wustl.edu/%7Epless/506/l3.html&quot;&gt;http://www.cs.wustl.edu/~pless/506/l3.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 12 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/algorithm/2016/10/12/divide-and-conquer.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/10/12/divide-and-conquer.html</guid>
        
        <category>convex hull</category>
        
        <category>divide and conquer</category>
        
        <category>algorithm</category>
        
        <category>CSC384</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Greedy Algorithm</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Minimum Spanning Tree&lt;/li&gt;
&lt;li&gt;Huffman Encoding&lt;/li&gt;
&lt;li&gt;Interval Scheduling&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h1&gt;Greedy Algorithms&lt;/h1&gt;

&lt;h3&gt;What is greedy?&lt;/h3&gt;

&lt;p&gt;Take the best move at the moment without worrying about future outcomes.&lt;/p&gt;

&lt;h2&gt;Minimum Spanning Tree&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A graph, connecting all nodes with edges that cost the least in total.&lt;/li&gt;
&lt;li&gt;No cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Definition&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Input&lt;/em&gt;: An undirected graph G = (V, E); edge weights we&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Output&lt;/em&gt;: A tree T = (V,E&amp;#39;), with E&amp;#39; ⊆ E, that minimizes weight(T) = Σ(e ⊆ E&amp;#39;)we&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Trees&lt;/h4&gt;

&lt;p&gt;Undirected graph, connected &amp;amp; acyclic  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Removing a cycle edge cannot disconnect a graph&lt;/li&gt;
&lt;li&gt;A tree with &lt;code&gt;n&lt;/code&gt; nodes has &lt;code&gt;n-1&lt;/code&gt; edges&lt;/li&gt;
&lt;li&gt;Any connected, undirected graph with &lt;code&gt;|E| = |V| - 1&lt;/code&gt; is a tree.&lt;/li&gt;
&lt;li&gt;An undirected graph is a tree &amp;lt;- there&amp;#39;s a unique path between any pair of nodes&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;&lt;em&gt;Kruskal&amp;#39;s MST Algorithm&lt;/em&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Start with empty graph&lt;/li&gt;
&lt;li&gt;Add the next lightest edge that doesn&amp;#39;t produce a cycle&lt;/li&gt;
&lt;li&gt;Do until all nodes connected&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;The Cut Property&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Cut: any partition of vertices into 2 groups &lt;code&gt;S&lt;/code&gt; &amp;amp; &lt;code&gt;V-S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;X&lt;/code&gt; be subset of MST not crossing between &lt;code&gt;S&lt;/code&gt; &amp;amp; &lt;code&gt;V-S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pick &lt;code&gt;e&lt;/code&gt; to be the lightest edge connecting &lt;code&gt;S&lt;/code&gt; &amp;amp; &lt;code&gt;V-S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X ∪ {e}&lt;/code&gt; is MST&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Implementation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Kruskal(G, w):
# Input: A connected undirected graph G = (V, E) with edge weights we 
# Output: A minimum spanning tree defined by the edges X

    for all u ∈ V : # =&amp;gt; O(|V|)
        makeset(u) # create a singleton set containing just u

    X = {}
    Sort the edges E by weight # =&amp;gt; O(|E|log|V|) where log|E| ~ log|V|
    for all edges {u, v} ∈ E, in increasing order of weight: # = O(|E|log|V|)
        # find sets to which u &amp;amp; v belong
        if find(u) != find(v):
            add edge {u, v} to X 
            union(u, v) # merging sets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Running Time&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;O(|E|log|V|)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Data Structure for Disjoin Sets&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Directed tree&lt;/li&gt;
&lt;li&gt;Root element as identifier&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# π = parent pointer
# rank = height of subtree hanging from that node

makeset(x): # = O(1)
    π(x) = x
    rank(x) = 0

find (x): # = O(logn)
    while x != π(x): 
        x = π(x) 
    return x

union(x, y)  # = O(logn)
    rx = find(x)
    ry = find(y)
    if rx = ry: 
        return 
    if rank(rx)  rank(ry):
        π(ry) = rx  # make root of y-tree point to root of x-tree
    else:
        π(rx) = ry
        if rank(rx)=rank(ry): 
            rank(ry)=rank(ry)+1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Any root node of rank &lt;code&gt;k&lt;/code&gt; has at least &lt;code&gt;2^k&lt;/code&gt; nodes in its tree&lt;/li&gt;
&lt;li&gt;So if &lt;code&gt;n&lt;/code&gt; elements overall, at most &lt;code&gt;n/(2^k)&lt;/code&gt; of rank &lt;code&gt;k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;=&amp;gt; max rank = &lt;code&gt;log(n)&lt;/code&gt; (upper bound of &lt;code&gt;find&lt;/code&gt; &amp;amp; &lt;code&gt;union&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Optimization - Path Compression&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;find(x):
    if x != π(x): 
        π(x) = find(π(x)) 
    return π(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;em&gt;Prim&amp;#39;s Algorithm&lt;/em&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Start with empty graph&lt;/li&gt;
&lt;li&gt;Add any vertex to &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add a min-weight edge from &lt;code&gt;S&lt;/code&gt; to &lt;code&gt;V-S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Repeat until done&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Pseudocode&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;X = { } (edges picked so far) 
repeat until |X| = |V| − 1:
    pick a set S ⊂ V for which X has no edges between S and V−S
    let e ∈ E be the minimum-weight edge between S and V − S
    # cost(v) = min(u ∈ S)(w(u, v))
    X = X ∪ {e}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Implementation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Prim(G, w):
# Input: A connected undirected graph G = (V, E) with edge weights we 
# Output: A minimum spanning tree defined by the array prev
    for all u ∈ V: 
        cost(u) = ∞
        prev(u) = nil
    Pick any initial node u0 
    cost(u0) = 0

    H = makequeue (V) # priority queue, using cost-values as keys 
    while H is not empty:
        v = deletemin(H) 
        for each {v, z} ∈ E:
            if cost(z) &amp;gt; w(v, z): 
                cost(z) = w(v, z) 
                prev(z) = v 
                decreasekey(H, z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Running Time&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;O(|E|log|V|)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Difference with Dijkstra&amp;#39;s Algorithm&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Key by with priority queue is ordered

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Prim&amp;#39;s&lt;/strong&gt;: lightest incoming edge from set S&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dijkstra&amp;#39;s&lt;/strong&gt;: length of path from start to that node&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Huffman Encoding&lt;/h2&gt;

&lt;p&gt;Encode a string of length T over alphabet Γ&lt;/p&gt;

&lt;h4&gt;Prefix-free Encoding&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No codeword can be a prefix of another&lt;/li&gt;
&lt;li&gt;Can be represented by a &lt;em&gt;full&lt;/em&gt; binary tree&lt;/li&gt;
&lt;li&gt;Leaves: symbols&lt;/li&gt;
&lt;li&gt;Path from root to leaf: codeword, left = 0, right = 1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Optimal Coding Tree&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A tree whose leaves each correspond to a symbol&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Min overall length of encoding&lt;br&gt;
&lt;code&gt;cost of tree = Σ(i=1, n) fi * di&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Or, combine freq of 2 decendants into freq of parent:&lt;br&gt;
&lt;code&gt;cost of tree = Σ(leaves) fi + Σ(internal nodes) fi&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Construction&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Implication: nodes with smallest freq @ bottom of tree&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Greedy construction:

&lt;ol&gt;
&lt;li&gt;Find 2 smallest freq nodes&lt;/li&gt;
&lt;li&gt;Combine into new node, &lt;code&gt;f = f1 + f2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace 2 nodes with new node&lt;/li&gt;
&lt;li&gt;Repeat&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Implementation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Huffman(f):
# Input: An array f [1 · · · n] of frequencies 
# Output: An encoding tree with n leaves

    let H be a priority queue of integers, ordered by f 
    for i = 1 to n: 
        insert(H,i)
    for k = n + 1 to 2n − 1:
        i = deletemin(H), j = deletemin(H)
        create a node numbered k with children i, j 
        f[k] = f[i] + f[j]
        insert(H, k)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; Binary heap: &lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Interval Scheduling&lt;/h2&gt;

&lt;h3&gt;&lt;em&gt;Max Compatible Interval Scheduling&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;A set of requests {1, 2, ..., n}; the ith request starts at s(i) and ends at f(i). Schedule the most intervals.&lt;/p&gt;

&lt;h4&gt;Attempts&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Earliest starting time&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Earliest request takes long?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Smallest interval&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|-------------|    |--------------|
            |----------|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fewest conflicts&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;|------|  |-------|  |-------|  |-------|
    |-------|   |-------|  |-------|
    |-------|              |-------|
    |-------|              |-------|
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Solution&lt;/h4&gt;

&lt;p&gt;Base on earliest finish time.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;
# Initially let R be the set of all requests, and let A be empty 

While R is not yet empty
    Choose a request i ∈ R that has the smallest finishing time
    Add request i to A
    Delete all requests from R that are not compatible with request i
EndWhile
Return the set A as the set of accepted requests

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Proof&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Let &lt;code&gt;O&lt;/code&gt; be an optimal set of compatible intervals. Prove that &lt;code&gt;A&lt;/code&gt; contains the same # of intervals as &lt;code&gt;O&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Let A = {i1, ..., ik}, O = {j1, ..., jm}. Prove k = m.

From our algo: f(i1) &amp;lt;= f(j1) # we 'stay ahead'
Now prove for each r = 1, f(ir) &amp;lt;= f(jr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For all indices r &amp;lt;= k, we have &lt;code&gt;f(ir) &amp;lt;= f(jr)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Prove by induction.

For r = 1, true.
Let r  1. Assume f(i_r-1) &amp;lt;= f(j_r-1).
We know f(j_r-1) &amp;lt;= s(jr), since O has compatible intervals.
= f(i_r-1) &amp;lt;= f(j_r-1) &amp;lt;= s(jr)
Thus jr is in set R of available intervals when our algorithm selects ir, hence f(ir) &amp;lt;= f(jr) so that we didn't choose it.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; for each r, the rth interval we select finishes at least as soon as the rth interval in O.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;A&lt;/code&gt; is optimal.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Prove by contradiction.

Assume A not optimal, then m  k. # O schedules more than A
By 2., there is request j_k+1 in O.
This request starts after request jk ends &amp;amp; hence after ik ends.
So R still contains j_k+1, which is valid to be put into A.
- Contradiction -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Running Time&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Extension&lt;/h4&gt;

&lt;p&gt;Consider cost of rejecting an interval = &lt;strong&gt;Weighted Interval Scheduling Problem&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;Schduling All Intervals&lt;/h3&gt;

&lt;p&gt;Partition all intervals across multiple resources = &lt;strong&gt;Interval Partitioning/ Coloring Problem&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;Lowerbound&lt;/h4&gt;

&lt;p&gt;In any instance of interval partitioning, &lt;code&gt;# of resources needed = depth of set of intervals&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;Pseudocode&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Sort the intervals by their start times, breaking ties arbitrarily 

Let I1, I2, . . . , In denote the intervals in this order
For j=1,2,3,...,n
    For each interval Ii that precedes Ij in sorted order and overlaps it 
        Exclude the label of Ii from consideration for Ij
    Endfor
    If there is any label from {1, 2, . . . , d} that has not been excluded then
        Assign a nonexcluded label to Ij 
    Else
        Leave Ij unlabeled 
    Endif
Endfor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Proof&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Every interval will be assigned a label. No 2 overlapping intervals receive the same label&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;1. No interval unlabeled.

Consider Ij, suppose t intervals precedes it and overlap it.
These t intervals + Ij = t+1 intervals all passes over s(Ij), so 
    t+1 &amp;lt;= d
    t &amp;lt;= d-1
Hence there will be a label to assign to Ij.

2. No 2 overlapping intervals assigned the same label.

I precedes I', and when I' is considered, we will not assign the label of I to I' from our algorithm.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You will hence never reach a point where all labels are currently in use, which matches the lower bound and is optimal.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;&lt;em&gt;Minumum Maximum Lateness&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;A set of n requests, resource available from time s, requiring t to finish, and deadline d. Schedule all requests while minimizing lateness.&lt;/p&gt;

&lt;h4&gt;Attempts&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In order of increasing length ti&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;t1 = 2, d1 = 100; t2 = 10, d2 = 10?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In order of increasing &lt;em&gt;slack&lt;/em&gt; time &lt;code&gt;di - ti&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;t1 = 1, d1 = 2; t2 = 10, d2 = 10?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Solution&lt;/h4&gt;

&lt;p&gt;Base on earlier deadlines.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Order the jobs in order of their deadlines
# Assume for simplicity of notation that d1 ≤ ... ≤ dn 

Initially, f = s
Consider the jobs i = 1, ..., n in this order
    Assign job i to the time interval from s(i) = f to f(i) = f + ti 
    Let f = f + ti
End
Return the set of scheduled intervals [s(i), f (i)] for i = 1, . . . , n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Proof&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Schedule has no &lt;strong&gt;gaps&lt;/strong&gt;, i.e. no idle time.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is an optimal schedule with no idle time.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Prove by exchange argument.

Suppose schedule A' has an inversion if job i with di scheduled before job j with dj, but dj &amp;lt; di. Our algorithm has no inversions.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All schedules with no inversions &amp;amp; no idle time have the same max lateness.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;2 schedules with these properties can only differ in the order in which jobs with the same deadlines are scheduled.

Let such deadline be d. There are some jobs with deadline d and scheduled consecutively. Among them, the latest scheduled one has the greatest lateness. This lateness does not depend on the order of the jobs!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There is an optimal schedule with no inversions and no idle time.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;a. If O has an inversion, there is a pair of jobs i &amp;amp; j s.t. j is schedules immediately after i, but dj &amp;lt; di.
b. Swapping i, j, we get a schedule with one less inversion.
c. The new max lateness &amp;lt;= original lateness.

    Assume each request r is scheduled [sr, fr] with lateness lr. Let L = max_r(lr).

    Let O' be the swapped schedule.

    = fi = sj, f'j = s'i

    All other jobs remain finishing at the same time after the swap, since t(i)+t(j) is the same.

    Job j will not have lateness increased, since it is put forward.

    For job i:
        If i not delayed, we're done.
        If i delayed:
            l'i = f'i - di = fj - di. Since di  dj:
                l'i = fj - di &amp;lt; fj - dj = lj

    Since L = lj  l'i, the swap doesn't increase max lateness.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An optimal schedule with no inversions exists. And all such schedules have the same max lateness. Hence algorithm optimal.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Extension&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Includes release time?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dasguptap, S., Papadimitriou, C.H., &amp;amp; Vazirani, U.V. Algorithms. Chapter 5.1-5.2.&lt;/li&gt;
&lt;li&gt;Kleinberg, J., Tardos, E. Algorithm Design. Chapter 4.1-4.2.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/algorithm/2016/10/10/greedy-algorithm.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/10/10/greedy-algorithm.html</guid>
        
        <category>minimum spanning tree</category>
        
        <category>huffman encoding</category>
        
        <category>interval scheduling</category>
        
        <category>greedy</category>
        
        <category>algorithm</category>
        
        <category>CSC384</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Graph Algorithm</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dijkstra&amp;#39;s Algorithm&lt;/li&gt;
&lt;li&gt;Shortest Paths with Negative Edges&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h2&gt;Dijkstra&amp;#39;s Algorithm&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Shortest path problem&lt;/li&gt;
&lt;li&gt;Adapted from BFS with edge lengths positive&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Tricks&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Replace edges with len  1 with multiple edges of len 1 &amp;amp; dummy nodes&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Then run BFS&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Not efficient with more nodes!&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Implementation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Dijkstra(G, l, s):
# Input: Graph G = (V, E), directed or undirected;
         positive edge lengths {le : e ∈ E}; vertex s ∈ V
# Output: For all vertices u reachable from s, dist(u) is set to the distance from s to u

    for all u ∈ V : 
        dist(u) = ∞
        prev(u) = nil 
    dist(s) = 0

    H = makequeue(V) # using dist-values as keys 
    while H is not empty:
        u = deletemin(H) # = |V| times
        for all edges (u, v) ∈ E:
            if dist(v)  dist(u) + l(u, v): 
                dist(v) = dist(u) + l(u, v) 
                prev(v) = u 
                decreasekey(H, v) # = |V| + |E| times
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;# Alternative

Initialize dist(s) to 0, other dist(·) values to ∞ 
R = { } # the &quot;known region&quot;
while R != V:
    Pick the node v !∈ R with smallest dist(·) 
    Add v to R
    for all edges (v, z) ∈ E:
        if dist(z)  dist(v) + l(v, z): 
            dist(z) = dist(v) + l(v, z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; Binary heap: &lt;code&gt;O((|V| + |E|)log|V|)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Update Operation&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;dist(v) = min{dist(v), dist(u) + l(u, v)}&lt;/code&gt; &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Correct distance to v where u is second-last in shortest path &amp;amp; dist(u) is correct&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Never make dist(v) too small (i.e. never underestimate) = safe&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;Analysis - Heaps &amp;amp; Array&lt;/h4&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Implementation&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;deletemin&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;insert/decreasekey&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;&amp;#124;V&amp;#124;xdeletemin + (&amp;#124;V&amp;#124;+&amp;#124;E&amp;#124;)xinsert&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Array&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(&amp;#124;V&amp;#124;)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(&amp;#124;V&amp;#124;^2)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Binary heap&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(log&amp;#124;V&amp;#124;)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(log&amp;#124;V&amp;#124;)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O((&amp;#124;V&amp;#124; + &amp;#124;E&amp;#124;)log&amp;#124;V&amp;#124;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;d-ary heap&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(dlog&amp;#124;V&amp;#124;/log d)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(log&amp;#124;V&amp;#124;/log d)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(&amp;#124;V&amp;#124;*d + &amp;#124;E&amp;#124;log&amp;#124;V&amp;#124;/logd)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Fibonacci heap&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(log&amp;#124;V&amp;#124;)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(1) (amortizes)&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;O(&amp;#124;V&amp;#124;log&amp;#124;V&amp;#124; + &amp;#124;E&amp;#124;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;If G sparse - heap (|E| ~ |V|)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;If G dense - array (|E| ~ |V|^2)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Priority Queue Implementations&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Array&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;insert/decreasekey: &lt;code&gt;O(1)&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;deletemin: &lt;code&gt;O(n)&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Binary Heap

&lt;ul&gt;
&lt;li&gt;complete binary tree (filled in from left to right, full)&lt;/li&gt;
&lt;li&gt;key value &amp;lt;= childrens&amp;#39;

&lt;ul&gt;
&lt;li&gt;insert/decreasekey: &lt;code&gt;O(log n)&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;deletemin: &lt;code&gt;O(log n)&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;array representation: parent @ &lt;code&gt;floor(j/2)&lt;/code&gt;, children @ &lt;code&gt;2j&lt;/code&gt; &amp;amp; &lt;code&gt;2j+1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;d-ary heap

&lt;ul&gt;
&lt;li&gt;nodes have d children&lt;/li&gt;
&lt;li&gt;h(T) = &lt;code&gt;Θ(log d n)&lt;/code&gt; = &lt;code&gt;Θ((log n)/(log d))&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;insert: &lt;code&gt;Θ((log n)/(log d))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;deletemin: &lt;code&gt;Θ(d * log d n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;array representation: parent @ &lt;code&gt;(j-1)/d&lt;/code&gt;, children @ &lt;code&gt;{(j-1)d+2, ..., min{n, (j-1)d+d+1}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Shortest Paths with Negative Edges&lt;/h2&gt;

&lt;h3&gt;&lt;em&gt;Bellman-Ford Algorithm&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Update &lt;em&gt;all&lt;/em&gt; edges &lt;code&gt;|V|-1&lt;/code&gt; times!&lt;/p&gt;

&lt;h4&gt;Implementation&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;Shortest-paths(G, l, s):
# Input: Directed graph G = (V, E);
         edge lengths {le : e ∈ E} with no negative cycles; 
         vertex s ∈ V
# Output: For all vertices u reachable from s, dist(u) is set to the distance from s to u
    for all u ∈ V : 
        dist(u) = ∞
        prev(u) = nil

    dist(s) = 0
    repeat |V | − 1 times:
        for all e ∈ E: 
            update(e)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;=&amp;gt; &lt;code&gt;O(|V|*|E|)&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;Termination&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;No update occurred (assume no &lt;strong&gt;negative cycles&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;After &lt;code&gt;|V|-1&lt;/code&gt; times of iterations, apply 1 extra round. If some &lt;code&gt;dist&lt;/code&gt; reduced &amp;lt;- negative cycle&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dasguptap, S., Papadimitriou, C.H., &amp;amp; Vazirani, U.V. Algorithms. Chapter 4.1-4.6.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/algorithm/2016/10/10/graph-algorithm.html</link>
        <guid isPermaLink="true">/blog/notes/algorithm/2016/10/10/graph-algorithm.html</guid>
        
        <category>dijkstra's</category>
        
        <category>bellman-ford</category>
        
        <category>graph</category>
        
        <category>data structure</category>
        
        <category>algorithm</category>
        
        <category>CSC384</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>Algorithm</category>
        
      </item>
    
      <item>
        <title>Linked List Basic</title>
        <description>&lt;h2&gt;Content&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;What is Linked List?&lt;/li&gt;
&lt;li&gt;Linked List v.s. Array&lt;/li&gt;
&lt;li&gt;Visualizing Linked List&lt;/li&gt;
&lt;li&gt;Basic examples (in C)&lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;hr&gt;

&lt;h1&gt;What is Linked List?&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Linked lists&lt;/em&gt; use &lt;strong&gt;dynamically allocated memories&lt;/strong&gt; as data storage, and associate these storages with &lt;strong&gt;pointers&lt;/strong&gt;. &lt;/p&gt;

&lt;p&gt;Well, you may just think of &lt;em&gt;linked lists&lt;/em&gt; as arrays that are &lt;strong&gt;resizable&lt;/strong&gt;, easily &lt;strong&gt;rearrangible&lt;/strong&gt;, with &lt;strong&gt;non-consecutive&lt;/strong&gt; slots. &lt;/p&gt;

&lt;h1&gt;Linked List v.s. Array&lt;/h1&gt;

&lt;p&gt;Everyone likes comparisons. So the properties of linked list &amp;amp; array here -&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Linked List&lt;/th&gt;
&lt;th style=&quot;text-align: left&quot;&gt;Array&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;* Dynamic size&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Fixed size&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;* Cheaper insertion&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Expensive insertion&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;No random access&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;* Random Access&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;---&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;* Better cache performance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align: left&quot;&gt;Extra memory space&lt;/td&gt;
&lt;td style=&quot;text-align: left&quot;&gt;* ---&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We must know how many elements to allow when defining an array; &lt;strong&gt;linked lists&lt;/strong&gt; allowes more flexibility.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;To insert an element into array, we probably need to move a whole bunch of elements backwards for the newcomer to fit. For &lt;strong&gt;linked lists&lt;/strong&gt;, it&amp;#39;s just about switching between some pointers and that&amp;#39;s it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Memories are allocated consecutively for arrays, which mean calculating &lt;code&gt;arr[5]&lt;/code&gt;, &lt;code&gt;arr[10]&lt;/code&gt;, &lt;code&gt;arr[1000]&lt;/code&gt; are all about adding offsets to &lt;code&gt;arr[0]&lt;/code&gt;, which is quite cheap. But for &lt;strong&gt;linked lists&lt;/strong&gt;, the memories are dynamically allocated on heap and do not have this luxury.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Moreover for consecutive memories, the cache performance is better, since a whole bunch of array elements that fit into the cache size will be fetched all at once.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Linked lists&lt;/strong&gt; requires more memory space than arrays due to the fact that pointers are required.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Visualizing Linked List&lt;/h1&gt;

&lt;p&gt;OK, so what&amp;#39;s the picture of &lt;em&gt;linked lists&lt;/em&gt;? It all starts with a pointer (&lt;code&gt;*list&lt;/code&gt;), followed by a list of nodes (&lt;code&gt;node_i&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;
  []   -&amp;gt;   [_]  -&amp;gt;  [_]  -&amp;gt; ...  -&amp;gt;  [_]  -&amp;gt;  NULL
*list     node_1   node_2    ...    node_N

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hold on, some structures need to be defined for &lt;strong&gt;lists&lt;/strong&gt; and &lt;strong&gt;nodes&lt;/strong&gt; before you can easily mingle with the crazy pointers.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// holding the value of the node; can be any type or have multiple value fields
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// pointing to the next node in list
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SinglyLinkedList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// pointing to the first node in list
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// count of nodes in list; optional field
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SinglyLinkedList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SinglyLinkedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;h4&gt;Haven&amp;#39;t seen &lt;code&gt;typedef&lt;/code&gt; before?&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;typedef&lt;/code&gt; provides an easy way to define types so that you don&amp;#39;t have to type in so many words when declaring a variable with that data type.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typedef [actual-data-type] [a-convenient-name]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So in C, after defiing a struct (e.g. Node), everytime you wanna declare a Node, you type &lt;code&gt;struct Node n&lt;/code&gt;. Now I know how to alias &lt;code&gt;struct Node&lt;/code&gt; into &lt;code&gt;Node&lt;/code&gt; by &lt;code&gt;typedef&lt;/code&gt;!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typedef struct Node Node;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then we&amp;#39;re ready to use these structs and build a linked list.&lt;/p&gt;

&lt;h1&gt;Basic Examples (in C)&lt;/h1&gt;

&lt;h3&gt;Initialization&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;n&quot;&gt;SinglyLinkedList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SinglyLinkedList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;malloc&lt;/code&gt; stands for memory allocation, which is similar to the &lt;code&gt;new&lt;/code&gt; keyword in C++.&lt;br&gt;
You pass in the size of memory you want to allocate, so for a &lt;code&gt;SinglyLinkedList&lt;/code&gt; struct, its
&lt;code&gt;sizeof(SinglyLinkedList)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Adding a node to list&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;cm&quot;&gt;/*      []     -&amp;gt;    NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list                 */&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// create a node
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// give the node a value
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// the node is not linked by other nodes yet
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// add it to the head of the list
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*      []     -&amp;gt;    [1]    -&amp;gt;     NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list           ↑                   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                   *n                   */&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// remove it from the list
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt;      NULL    [1] -&amp;gt;  NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list                  ↑             */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                           *n            */&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// destroy it by releasing its memory
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*      []     -&amp;gt;    NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list                 */&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Always free your malloc&amp;#39;ed memories to avoid memory leak.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Adding nodes to list&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;c1&quot;&gt;// declare pointer temp_n to point to the head of the empty list
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// create new node
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// add to the head of the list
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if list empty, let head point to n
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// else let the currently pointed node link to n (by assigning *next to point to n)
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; [0] -&amp;gt; [1] -&amp;gt; [2] -&amp;gt; ... -&amp;gt; [999] -&amp;gt;  NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list     ↑  -&amp;gt;  ↑  -&amp;gt;  ↑     ... -&amp;gt;   ↑              */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*          *temp_n *temp_n *temp_n        *temp_n          */&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Use a temp node pointer to move around the list.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;List traversal&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// move forward the cursor
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sum: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Insert a node into list&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; [0] -&amp;gt; [1] -&amp;gt; [2] -&amp;gt; ... -&amp;gt; [999] -&amp;gt;  NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list                                                 */&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// inserting into index 5 of list
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;87&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// traverse through the list to find index; assume we don't check if index is valid
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; ... -&amp;gt; [4] -&amp;gt; [5] -&amp;gt; ... -&amp;gt;  NULL   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list            ↑                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                  *temp_n                        */&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// insert by moving around pointers
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*                    *n  -&amp;gt; [87]                          */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                             ↓                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; ... -&amp;gt; [4] -&amp;gt;  [5]   -&amp;gt; ... -&amp;gt;  NULL        */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list            ↑                                   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                  *temp_n                                */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*                    *n  -&amp;gt; [87]                          */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                         ⬈   ↓                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; ... -&amp;gt; [4]     [5]   -&amp;gt; ... -&amp;gt;  NULL        */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list            ↑                                   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                  *temp_n                                */&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Remove a node from list&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// removing node at index 5 of list
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// traverse through the list to find index; assume we don't check if index is valid
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; ... -&amp;gt; [4] -&amp;gt; [87] -&amp;gt; ... -&amp;gt;  NULL  */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list            ↑                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                  *temp_n                        */&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// remove by moving around pointers; notice that we're removing temp_n-&amp;gt;next instead of temp-&amp;gt;n
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// n = node to remove
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// connect the previous node and the next node
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                            *n                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                             ↓                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; ... -&amp;gt; [4] -&amp;gt;  [87]   -&amp;gt; ... -&amp;gt;  NULL       */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list            ↑                                   */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                  *temp_n                                */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*                            *n                                    */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                             ↓                                    */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*      []  -&amp;gt; ... -&amp;gt; [4]     [87]   -&amp;gt;  [5]  -&amp;gt; ... -&amp;gt;  NULL       */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*    *list            ↑  \_____________⬈                           */&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*                  *temp_n                                         */&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// release memory
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Destroy the whole list before program ends&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// finally, free list as well
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Linked lists&lt;/strong&gt; are the most basic data structure to know and deal with, and its application is wide, such as creating trees. Make sure you can construct a valid linked list before you move on to the more complicated pointer-related data structure!&lt;/p&gt;

&lt;p&gt;Source code can be found at &lt;a href=&quot;https://github.com/pyliaorachel/data-structure-and-algorithm/blob/master/DataStructures/LinkedList/Implementations/linked-list.c&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/linked-list-vs-array/&quot;&gt;GeeksforGeeks - Linked List vs Array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 08 Oct 2016 00:00:00 -0400</pubDate>
        <link>/blog/notes/datastructure/2016/10/08/linked-list-basic.html</link>
        <guid isPermaLink="true">/blog/notes/datastructure/2016/10/08/linked-list-basic.html</guid>
        
        <category>data structure</category>
        
        
        <category>Blog</category>
        
        <category>Notes</category>
        
        <category>DataStructure</category>
        
      </item>
    
  </channel>
</rss>
